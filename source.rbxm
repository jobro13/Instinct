<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Model" referent="RBX31ed1725ce004cebb36a8d2ff7ab59f0">
		<Properties>
			<CoordinateFrame name="ModelInPrimary">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
				<R00>1</R00>
				<R01>0</R01>
				<R02>0</R02>
				<R10>0</R10>
				<R11>1</R11>
				<R12>0</R12>
				<R20>0</R20>
				<R21>0</R21>
				<R22>1</R22>
			</CoordinateFrame>
			<string name="Name">Include</string>
			<Ref name="PrimaryPart">null</Ref>
		</Properties>
		<Item class="Script" referent="RBX4b463146947b4a7bbc9eff90eed0feed">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Instinct</string>
				<ProtectedString name="Source"><![CDATA[-- Instinct --
-- Master loader --

-- Solution for the Constructor-Loads-Depenedencies:
-- > Add a list of dependencies to every class
-- > Auto-add to constructor

local Instinct = {}
Instinct.Sources = {} -- Sources, by name

function Instinct:Flush()
	_G.Instinct = {}
end
-- Load module from String, seperated by Seperator
-- Looks inside Source to find given module
function Instinct:Load(String, Source, Seperator)
	local Where = _G.Instinct
	local Inst = Source
	local LastMatch
	for match in string.gmatch(String, "[^" .. (Seperator or "/") .. "]+") do
		if LastMatch then
			if Where[LastMatch] then
				Where = Where[LastMatch]
			else
				Where[LastMatch] = {}
				Where = Where[LastMatch]
			end
			Inst = Inst:FindFirstChild(LastMatch)
		end
		LastMatch = match
	end
	-- Reached target instance --
	local Target = Inst:FindFirstChild(LastMatch)
	if Target then
		local Loaded = require(Target)
		if type(Loaded) == "table" then
			Where[LastMatch] = Instinct:Create(Loaded) -- provide new copy
		elseif type(Loaded) == "function" then
			Loaded()
		else
			print("Got strange module, type: ".. type(Loaded) .. " name: " .. String)
		end
	end
end


function Instinct:AddSource(source, name)
	if not source then
		error("Cannot add source " .. tostring(source) .. " doesn't exist")
	end
	self.Sources[name] = source
end

local ClassMeta = {}

-- Using __index, can later add more functionality
-- Current behaviour is same as __index=table
function ClassMeta:__index(Index)
	local ExtClass = rawget(self, "Extends")
	if ExtClass then
		return ExtClass[Index]
	end
end

-- Last version used Parent structure; not necessary, removing.
--[[
function ClassMeta:__newindex(Index, Value)
	
end
--]]

ClassMeta.__call = function(tab, ...)
	if tab.Call then
		return tab.Call(...)
	end
end

-- MS = ModuleScript input; require this script and create a proxy for it
function Instinct:GetChild(MS)
	local Master = require(MS)
	return self:Create(Master)
end

function Instinct:Create(Master)
	local OBJ = {Extends=Master}
	setmetatable(OBJ, ClassMeta)
	if OBJ.Constructor then 
		OBJ:Constructor()
	end
	return OBJ 
end


-- Set loading type; (Server | Local)
function Instinct:SetType(Type)
	self.Type = Type
end

return Instinct]]></ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX1991e8d6546f4078ae32e951411e2e44">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Version</string>
				<ProtectedString name="Source">return &quot;0.1.1&quot;</ProtectedString>
			</Properties>
		</Item>
		<Item class="Folder" referent="RBX3092db4e40044c3eaf53d3c7f0809285">
			<Properties>
				<string name="Name">Data</string>
			</Properties>
			<Item class="Script" referent="RBX576abf932f9545db93e9f5ae32e4cc08">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Actions</string>
					<ProtectedString name="Source"><![CDATA[-- Should be loaded AFTER all services and other BS are loaded
-- Loads the action hooks
-- Action hooks;

-- Run(Target, Tool) -> (tool is optional) runs given actions. IS already confirmed to be ok
-- Check(Target, Tool) -> 


return (function()
local IntentionService = _G.Instinct.Services.IntentionService
local ToolService = _G.Instinct.Services.ToolService
local DamageService = _G.Instinct.Services.DamageService

local toadd ={}
local function mk(name)
	local o = {Name=name}
	table.insert(toadd, o)
	return o
end

-- START ACTION INSPECT DEAD CORPSE 
local InspectBackpack = mk "Inspect Backpack"

local IBS_Open = nil; -- inspect backpack open debouncher.

function InspectBackpack:Run(targ)
	if IBS_Open then
		return --no.
	end
	local r = targ
	if targ.Name ~= "Backpack" then
		if targ.Name == "chParent" then 
			r = targ.Parent
		end
	end
	if r and r:FindFirstChild("BPRootLocation") then
		if r.BPRootLocation.Value then
			-- good. let's get sidebar.
			local newsidebar = _G.Instinct.Create(_G.Instinct.Gui.SideBar)
			IBS_Open = newsidebar
			local root = r.BPRootLocation.Value
			_G.Instinct.Gui.SideBar:ForceClose() --> close own inventory.
			
			newsidebar.Root.Sidebar.RealBar.Tabs:ClearAllChildren()
			local close_button_loc = newsidebar.Root.Sidebar.RealBar.Tabs
			local new = Instance.new("TextButton", close_button_loc)
			new.Size = UDim2.new(0.9, 0, 0.9, 0)
			new.Position = UDim2.new(0.05, 0, 0.05,0)
			new.BackgroundTransparency = 0.8
			new.Text = "Close"
			new.FontSize = Enum.FontSize.Size24
			new.Font = Enum.Font.SourceSans
			new.BorderSizePixel=0
			new.ZIndex=3
			
			new.MouseButton1Click:connect(function()
				newsidebar:Destroy() -- removes gui.
				IBS_Open = nil
				_G.Instinct.Gui.SideBar:EnableOpen()
			end)
			
			for i,v in pairs(root:GetChildren()) do
				newsidebar:AddBackpackItem(v)
			end
			root.ChildRemoved:connect(function(v)
				newsidebar:RemoveBackpackItem(v)
			end)
			
			function newsidebar:RequestDrop(v)
				local comm = _G.Instinct.Communicator
				comm:Send("SwapBackpack", v)
			end
			
			-- we are done; open
			newsidebar:MakeVisible() -- done drawing
			newsidebar:Open()
		end
	end
end
	

-- Shake tree action LOL KAPPA XDDDDD JOBRO SO FUCKING TRASH-- 	
local ShakeTree = mk "Shake tree"

function ShakeTree:Run(targ)
	print("oh very shake tree Kappa")
end

-- Attack action --
local Attack = mk "Attack"

function Attack:Run(Targ, Hand)
	print("WAT attack? jobro13 so trashhh XDDD")
	local Tool = ToolService["Equipped"..Hand]
	print(Tool, Hand)
	if Tool then
		print("EXISITSerino	")
		DamageService:Attack(Tool, Targ)
	end
end

for _,action in pairs(toadd) do
	IntentionService:AddAction(action)
end
	
end)]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBXf7d30db0db01419f9d07755d4d380e5d">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Clothing</string>
					<ProtectedString name="Source"><![CDATA[return (function() local toadd = {}
local function mk(n)
	local o = {Name=n}
	table.insert(toadd,o)
	return o
end

local ClothingService = _G.Instinct.Services.ClothingService

local dr = game:GetService "ServerStorage"
local r = dr.Clothing

local Backpack = mk "Backpack"
Backpack.Grip = CFrame.new(0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1) * CFrame.Angles(0,math.pi,0)
Backpack.Root = r.Backpack
Backpack.BodyPart = "Torso"

local Shirt = mk "Shirterino"
Shirt.Grip = CFrame.new(0,-0.2, 0.04, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Shirt.Root = r.Shirt
Shirt.BodyPart = "Torso"

local LeftPants = mk "LeftPants"
LeftPants.Grip = CFrame.new(0, 0.42, 0.01, 1, 0, 0, 0, 1, 0, 0, 0, 1)
LeftPants.Root = r.LeftPants
LeftPants.BodyPart = "Left Leg"

local RightPants = mk "RightPants"
RightPants.Grip =  CFrame.new(0, 0.42, 0.01, 1, 0, 0, 0, 1, 0, 0, 0, 1)
RightPants.Root = r.RightPants
RightPants.BodyPart = "Right Leg"

for i,v in pairs(toadd) do
	ClothingService:AddCloth(v)
end
end)]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBXb2599fa898514f4898078728211589d3">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">CommandsLocal</string>
					<ProtectedString name="Source"><![CDATA[-- Command gets called with info packet and data
local Commands = {}

local Chat = _G.Instinct.Mechanics.Chat


function Commands.Test(Data, arg1)
	--warn(arg1, "cmds work")
end

function Commands.Chat(Data, Message, Mode, Sender)

	if _G.Instinct.Gui and _G.Instinct.Gui.Chat then 
		_G.Instinct.Gui.Chat:Process(Message, Mode, Sender)
	end
end

-- Ugly hack because setting character stuff from server is a big NOPE with Repl off
function Commands.SetSkinColor(Data, Color)
	local ch = game.Players.LocalPlayer.Character
	for i,v in pairs(ch:GetChildren()) do
		if v:IsA("BasePart") then
			v.BrickColor = BrickColor.new(Color)
		end
	end
end

return Commands]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBXf7ccf06822e54640a9cb065a574e29a2">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Resources</string>
					<ProtectedString name="Source"><![CDATA[return function()

local Instinct = _G.Instinct
local Object = _G.Instinct.Class.Object
local ObjectService = Instinct.Services.ObjectService
-- This part should be in a "Properties" data file -- 
local Property = Instinct.Class.Property
local new = Instinct.Create(Property)
new.Mode.ShowInfo = true
new.Name = "Material"
ObjectService:AddProperty(new)
print("add")


 -- //// START RESLIST
-- FLOWER
-- mk object
local FL = Instinct.Create(Object)
-- set name
FL.Name = "Flower"
-- What properties must be saved (resp. Save rule names)
FL.SaveDataList = {"Size", "Color"}
-- When moving, what should happen (moverules)
FL.MoveRuleList = {"UnanchorAll", "UnweldAll", "Ungroup"}
-- Evt. Special function which defines gather behaviour
FL.CheckGather = true -- no special function needed.
-- density, kg/m3
FL.Density = 0.01
-- damage;
FL.DamageType = "Crush"
-- base damage
FL.BaseDamage = 0.01
-- hardness
FL.Hardness = 0.01

-- FLOWRE STALK
local FLS = Instinct.Create(Object)
FLS.Name = "Flower Stalk"
FLS.SaveDataList = {"Size", "Color"}
FLS.MoveRuleList = {"UnanchorAll", "UnweldAll", "Ungroup"}
FLS.CheckGather = true
FLS.Density = 0.05
FLS.BaseDamage = 0.1
FLS.Hardness = 0.01
FLS.DamageType = "Cut"

ObjectService:AddObject(FL)
ObjectService:AddObject(FLS)

-- STONES -- 
local Stone = Instinct.Create (Object)

Stone.Name = "Stone"
Stone.Material = "Stone"
Stone.ToolToGatherWhenAnchored = "Pickaxe"
Stone.SaveDataList = {"Size"}
Stone.MoveRuleList = {"UnanchorAll", "UnweldAll", "Ungroup"}
Stone.BuildingMaterial = true
Stone.Hidden = true -- hide stone from resources
Stone.BaseDamage = 3
Stone.DamageType = "Crush"

function Stone:CheckGather(Inst)
	if (Inst:IsA("BasePart") and Inst.Anchored) or Inst:FindFirstChild("Weld") then 
		return false, {"Use a pickaxe to gather this resource"}, "Mine"
	end
	return true
end

ObjectService:AddObject(Stone)


local ToolHead = Instinct.Create(Object)
ToolHead.SaveDataList = {}

ToolHead.CheckGather = true

function ToolHead:GetBaseDamage(Tool)
	local n = Tool.Tool.Name
	local obj = ObjectService:GetObject(n)
	local mat = obj:GetContext(Tool.Tool, "Material")[1]
	print(mat)
	if mat then
		local obj = self:GetObject(mat)
		if obj then
			return {Hardness = obj.Hardness, Density = obj.Density}
		end
	end
end

local Axe = ToolHead:CreateExtension("Axe")
Axe.DamageType = "Cut"
Axe.BaseDamage = 10
ObjectService:AddObject(Axe)
 
local Knife = ToolHead:CreateExtension("Knife")
Knife.DamageType = "Cut"
Knife.BaseDamage = 20
ObjectService:AddObject(Knife)

local Pickaxe = ToolHead:CreateExtension("Pickaxe")
Pickaxe.DamageType = "Hack"
Pickaxe.BaseDamage = 15
ObjectService:AddObject(Pickaxe)


local StoneTypes = {
	"General",
	"River",
	"Pressured",
	"Volcanic",
	"All"
}

local Instinct = _G.Instinct
Instinct.Utilities.Options.New("StoneType", StoneTypes)

local stonedata = {}

_G.StoneData = stonedata
stonedata.StonesInStoneType = {}

local data = {
	[Instinct.Options.StoneType.General] = {
			Flint = {
				Rarity = 0.75,
				OreBoost = "Chalcopyrite",
				Hardness = 4,
				Density = 2.6
			},
			Chert = {
				Rarity = 4,
				OreBoost = "Franklinite",
				Hardness = 2,	
				Density = 2.65			
				
			},
			Chalk = {
				Rarity = 6,
				OreBoost = "Malachite",
				Hardness = 1,	
				Density = 2.4			
			},
			Coal = {
				Rarity = 2.5,
				OreBoost = "Cuprite",
				Hardness = 3,
				Density = 1.4
			},
			Shale = {
				Rarity = 11,
				OreBoost = "Cassiterite",
				Hardness = 2,
				Density = 2.6
			},
		},
	[Instinct.Options.StoneType.River] = {
		Sandstone = {
			Rarity = 10,
			OreBoost = "Pyrite",
			Hardness = 5,
			Density = 2.6
		},
		Mudstone = {
			Rarity = 3,
			OreBoost = "Cuprite",
			Hardness = 1,
			Density = 2.7
		},
		Breccia = {
			Rarity = 1,
			OreBoost = "Bismite",
			Hardness = 4,
			Density = 2.5
		},
		Dolomite = {
			Rarity = 5,
			OreBoost = "Nordenskioldine",
			Hardness = 5,
			Density = 2.9
			
		},
		Limestone = {
			Rarity = 8,
			OreBoost = "Malachite",
			Hardness = 3,	
			Density = 2.5		
		}
	},
	[Instinct.Options.StoneType.Pressured] = {
		Blueschist = {
			Rarity = 1,
			OreBoost = "Pyrolusite",
			Hardness = 7,
			Density = 1.8
		},
		Gneiss = {
			Rarity = 8,
			OreBoost = "Malachite",
			Hardness = 6,
			Density = 2.9
		},
		Quartzite = {
			Rarity = 0.5,
			OreBoost = "Pentlandite",
			Hardness = 8,
			Density = 2.8
		},
		Marble = {
			Rarity = 3,
			OreBoost = "Cassiterite",
			Hardness = 7,
			Density = 2.5
		},
		Slate = {
			Rarity = 10,
			OreBoost = "Stannite",
			Hardness = 9,
			Density = 2.8
		}
	},
	[Instinct.Options.StoneType.Volcanic] = {
		Obsidian = {
			Rarity = 0.3,
			OreBoost = "Chromium",
			Hardness = 11,
			Density = 2.4
		},
		Andesite = {
			Rarity = 5,
			OreBoost = "Chalcopyrite",
			Hardness = 11,
			Density = 2.5
		},
		Latite = {
			Rarity = 8,
			OreBoost = "Hematite",
			Hardness = 10,
			Density = 2.2
		},
		Rhyolite = {
			Rarity = 4,
			OreBoost = "Cassiterite",
			Hardness = 14,			
			Density = 2.6
		},
		Feldspar = {
			Rarity = 12,
			OreBoost = "Malachite",
			Hardness = 18,
			Density = 2.6
			
		}
		
	}
	
}

for StoneType, StoneData in pairs(data) do 
	for name, data in pairs(StoneData) do 
		local obj = Stone:CreateExtension(name)

		local new = Stone:CreateExtension(name)
		new.StoneType = StoneType


		for setting, settingdata in pairs(data) do 
			new[setting] = settingdata
			obj[setting] = settingdata
		end
		_G.StoneData[name] = new
		new.Material = "Stone"
		ObjectService:AddObject(new)

		if _G.StoneData.StonesInStoneType[StoneType] then
			table.insert(_G.StoneData.StonesInStoneType[StoneType], new)
		else
			_G.StoneData.StonesInStoneType[StoneType] = {new}
		end
	end	

end

local holder = {}

local Ore = Instinct.Create(Object)

Ore.Name = "Ore"
Ore.CheckGather=true
Ore.SaveDataList = {"Size"}
Ore.DamageType = "Crush"
Ore.BaseDamage = 1

ObjectService:AddObject(Ore)


_G.OreData = holder
_G.OreData.OresInStoneType = {}


local data = {
	Chalcopyrite = {
		Contents = {Cu = 34.6, Fe = 30.4},
		Rarity = 8,
		StoneType = Instinct.Option.StoneType.General,
		Density = 4.1
	},
	Cuprite = {
		Contents = {Cu = 88.8},
		Rarity = 1,
		StoneType = Instinct.Option.StoneType.General,
		Density = 6.14
	},
	Malachite = {
		Contents = {Cu = 57.3},
		Rarity = 10,
		StoneType = Instinct.Option.StoneType.All,
		Density = 3.7,
	},
	Cassiterite = {
		Contents = {Sn = 78.8},
		Rarity = 1,
		StoneType = Instinct.Option.StoneType.All,
		Density = 7,
	},
	Stannite = {
		Contents = {Cu = 29.6, Sn = 27.6, Fe = 13.0},
		Rarity = 3,
		StoneType = Instinct.Option.StoneType.General,
		Density = 4.3
	},
	Nordenskioldine = {
		Contents = {Sn = 43.0},
		Rarity = 7,
		StoneType = Instinct.Option.StoneType.General,
		Density = 4.1
		
	},
	Sphalerite = {
		Contents = {Zn = 67.1},
		Rarity = 0.25,
		StoneType = Instinct.Option.StoneType.General,
		Density = 3.9
	},
	Franklinite = {
		Contents = {Zn = 27.1, Fe = 46.3},
		Rarity = 0.75,
		StoneType = Instinct.Option.StoneType.General,
		Density = 5.1
	},
	Pyrite = {
		Contents = {Fe = 46.5},
		Rarity = 10,
		StoneType = Instinct.Option.StoneType.Pressured,
		Density = 4.8
	},
	Bismuthinite = {
		Contents = {Bi = 81.3},
		Rarity = 0.6,
		StoneType = Instinct.Option.StoneType.River,
		Density = 6.8
	},
	Bismite = {
		Contents = {Bi = 89.7},
		Rarity = 0.3,
		StoneType = Instinct.Option.StoneType.River,
		Density = 8.7
	},
	Stibnite = {
		Contents = {Sb = 71.7},
		Rarity = 0.25,
		StoneType = Instinct.Option.StoneType.River,
		Density = 4.63
	},
	Cobaltite = {
		Contents = {As = 45.2},
		Rarity = 1,
		StoneType = Instinct.Option.StoneType.River,
		Density = 6.3
	},
	Hematite = {
		Contents = {Fe = 69.9},
		Rarity = 6,
		StoneType = Instinct.Option.StoneType.Volcanic,
		Density = 5.3
	},
	Pyrolusite = {
		Contents = {Mn = 63.2},
		Rarity = 0.8,
		StoneType = Instinct.Option.StoneType.Pressured,
		Density = 5.1
	},
	["Native Silver"] = {
		Contents = {Ag = 80.5},
		Rarity = 0.08,
		StoneType = Instinct.Option.StoneType.Pressured,
		Density = 10.1
	},
	["Native Gold"] = {
		Contents = {An = 75.3},
		Rarity = 0.01,
		StoneType = Instinct.Option.StoneType.River,
		Density = 17;
	},
	Pentlandite = {
		Contents = {Ni = 41.0},
		Rarity = 10	,
		StoneType  = Instinct.Option.StoneType.Pressured,
		Density = 4.6
	},
	Chromite = {
		Contents = {Cr = 41.9},
		Rarity = 0.2,
		StoneType = Instinct.Option.StoneType.Volcanic ,
		Density = 4.6
		
	},
	Galena = {
		Contents = {Pb = 86.6},
		Rarity = 4,
		StoneType = Instinct.Option.StoneType.Volcanic,
		Density = 7.6
	},
	Beryl = {
		Contents = {Si = 31.0},
		Rarity = 1,
		StoneType = Instinct.Option.StoneType.Volcanic,
		Density = 2.7
	}

}

_G.OreData.OresInStoneType = {}

for OreName, OreData in pairs(data) do
	local new = {}
	new.Name = OreName

	local obj = Ore:CreateExtension(OreName)


	for setting, value in pairs(OreData) do
		new[setting] = value
		obj[setting] = value 
	end
	obj.Material = "Ore"
	ObjectService:AddObject(obj)
	_G.OreData[OreName] = new
	if _G.OreData.OresInStoneType[OreData.StoneType] and OreData.StoneType ~= Instinct.Option.StoneType.All then 
		table.insert(_G.OreData.OresInStoneType[OreData.StoneType], new)
	elseif  OreData.StoneType ~= Instinct.Option.StoneType.All then
		_G.OreData.OresInStoneType[OreData.StoneType] = {new}
	end
	
end

local new = Instinct.Create(Object)
new.Name = "Wood"
new.BuildingMaterial = true
new.Material = "Wood"
new.ToolToGatherWhenAnchored = "Axe"
new.ToolToGatherWhenWelded = "Axe"
new.ResizeTool = "Axe"
new.GatherVolumeMaximum = 2^3
new.SaveDataList = {"Size", "Color"}
new.MoveRuleList = {"UnanchorAll", "UnweldAll", "Ungroup"}
new.DamageType = "Crush"
new.BaseDamage = 4-- stick epic damage
new.Density = 0.7-- depends on wood, add later.
new.Hardness = 3

function new:CheckGather(Inst)
	local val = self:GetContext(Inst, "ChoppedDown")
	if val == 1 then
		return false, {"Use an axe to remove the leaves"}, "Chop"
	elseif val == 2 then
		return true
	else 
		return false, {"Use an axe to chop the tree down"}, "Chop", {Left="Shake tree"}
	end
end

ObjectService:AddObject(new)


-- le foliage

local Foliage = Instinct.Create(Object)
Foliage.Name = "Foliage"
Foliage.BuildingMaterial =true
Foliage.GatherVolumeMaximum = 2^3
Foliage.Material = "Leaves"
Foliage.ResizeTool = "Knife"
Foliage.SaveDataList = {"Size", "Color"}
Foliage.MoveRuleList = {"UnanchorAll", "UnweldAll", "Ungroup"}
Foliage.DamageType = "Cut"
Foliage.Hardness = 0.05
Foliage.Density = 0.4

function Foliage:CheckGather(Inst)
	if Inst.Parent.Name == "Wood" then
		return false, {"Chop the tree down with an axe"}, nil
	else
		return true
	end
end
ObjectService:AddObject(Foliage)
-- NEED KNIVE WHEN ANCHORED ?

local Apple = Instinct.Create(Object)
Apple.Name = "Apple"
Apple.SaveDataList = {"Size", "Color"} -- realy
Apple.MoveRuleList = {"Unweld", "Unanchor"}
Apple.CheckGather = true
Apple.Edible = {Hunger = 10, Thirst = 3}; -- edible value per studs^3
Apple.Hardness = 0.05
Apple.Density = 0.8
Apple.DamageType = "Crush"
function Apple:CustomVolume(inst) -- custom volume function; 
	if inst:IsA("BasePart") then
		local r = inst.Size.x/2
		return math.pi * 4/3 * r^3
	end
end
ObjectService:AddObject(Apple)


------------------------------------
------------------------------------
------------------------------------
--									--
--			SAVING RULES 			--
------------------------------------

local function addr(r,name)
	r.Name=r.Name or name
	ObjectService:AddRule(r,name,"Save")
end

-- SIZE RULE --
local Size = {}
Size.To = function(inst)
	local size = inst.Size
	local out = {x=size.X, y = size.Y, z=size.Z}
	return out
end

Size.From = function(data, instance)
	instance.Size = Vector3.new(data.x, data.y, data.z)
end
addr(Size,"Size")

local Colour = {}
Colour.To = function(inst)
	return inst.BrickColor.Number
end
Colour.From = function(data, inst)
	inst.BrickColor = BrickColor.new(data)
end
addr(Colour, "Color") -- QQ

local MaterialContext = {}

function MaterialContext.From(data, inst)
	local propcpy = {"Material", "BrickColor", "Reflectance", "Transparency"}
	-- only checks for stones
	print("called", inst.Name)
	warn("CALLED!!")
	-- please make a "STYLE" rule
	ObjectService:CopyStyle(game:GetService("ServerStorage").Mining:FindFirstChild(data), inst, propcpy)
	-- please move this somewhere else.. --	
	ObjectService:WeldObject(inst)		
end

MaterialContext.To = function() end

addr(MaterialContext, "ContextMaterial") -- qq

---- MOVERULES
-----
------
------
-------
local function addmvr(rule, name)
	ObjectService:Add(rule,name, "Move")
end

local unanchor = function(r)
	if r:IsA("BasePart") then
		r.Anchored=false
	else
		warn("no unanchor for models")
	end
end
addmvr(unanchor, "Unanchor")


local unweld = function(r)
	r:BreakJoints() -- works for mods/parts
end
addmvr(unweld, "Unweld")

function generic_inmod(where, func)
	local x = where
	while x.Parent and not x.Parent:IsA("Model") do
		x = x.Parent
	end
	local mod
	if x.Parent.Parent == game.Workspace then 
		mod = x
	elseif x.Parent.Parent == game.Workspace.Mine then 
		mod =x
	else
		mod = x.Parent
	end
	print("inmod " .. where:GetFullName(), mod:GetFullName())
	local function re(where)
		for i,v in pairs(where:GetChildren()) do
			if v:IsA("BasePart") then
				func(v, mod)
			end
			re(v)
		end
	end
	re(mod)
	func(mod, mod)
end

local unweld_all = function(r)
	generic_inmod(r, function(c) c:BreakJoints() end)
end

local unanchor_all = function(r)
	generic_inmod(r, function(c) if c:IsA("BasePart") then c.Anchored=false end end)
end
addmvr(unweld_all, "UnweldAll")
addmvr(unanchor_all, "UnanchorAll")

local ungroup = function(r)
	local c = r
	while c.Parent and not c.Parent:IsA("Model") do
		c = c.Parent
	end
	local root
	if c.Parent.Parent == game.Workspace then 
		root = c
	elseif c.Parent.Parent == game.Workspace.Mine then 
		root =c 
	else
		root = c.Parent
	end
print("inmod " .. r:GetFullName(), root:GetFullName())
	local function re(where)
		for i,v in pairs(where:GetChildren()) do
			if v:IsA("BasePart") and v ~= r then
				if root == r then 
					v.Parent=root.Parent				
				else 
					v.Parent = root
				end
			end
			re(v, root)
		end
	end
	re(root, root)
end

addmvr(ungroup, "Ungroup")

end]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX5897b66b32c44bd894b66dc016e1c9fe">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Tools</string>
					<ProtectedString name="Source"><![CDATA[return function()
	-- Fix recipe check for move/bild
local Instinct = _G.Instinct
local Tool = Instinct.Class.Tool
local ToolService = Instinct.Services.ToolService
local ObjectService = Instinct.Services.ObjectService
local Knapping = Instinct.Libraries.Knapping
 
local Mover
local NormalMover
if game.Players.LocalPlayer then
	local CMover = Instinct.Libraries.Mover
	Mover = Instinct.Create(CMover)
	Mover.MoverType = "Build"
	Mover:CreateBuilder()
	CMover.Builder = Mover
	NormalMover = Instinct:Create(CMover)
	NormalMover.MoverType = "Move"
	CMover.Mover = NormalMover
	NormalMover:CreateMover()
	ToolTip = Instinct.UI.ToolTip
	NutritionService = Instinct.Services.NutritionService
end

local Eat = Instinct:Create(Tool)
Eat.Type = "NonPhysical"
Eat.Name = "Eat"

function Eat:Create() end

function Eat:OnEquip()
	Instinct.Services.KeyService.State = "Eating"
	self.Gui = Instinct.Create(ToolTip)
	self.Cache = {}
	--self.Gui:Hide()
	delay(0, function()
		local Mouse = game.Players.LocalPlayer:GetMouse()
		while Instinct.Services.KeyService.State == "Eating" do
			
			
			local targ = Mouse.Target
			if targ and NutritionService:IsEdible(targ) then
				local data = NutritionService:GetNutritionInfo(targ)
				local use = {}
				for i,v in pairs(data) do
					local val = ((math.floor(v*100 + 0.5)-0.5)/ 100) 
					table.insert(use, {"info", i..": "..val})
				end
				table.insert(use,{"info", "Left click to eat!"})
				self.Gui:Show(targ, {}, use)
			--	warn('show')
				self.Cache[targ] = data
			else 
				self.Gui:Hide()
			--	warn('hide')
			end
			wait()		
			if targ then
				self.Cache[targ] = nil -- GC last targ [ifexist]
			end
		end
	end)
end

function Eat:OnUnequip()
	Instinct.Services.KeyService.State = "Default"
	self.Cache = {}
	self.Gui:Destroy()
end

function Eat:DoAction(mbutton)
	if mbutton == "m1" then
		local Mouse = game.Players.LocalPlayer:GetMouse()
		local targ = Mouse.Target
		if self.Cache[targ or ""] then
			NutritionService:Eat(targ, self.Cache[targ])
		end
	end
end

ToolService:RegisterTool("Eat", Eat)


local Move = Instinct:Create(Tool)
Move.Type = "NonPhysical"
Move.Name = "Move"

function Move:Create() end

function Move:OnEquip()
	Instinct.Services.KeyService.State = "Moving"
end

function Move:OnUnequip()
	Instinct.Services.KeyService.State = "Default"
	if NormalMover.MoveRoot then
		-- should not abort but just move.
		NormalMover:Confirm()
	end

end

function Move:DoDBCAction(key)
	 NormalMover:DoubleClicked(key)
end

function Move:DoAction(mbutton)
	print(mbutton, mbutton == "m1")
	if mbutton == "m1" then
		print(NormalMover.MoveRoot)
		if NormalMover.MoveRoot == nil then
			local Mouse = game.Players.LocalPlayer:GetMouse()
			local targ = Mouse.Target
			local usetarg = Instinct.Services.ObjectService:GetMainPart(targ)
			local o = Instinct.Services.ObjectService:GetObject((usetarg and usetarg.Name) or "")
			print(usetarg)
			local Char = game.Players.LocalPlayer.Character
			if Char then 
				if Char:FindFirstChild("Torso") then
					if (Char.Torso.Position - Mouse.Hit.p).magnitude > 20 then
						return
					end
				end
			end
			if usetarg and o then 
				if select(5,_G.Instinct.Services.IntentionService:CanGather(usetarg)) then
						local omg = usetarg
						if omg then
							if not NormalMover.GettingMoveRoot then
								print(omg:GetFullName())
								NormalMover:SelectTarget(omg)
								NormalMover:ToMoveMode()
							end
						end
				else 
					-- not ok to build with this resource!
				end
			end
		else
			print("->clicked")
			NormalMover:Clicked(mbutton)
		end
	end
end
ToolService:RegisterTool("Move", Move)


local Build = Instinct:Create(Tool)
Build.Type = "NonPhysical"
Build.Name = "Build"

function Build:Create()
	
end

function Build:OnEquip()
	if Instinct.UI and Instinct.UI.SideBar then 
		Instinct.UI.SideBar:ForceClose()
	end
	Instinct.Services.KeyService.State = "Building"
	Mover.UI.BuildGui.Visible = true
end

function Build:OnUnequip()
	if Instinct.UI and Instinct.UI.SideBar then 
		Instinct.UI.SideBar:EnableOpen()
	end
	Instinct.Services.KeyService.State = "Default"
	if Mover.MoveRoot then
		Mover:Abort()
	end
	Mover.Gui.BuildGui.Visible=false
end

function Build:DoDBCAction(key)
	Mover:DoubleClicked(key)
end

function Build:DoAction(mbutton)
	print(mbutton, mbutton == "m1")
	if mbutton == "m1" then
		print(Mover.MoveRoot)
		if Mover.MoveRoot == nil then
			local Mouse = game.Players.LocalPlayer:GetMouse()
			local targ = Mouse.Target
			local usetarg = Instinct.Services.ObjectService:GetMainPart(targ)
			local o = Instinct.Services.ObjectService:GetObject((usetarg and usetarg.Name) or "")
			print(usetarg)
			local Char = game.Players.LocalPlayer.Character
			if Char then 
				if Char:FindFirstChild("Torso") then
					if (Char.Torso.Position - Mouse.Hit.p).magnitude > 20 then
						return
					end
				end
			end
			if usetarg and o then 
					if select(5,_G.Services.IntentionService:CanGather(usetarg)) then
						local omg = Instinct.Services.ObjectService:GetMainPartRoot(targ)
						if omg then
							if not Mover.GettingMoveRoot then
								print(omg:GetFullName())
								print("SELECTING TARGET")
								Mover:SelectTarget(omg)
								Mover:ToMoveMode()
							end
						end
					end

			end
		else
			print("->clicked")
			Mover:Clicked(mbutton)
		end
	end
end
ToolService:RegisterTool("Build", Build)

-- Start of ugly tool API - fix pls

local DefaultTool = Instinct:Create(Tool)

local function inrange()	
	local center = game.Players.LocalPlayer.Character:FindFirstChild("Torso")
	return (center.Position - game.Players.LocalPlayer:GetMouse().Hit.p).magnitude < 10
end
function DefaultTool:Create(TRoot, ObjData)
	local find
	print('scan')
	for objname, objdata in pairs(ObjData) do
		print(objname, objdata)
		for i, item in pairs(objdata) do
			print(i,item)
			find = item
			break
		end
		if find then
			break
		end
	end
	if find then
		local this = find:Clone()
		this.Parent = TRoot
	end
	
	return self -- always
end

-- Change how tools get and do actions.
-- Should be documented!!
-- Actions are inside intentserv;
-- Tools provide a list of actions to check
-- Cache checks if move is possible
-- Run executes it
-- RunServer executes server code
-- 

function DefaultTool:DoAction(button)
	print(self.Tool.Name)
	local o = ObjectService:GetObject(self.Tool.Name)
	print(o)
	if o and inrange() then
		local mat = o:GetConstant("Material")
		print(mat)
		if mat[1] == "Stone" then
			-- is a hammerstone. 
			print("IS HAMMERSOTNE")
			local Mouse = game.Players.LocalPlayer:GetMouse()
			if Mouse.Target and Mouse.Target:IsDescendantOf(game.Workspace.Resources) then 
				local target = ObjectService:GetObject(Mouse.Target.Name)
				if target then 
					local mat = target:GetConstant("Material")
					if mat[1] == "Stone" then
						-- omg
						Knapping:Knap(Mouse.Target)
					end
				end
			end
		elseif self.Tool.Name == "Apple" then
			local Mouse = game.Players.LocalPlayer:GetMouse()
			if Mouse.Target and Mouse.Target.Name == "FertileGround" then 
					Instinct.Communicator:Send("Plant", self.Tool, self.ToolRoot, Mouse.Hit, Mouse.Target)
			end
				
		elseif self.Tool.Name == "Axe" then
			local Mouse = game.Players.LocalPlayer:GetMouse()
			if Mouse.Target then 
				local target = ObjectService:GetObject(Mouse.Target.Name)
				if target then 
					local c = target:GetContext(Mouse.Target, "ChoppedDown")
					if c == nil or c == 1 then 
						Instinct.Communicator:Send("ChopTree", Mouse.Target)
					end
				end
			end
		end 
	end
end

function DefaultTool:CacheAction()
	--	print(self.Tool.Name)
	local o = ObjectService:GetObject(self.Tool.Name)
--	print(o)
	if o then
		local mat = o:GetConstant("Material")
		--print(mat)
		if mat[1] == "Stone" then
			-- is a hammerstone. 
			print("IS HAMMERSOTNE")
			local Mouse = game.Players.LocalPlayer:GetMouse()
			if Mouse.Target then 
				local target = ObjectService:GetObject(Mouse.Target.Name)
				if target then 
					local mat = target:GetConstant("Material")
					if mat[1] == "Stone" then
						-- omg
						return "Knap"
					end
				end
			end
		elseif self.Tool.Name == "Apple" then
			local Mouse = game.Players.LocalPlayer:GetMouse()
			if Mouse.Target and Mouse.Target.Name == "FertileGround" then 
					return "Plant"
			end
				
		elseif self.Tool.Name == "Axe" then
			local Mouse = game.Players.LocalPlayer:GetMouse()
			if Mouse.Target then 
				local target = ObjectService:GetObject(Mouse.Target.Name)
				if target and target.Name == "Wood" then 
					local c = target:GetContext(Mouse.Target, "ChoppedDown")
					if c == nil or c == 1 then 
						return "Chop"
					end
				end
			end
		end
	end
end

-- OVERRIDE
-- Cache action returns an ACTION NAME
function DefaultTool:CacheAction()
	
end

function DefaultTool:DoAction(MouseButton)
	
end

function DefaultTool:GetGrip()
	print('get grip')
	local norm = self.Tool
	local other = CFrame.new()
	if norm then
		other = CFrame.new(0, -0.5, 0)
	end
	return CFrame.new(0, -1, 0) * CFrame.Angles(math.pi/2,0,0) * other
end

ToolService:RegisterTool("DefaultTool", DefaultTool)

end]]></ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="Folder" referent="RBX21e597350dd24987a7350b966a8f39ec">
			<Properties>
				<string name="Name">Services</string>
			</Properties>
			<Item class="Script" referent="RBXa7477f19a83e47439903aa3429bfc826">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ObjectService</string>
					<ProtectedString name="Source"><![CDATA[-- OBJECTSERVICE REWRITE --

-- ObjectService is the interface to Objects and other global-object related operations --

local ObjectService = {}

ObjectService.StudsLength = 0.2 -- 1 stud = x m
ObjectService.MaximumGatherVolue = 3^3 -- max volume for one resource in backpack

-- OBJ lists --

function ObjectService:Constructor() 
	self.Objects = {} 
	self.Rules = {} 
end 

function ObjectService:AddRule(Rule,RuleName,RuleType)
	if not Rule or not RuleName then 
		error("Missing argument @ObjectService:AddRule")
	end 
	if not self.Rules[RuleType or "Default"] then
		self.Rules[RuleType or "Default"] = {}
	end 
	self.Rules[RuleType or "Default"][RuleName] = Rule 
end 

function ObjectService:GetRule(RuleName, RuleType)
	if not RuleName then 
		error("Missing argument @ObjectService:GetRule")
	end 
	return (self.Rules[RuleType or "Default"] and self.Rules[RuleType or "Default"][RuleName])
end 

function ObjectService:AddObject(Object)
	if not Object then 
		error("Missing argument @ObjectService:AddObject")
	end 
	if self.Objects[Object.Name] then 
		error(Object.Name .. " already exists.")
	end 
	self.Objects[Object.Name] = Object 
end 

function ObjectService:GetObject(Name)
	if not Name then 
		error("Missing argument @ObjectService:GetObject")
	end 
	return self.Objects[Name]
end 

-- GetVolume procedure
-- > Get object
-- > Figure out if object has a CustomVolume field
-- > Call this on current resource
-- > if it returns a truthy value, return
-- > else basepart: return getmass
-- > else model: return GetModelSize() multiplied

function ObjectService:GetVolume(RBX_Inst)
	if not RBX_Inst then 
		error("Missing argument @ObjectService:GetVolume")
	end 
	-- First check for a CustomVolume rule
	-- Should get around ugly stuff like axes with parts in it
	local Obj = self:GetObject(RBX_Inst.Name)
	if Obj then 
		local CVolume = Obj.CVolume 
		if CVolume then 
			local val = CVolume(Obj, RBX_Inst)
			if val then 
				return val 
			end 
		end 
	end 

	if RBX_Inst:IsA("BasePart") then 
		return RBX_Inst:GetMass()
	elseif RBX_Inst:IsA("Model") then 
		local size = RBX_Inst:GetModelSize()
		return size.x * size.y * size.z 
	end 
end 

function ObjectService:GetSize(RBX_Inst)
	if not RBX_Inst then 
		error("Missing argument @ObjectService:GetSize")
	end 

	if RBX_Inst:IsA("BasePart") then 
		return RBX_Inst.Size 
	elseif RBX_Inst:IsA("Model") then 
		return RBX_Inst:GetModelSize()
	else
		error("Provided a non-model and non-object to ObjectService")
	end 
end 

-- Resource: RBXINST
-- RuleName: full name of property (MoveDataList)
-- RuleType: name for usage in Rules (Move)
function ObjectService:ApplyRules(Resource, RuleName, RuleType) 
	if not Resource or not RuleType then 
		error("Missing argument @ObjectService:ApplyRules")
	end 
	local Object = self:GetObject(Resource.Name)
	if not Object then 
		error(Resource.Name .. " doesnt exist")
	end 
	local RuleList = Object:GetAncestryProperties(RuleName, true)
	-- Automerged;
	for _, Rule in pairs(RuleList) do 
		local RuleFunc = self:GetRule(Rule, RuleType)
		if RuleFunc then
			RuleFunc(Resource)
		else 
			error(Rule .. " doesnt exist (Rule)")
		end 
	end 
end 

-- generalized "ToBackpack" function (as it was used..)
function ObjectService:ToLocation(Resource, Location)
	if not Resource or not Location then
		error("Missing argument @ObjectService:ToLocation")
	end 
	self:ApplyRules(Resource, "MoveRuleList", Location)
	Resource.Parent = Location 
end 

-- ////////////////////////// --
-- Damn saving/loading api is pretty cool 
-- SAVING / LOADING FUNCTIONS --
-- ////////////////////////// --

-- Warning: Saving data does ONLY accept tables
-- This means that directly copied values from xValues MUST be converted to tables first
-- This is not supported as of OSv2
-- All Save rules should be in the "Save" namespace

function ObjectService:GetSaveData(Inst)
	if not Inst then
		error("Missing argument @ObjectService:GetSaveData")
	end

	-- Procedure 
	-- Load Saving rules for given Instance
	-- Apply rules
	-- Dump properties inside table

	local Object = self:GetObject(Inst.Name)
	if not Object then 
		error("Cannot save; object unknown")
	end 
	-- Name is global identifier
	local SaveData = {Name=Inst.Name} 
	local SaveRules = Object:GetAncestryProperties("SaveDataList", true)
	-- Apply save rules -- 
	for _, RuleName in pairs(SaveRules) do 
		if RuleName == "Context" then
			error("Context rule cannot exist")
		end 
		local Rule = self:GetRule(RuleName, "Save")
		if Rule then 
			SaveData[RuleName] = Rule.To(Inst)
		else 
			error("Nonexistant rule: "..RuleName)
		end 
	end 
	local PPClassName = Object.PropertyContainerClassName
	-- Done with parsing rules; now get Context
	if Inst:FindFirstChild(Object.PropertyContainerName) then
		-- Found context; gotta save
		-- properties go only one level deep, so no need to recurse;
		-- properties are always xValues;
		-- if not then somewhere the code fked up
		SaveData.Context = {} 
		for _, Child in pairs(Inst[Object.PropertyContainerName]:GetChildren()) do 
			if Child:IsA(PPClassName) then 
				-- if Object:Get/SetProperty is used correctly
				-- then there are never empty subproperties;
				if not SaveData.Context.__SubProperties then 
					SaveData.Context.__SubProperties = {}
				end 
				SaveData.Context.__SubProperties[Child.Name] = {}
				for _, SubProperty in pairs(Child:GetChildren()) do
					SaveData.Context.__SubProperties[Child.Name][SubProperty.Name] = SubProperty.Value
				end 
			else 
				SaveData.Context[Child.Name] = Child.Value 
			end 
		end 
	end 
	return SaveData 
end 

-- Recreates an object from SaveData. Only works if the given rules 
-- Have the right To/From rules set. If not, it no work
function ObjectService:FromSaveData(SaveData)
	local Identifier = SaveData.Name -- Object Identifier.
	if not Identifier then
		error("Data doesn't have a Name field")
	end 
	local Object = self:GetObject(Identifier) 
	if not Object then 
		error("Object " .. Identifier .. " does not exist")
	end 
	local BaseObject = self:GetObjectRoot(Identifier)
	if not BaseObject then 
		error("Cannot load " .. Identifier .. " because it's base object doesn't exist")
	end 
	local Target = BaseObject:Clone()
	-- Start parsing the rules which are not the "Context" rules ..
	-- This method is forward-compatibility proof
	for RuleName, RuleData in pairs(SaveData) do
		if RuleName ~= "Context" then -- Context is a special field.
			local Rule = self:GetRule(RuleName, "Save")
			if Rule then 
				-- Parse rule
				Rule.From(RuleData, Target)
			end 
		end 
	end 	
	-- Check for context;
	if SaveData.Context then 
		-- Context is here
		for ContextName, ContextData in pairs(SaveData.Context) do 
			if ContextName ~= "__SubProperties" then 
				Object:SetProperty(Target, ContextName, ContextData)
			end 
		end 
		if SaveData.Context.__SubProperties then
			for ContextGroup, SubData in pairs(SaveData.Context.__SubProperties) do 
				for ContextName, ContextData in pairs(SubData) do 
					Object:SetProperty(Target, ContextName, ContextData, ContextGroup)
				end
			end 
		end
	end
	return Target  
end	

-- Updates a weld
function ObjectService:UpdateWeld(part1, part2, c1, c2)
	if part1:FindFirstChild("Weld") then
		part1.Weld:Destroy()
	end
	local Weld = Instance.new("Weld", part1)
	Weld.Name = "Weld"
	Weld.Part0 = part2
	Weld.Part1 = part1
	Weld.C0 = c2:toObjectSpace(c1)
end


function ObjectService:WeldTransform(part, CC, AN)
	part.CanCollide = CC or false
	part.Anchored = AN or false
end

-- WeldObject;
-- > Always  unanchors and unCCs
-- Inst: resource to weld. Welds to itself as default behaviour
function ObjectService:WeldObject(Inst, TargetInstance, Grip)
	error("Missing argument @ObjectService:WeldObject")
	local MainPart = self:GetMainPart(Inst)
	local Root = self:GetMainPartRoot(Inst)

	for i,v in pairs(Root:GetChildren()) do
		if v:IsA("BasePart") and v ~= MainPart then
			self:UpdateWeld(v, mainpart, v.CFrame, mainpart.CFrame)
			self:WeldTransform(v)
		end
	end
	self:WeldTransform(MainPart)
	if TargetInstance then 
		local Weld = Instance.new("Weld", TargetInstance)
		Weld.Name = "Weld"
		Weld.Part1 = TargetInstance
		Weld.Part0 = MainPart
		Weld.C1 = Grip or CFrame.new()
		Weld.C0 = CFrame.new()
	end 
end

function ObjectService:GetMainPart(Inst)
	if Inst.Parent:IsA("Model") and Inst.Parent.PrimaryPart then
		return Inst.Parent.PrimaryPart
	else
		if Inst.Name == "chParent" then
			return Inst.Parent
		end
	end
	return Inst -- just return self as mainpart then.
end

function ObjectService:GetMainPartRoot(Inst)
	if Inst.Parent:IsA("Model") and Inst.Parent.PrimaryPart then
		return Inst.Parent
	else
		if Inst.Name == "chParent" then
			return Inst.Parent
		end
	end
	return Inst -- just return self as mainpart then.
end

--Finds a roblox instance from a given name
-- Must update locs list in order to find it.
function ObjectService:GetObjectRoot(name)
	local root = game:GetService("ServerStorage")
	local locs = {root:FindFirstChild("Mining"), root:FindFirstChild("Ores"), root:FindFirstChild("Resources"), game:GetService("ReplicatedStorage").NewTools}
	for i,v in pairs(locs) do
		if v:FindFirstChild(name) then
			return v:FindFirstChild(name)
		end
	end
end

-- Copies a Style from StyleBrick to Target given Props in a PropList
function ObjectService:CopyStyle(StyleBrick, Target, PropList)
	local function r(w)
		for i,v in pairs(w:GetChildren()) do
			if v:IsA("BasePart") then
				for ind, val in pairs(PropList) do
					print(val)
					v[val] = StyleBrick[val]
					v.Anchored=false
					v.CanCollide=true
				end
			end
		end
	end
	r(Target)
	for ind, val in pairs(PropList) do
		Target[val] = StyleBrick[val]
		Target.Anchored=false
		Target.CanCollide=true
	end
end

function ObjectService:DropItem(res, pos)
	if not res then return end
	res.Parent = game.Workspace.Resources 
	if res:IsA("Part") then
		-- check for parts inside
		res.CFrame = CFrame.new(pos)
	else -- qq
		
	end
end

function ObjectService:SetResourceCFrame(res, CF)
	if res:IsA("Model") then
		local function moveModel(model,targetCFrame)
			for i,v in pairs(model:GetChildren()) do
				if v:IsA("BasePart") then
					v.CFrame=targetCFrame:toWorldSpace(model:GetModelCFrame():toObjectSpace(v.CFrame))
				end
				moveModel(v, targetCFrame)
			end
		end

		moveModel(res, CF)
	else
		if res:FindFirstChild("chParent") then
			for i,v in pairs(res:GetChildren()) do
				if v:IsA("BasePart") and v.Name == "chParent" then
					local weld = v:FindFirstChild("Weld")
					if weld then
						local c0 = weld.C0
						v.CFrame = CF * c0
					end
				end
			end
			res.CFrame = CF
		else
			res.CFrame = CF
		end
	end
end

-- oldparent can be used to put leftovers in.
function ObjectService:ResizeResource(res, size, oldparent)
	if res:IsA("Model") then
		-- ... wat ... 

		return
	elseif res:FindFirstChild("chParent") then
		-- no.
		return
	end
	res.Size = size 

end

return ObjectService







]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBXc33f7293e9e54f87b3a512eed20493ea">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ClothingService</string>
					<ProtectedString name="Source"><![CDATA[local ClothingService = {}

-- general interface to clothing. should be expanded later.
-- clothing are just resources. v1=current
-- v1: do not add to resources, as we need additional rules for gathering then. not something we want, rite?
-- v2: add to objects
-- v3: make unwear/wear
-- v4: add chcreator

function ClothingService:Constructor()
	self.Clothing = {}
end

function ClothingService:AddCloth(ClothData)
	-- what is necessary?
	local function check(prop)
		if ClothData[prop] == nil then
			error(prop .. " is notprovided with clothdata")
		end
	end
	check "Name"
	check "BodyPart"
	check "Grip" -- grip is derived from bodypart CF
	check "Root"
	self.Clothing[ClothData.Name] = ClothData
end

-- shamelessly copied from tools

function ClothingService:UpdateWeld(part1, part2, c1, c2)
	if part1:FindFirstChild("Weld") then
		part1.Weld:Destroy()
	end
	local Weld = Instance.new("Weld", part1)
	Weld.Name = "Weld"
	Weld.Part0 = part2
	Weld.Part1 = part1
	Weld.C0 = c2:toObjectSpace(c1)
end

function ClothingService:Transform(part)
	print('transform', part.Name)
	part.CanCollide = false
	part.Anchored = false
end

function ClothingService:CreateWelds(root, weld_to, grip, dontweldtoroot)
	local hand = hand
	local handle = root
--	handle.Parent = game.Workspace
	if not root then return end
	local mainpart = root


	for i,v in pairs(mainpart:GetChildren()) do
		if v:IsA("BasePart") and v ~= mainpart then
			self:UpdateWeld(v, mainpart, v.CFrame, mainpart.CFrame)
			if not dontweldtoroot then
				self:Transform(v)
			end
		end
	end
	if not dontweldtoroot and mainpart:IsA("BasePart") then
		self:Transform(mainpart)
	end
	local Weld
	if not dontweldtoroot then
		Weld = Instance.new("Weld", weld_to)
		Weld.Name = "Weld"
		Weld.Part1 = weld_to
		Weld.Part0 = mainpart
		Weld.C1 = grip or CFrame.new()
		Weld.C0 = CFrame.new()
	end
	return 
end

function ClothingService:GetCloth(name)
	return self.Clothing[name]
end


-- v1: no check for clothes which are being worn.
-- v2: check for clothes.. etc..
-- clothinst is a copy of the cloth; can be changed if necessary; only change style, sizes will be problematic
-- no hard checks for hta.t
function ClothingService:WearCloth(ClothName, ClothInst, Player)
	-- clothinst should be a clone.
	if self.Clothing[ClothName] == nil then
		-- clothing doesnt exist, baibai
		warn(ClothName.. " does not exist, cannot wear.")
		return
	end
	local ClothData = self.Clothing[ClothName]
	local char = Player.Character
	if char:FindFirstChild("Clothing") == nil then
		local mod = Instance.new("Model", char)
		mod.Name = "Clothing"
	end
	local this = char.Clothing 
	local BodyPart = ClothData.BodyPart
	if char:FindFirstChild(BodyPart) then
		local weldto = char[BodyPart]
		local root = ClothInst
		-- assuming the chParent structure;
		self:CreateWelds(root, weldto, ClothData.Grip, nil)
		root.Parent=this
	else 
		-- body part doesnt exist, cannot wear this cloth. baibai.
	end
end

function ClothingService:UnwearCloth(root)
	-- unwear cloth by destroying it or something. or dropping it. not supported as of v1
end

return ClothingService

]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBXa2d7f3408b7143c0b493328b70688061">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">DamageService</string>
					<ProtectedString name="Source"><![CDATA[local DamageService = {}

local ObjectService, ToolService, Communicator 

DamageService.CooldownScaler = 1;
DamageService.CriticalHitChance = 0.1

function DamageService:Constructor()
	ObjectService = _G.Instinct.Services.ObjectService
	ToolService = _G.Instinct.Services.ToolService
	Communicator = _G.Instinct.Communicator
	self.Cooldowns = {}
end


DamageService.DamageTypes = {
	Cut = {
		BuildingDamage = 0.5;
		PlayerDamage = 1.5;
	},
	Crush = {
		BuildingDamage = 2;
		PlayerDamage = 1;
	},
	Hack = {
		BuildingDamage = 1.5;
		PlayerDamage = 1.25;
	}
}

DamageService.NoToolDamage = {
	Hardness = 2;
	DamageType = "Crush"
}

DamageService.DamageMultiplier = {
	Head = 2;
	Torso = 1.5;
	["Left leg"] = 1;
	["Right leg"] = 1;
	["Left arm"] = 1;
	["Right arm"] = 1;
	Backpack = 1.25;
}

function DamageService:Constructor()
	if game.Players.LocalPlayer then 	
		local Gui = Instance.new("ScreenGui", game.Players.LocalPlayer.PlayerGui)
		Gui.Name = "DamageGui"
		self.Gui=Gui
		self.Cooldowns = {}
	end
end

function DamageService:IsPlayer(Target)
	local c = Target
	repeat
		c = c.Parent
	until (c and c:FindFirstChild("Humanoid")) or (not c)
	if c and c:FindFirstChild("Humanoid") then
		return c
	end
end

function DamageService:GetDamageInfo(Tool, TargetInstance)
	if not TargetInstance then return end
	if os.time() - (self.Cooldowns[Tool.Hand] or 0) < 0 then
		return -- cooldown thing
	end
	local Mouse = game.Players.LocalPlayer:GetMouse()
	local Char = game.Players.LocalPlayer.Character
	if Char:FindFirstChild("Torso") and (Mouse.Hit.p - Char.Torso.Position).magnitude < 5 then
		local IsPlayer = self:IsPlayer(TargetInstance)
		if IsPlayer then
			local Name = TargetInstance.Name
			-- check for backpack
			local DamageMultiplier = self.DamageMultiplier[Name] or self.DamageMultiplier.Backpack
			
			local ToolName = Tool.Tool.Name 
			local Object = ObjectService:GetObject(ToolName)
			if Object then
				-- all tools get damage calculation
				if true then -- (Object:GetConstant("Hardness")[1] and Object:GetConstant("DamageType")[1] and Object:GetConstant("Density")[1]) or  Object:GetConstant("GetBaseDamage")[1] then
					local glob = {}					
					if Object.GetBaseDamage then
						glob = Object:GetBaseDamage(Tool) or {}
					end
					local Mass = glob.Mass or (ObjectService:GetVolume(Object) or 1) * (glob.Density or Object.Density or 1)
					local Cooldown = Mass * self.CooldownScaler
					local DamageTypeMultiplier = self.DamageTypes[glob.DamageType or Object.DamageType or ""]  or 1
					if type(DamageTypeMultiplier) ~= "number" then
						DamageTypeMultiplier = 1
					end
					local Multiplier = DamageTypeMultiplier * DamageMultiplier
				--	local Critical = false

										
					-- Ok so we calculated Cooldown and Multiplier
					-- Let's calculate energy loss due to this dmaage [later]
					
					
					local BaseDamage = glob.BaseDamage or Object.BaseDamage or 1
				
					local Damage = math.sqrt(BaseDamage * Mass * (glob.Hardness or Object.Hardness or 1)) * Multiplier
					
					return {Damage = Damage,  Cooldown = Cooldown, TargetType = "Player", Target = IsPlayer}
				end
			end
		end
	end
end

function DamageService:Attack(Tool, TargetInstance)
	local Info = self:GetDamageInfo(Tool, TargetInstance)
	if Info then
		ToolService:SetCooldown(Tool.Hand, Info.Cooldowns)
		self.Cooldowns[Tool.Hand] = os.time() + (Info.Cooldown or 1)
		if math.random() <= self.CriticalHitChance then
			Info.Damage = Info.Damage * 2
			Info.IsCritical = true
		end
		if Info.TargetType == "Player" then
			Communicator:Send("DoPlayerDamage", Info.Target, Info.Damage, Info.IsCritical)

			-- > push to GUI
		end
	end
end

return DamageService]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX53ba5285045c42ad84fc4e675c85c67d">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">DiscoveryService</string>
					<ProtectedString name="Source"><![CDATA[local DiscoveryService = {}

function DiscoveryService:Constructor()
	self.Cache = {}
	self.LastChecks = {}
	self.LocalDiscoveries = {}
	self.DataStoreService = game:GetService("DataStoreService")
end

function DiscoveryService:GetStore(Name)
	return self.DataStoreService:GetDataStore(Name, "DiscoveryData")
end

function DiscoveryService:GetDiscoveries(Name)
	local store = self:GetStore(Name)
	if store then 
		local this
		if not self.LastChecks[Name] then
			self.LastChecks[Name] = os.time()
			self.LocalDiscoveries[Name] = {}
			this = store:GetAsync("Data") or {}
			self.Cache[Name] = this
			self:CreateFromData(Name, this)
		elseif (os.time() - self.LastChecks[Name]) >= 50 then
			-- sure
			self.LastChecks[Name] = os.time()
			this = store:GetAsync("Data") or {}
			for objname, discoverer in pairs(this) do
				if self.Cache[Name] and self.Cache[Name][objname] == nil then
					self:CreateFromData(Name, this)
					if _G.Instinct.Mechanics.Chat then
						if not self.LocalDiscoveries[Name][objname] then
							print("discovery", discoverer, Name, objname)
							_G.Instinct.Mechanics.Chat:SendGlobal(discoverer .. " discovered a " .. Name .. ": " .. objname)
						end
					end
				end
			end			
			self.Cache[Name] = this
		else
			this = self.Cache[Name]
		end
		return this
	end
end

function DiscoveryService:CreateFromData(Name, Data)
	local mod = game:GetService("ReplicatedStorage").Discoveries
	if mod:FindFirstChild(Name) == nil then
		Instance.new("Model", mod).Name = Name
	end
	for objname, discoverer in pairs(Data) do
		print("check", objname, discoverer)
		if mod[Name]:FindFirstChild(objname) == nil then 
			local this = Instance.new("StringValue")
			this.Name = objname
			this.Value = discoverer
			this.Parent = mod[Name]
		end
	end
end


-- name = recipe/tool/resource
-- who is player name
-- what is the objname
function DiscoveryService:SetDiscovery(Name, Player, What)
	local Who	
	-- sorry guests 
	if Player.userId <= 0 then
		return 
	-- sorry noob dev
	elseif Player.Name == "jobro13" then
		return
	end
	Who = Player.Name
	if not Name or not Who or not What then
		return
	end
	if type(Name) ~= "string" or type(What) ~= "string" or type(Who) ~= "string" then
		return 
	end
	if self.Cache[Name] and self.Cache[Name][What] == nil then
		local store = self:GetStore(Name)
		if store then
			pcall(function()
			store:UpdateAsync("Data", function(oldValue)
				if oldValue == nil then
					return {What=Who}
				elseif oldValue and not oldValue[What] then
					oldValue[What] = Who
					if _G.Instinct.Mechanics.Chat then
						print("discovery", Who, Name, What)
						if self.LocalDiscoveries[Name] then
							self.LocalDiscoveries[Name][What] = true
						end
						_G.Instinct.Mechanics.Chat:SendGlobal(Who .. " discovered a " .. Name .. ": " .. What)
					end
					return oldValue
				end
			end)
			end)
		end
	end
end

return DiscoveryService]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBXaa2fb43b07154ab3834d51cff9e7e372">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">GameState</string>
					<ProtectedString name="Source"><![CDATA[local GameState = {}

function GameState:Set(x)
	self.State = x
end


return GameState]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX1d57467934c44e46b0fda6ac2f473266">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">IntentionService</string>
					<ProtectedString name="Source"><![CDATA[local IntentionService = {}

local ToolService, ObjectService, DamageService

function IntentionService:Constructor()
	ToolService = _G.Instinct.Services.ToolService
	ObjectService = _G.Instinct.Services.ObjectService
	DamageService = _G.Instinct.Services.DamageService
	self.Actions = {}
end

function IntentionService:AddAction(Action)
	if Action.Name and Action.Run then
		self.Actions[Action.Name]=Action
	end
end

function IntentionService:DoAction(AName, Arg, Hand)
--	print(AName, self.Actions[AName])
	if self.Actions[AName] then
		table.insert(Arg, Hand)
		self.Actions[AName]:Run(unpack(Arg))
	end
end

function IntentionService:IsTool(Inst)
	-- returns if Inst is a tool, very naive checking 
	return Inst:IsDescendantOf(game.Workspace.Tools)
end 



-- left/right action are strings of cached left/right actions for given inst

function IntentionService:CanGather(Inst, LeftAction, RightAction)
	local CanMove = false
	local LeftTool = ToolService.EquippedLeft
	local RightTool = ToolService.EquippedRight
	local obj = ObjectService:GetObject(Inst.Name)
	local bool, rlist, oaction
	local oaction = oaction or {}
	local UseName
	if obj  and obj.CheckGather then
		local func = obj.CheckGather
		if type(func) == "boolean" then
			if func and ObjectService:GetVolume(Inst) > ObjectService.MaximumGatherVolume then
				bool, rlist = false, {"This resource is too large to gather. Move it with the move tool."}
				CanMove = true
			else 
				bool, rlist = func, {}
			end
		else
			-- Call the function. This will be called with
			-- one arg: Inst.
			-- The function should return:
			--> can gather (bool)
			--> if not can gather ->
			--> provide the ReasonList
			--> provide which action would be necessary.
			local CanGather, Reasons, ActionNeeded -- oaction not local pls.
			CanGather, Reasons, ActionNeeded, oaction = func(obj, Inst)
			oaction = oaction or {}
			if CanGather then
				if ObjectService:GetVolume(Inst) > ObjectService.MaximumGatherVolume then
					bool,rlist =  false, {"This resource is too large to gather. Move it with the move tool."}
				else
					bool, rlist = true, {}
				end
			end
			if type(ActionNeeded) == "table" then 
				local has_equipped=false
				for _, Action in pairs(ActionNeeded) do 
					if Action == LeftAction then 
						has_equipped = "left"
						break
					elseif Action == RightAction then 
						has_equipped = "right"
						break
					end
				end
				if has_equipped then 
					bool, rlist = false, Reasons 
				else
					bool, rlist = false, {"Use your "..has_equipped.."-handed tool to do the required action"}
				end
			elseif type(ActionNeeded) == "string" then
				if ActionNeeded == LeftAction then 
					bool, rlist = false, {"Use your left-handed tool to do the required action"}
				elseif ActionNeeded == RightAction then 
					bool, rlist = false, {"Use your right-handed tool to do the required action"}
				else 
					bool, rlist = false, Reasons 
				end
			elseif not CanGather then
				warn("got strange exception from INTSERV: "..(tostring(ActionNeeded)))
				if type(ActionNeeded) == "table" then
					for i,v in pairs(ActionNeeded) do
					--	print(tostring(i), tostring(v))
					end
				end
				bool, rlist = false, {"cannot gather; unknown reason;"}
			end
		end
	end
	
	-- here, check for actions lft/right hand and for cooldown, change
	-- info accordingly
	
	if not oaction.Left and not oaction.Right then
		local function hashumanoid(t)
			local c = t
			repeat
				c = c.Parent
			until (c and c:FindFirstChild("Humanoid")) or not c
			if c and c:FindFirstChild("Humanoid") then
				return true, c.Name
			end
		end
		-- start general procedure to check if we want anything else!
		local has, name = hashumanoid(Inst)
		if Inst:IsDescendantOf(game.Workspace.Corpses) then
			-- uhoh.
			rlist = {}
			local n = Inst 
			while n.Parent ~= game.Workspace.Corpses do
				n = n.Parent
			end
			-- we found root which is n.
			local cName = n.Name 
			bool = false 
			if n:FindFirstChild("Clothing") and Inst:IsDescendantOf(n.Clothing) then
				if n.Clothing:FindFirstChild("Backpack") then
					if Inst == n.Clothing.Backpack or Inst:IsDescendantOf(n.Clothing.Backpack) then
						-- it backpack!
						UseName = "Backpack of "..cName
						oaction = {Left = "Inspect Backpack"}
					end
				end
			end
			if not oaction.Left then
				UseName = "Corpse of " .. cName
				table.insert(rlist, "I wonder what happened...")
			end
		elseif has then
			UseName = name -- show player name on hover;
			local temp = oaction or {}
			local changed = false
			if LeftTool then
				local Info = DamageService:GetDamageInfo(LeftTool, Inst)
				if Info then
					temp.Left = "Attack"
					changed = true
				end
			end
			if RightTool then
				local Info = DamageService:GetDamageInfo(RightTool, Inst)
				if Info then
					temp.Right = "Attack"
					changed = true
				end
			end
			if changed then
				oaction = temp
			end
		end
		
	end
	
	if bool == nil then 
		bool= false
	end
	
	if rlist == nil then
		rlist = {}
	end
	
	if bool and Inst:IsDescendantOf(game.Workspace.Buildings) or Inst:IsDescendantOf(game.Workspace.Tools) or Inst:IsDescendantOf(game.Workspace.Garbage) then	
		bool=false
	end
	return bool, (rlist or {}), (oaction or {}), UseName, CanMove
end

return IntentionService]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX2f65c1c2c84d4d068dfad81f37ba9fbf">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">KeyService</string>
					<ProtectedString name="Source"><![CDATA[local KeyService = {}

KeyService.Keys = {}

KeyService.DoubleClickTime = 0.25

-- enums plz

KeyService.State = "Default" -- block keys later (via keydown event)

local fix = {}
fix.__index = function(tab, index)
	rawset(tab, index, {true, tick()})
	return rawget(tab, index)
end

setmetatable(KeyService.Keys, fix) -- Fixes a "nil-call" when key was not down / up yet

function KeyService:Constructor()
	self.KeyDown = _G.Instinct:Create(_G.Instinct.Utilities.Event)
	self.DoubleClick =_G.Instinct:Create(_G.Instinct.Utilities.Event)
	self.KeyUp = _G.Instinct:Create(_G.Instinct.Utilities.Event)
end

function KeyService:GetKey(input)
	return (type(input) == "number" and input) or (type(input) == "string" and input:byte()) or 1
end

function KeyService:KeyIsUp(key)
	return self.Keys[self:GetKey(key)][1] and true 
end

function KeyService:KeyIsDown(key)
	return not self:KeyIsUp(key)
end

function KeyService:GetTime(key)
	return tick() - self.Keys[key][2]
end

function KeyService:KeyIsDownFor(key, time)
	return self:KeyIsDown(key) and self:GetTime(key) > time
end

function KeyService:KeyIsUpFor(key, time)
	return self:KeyIsUp(key) and self:GetTime(key) > time
end

function KeyService:Initiate() 
local uis = game:GetService("UserInputService")
uis.InputBegan:connect(function(obj)
	local _,kc = pcall(function() return obj.KeyCode end)
	if kc then
		self.Keys[kc] = {true, tick()}
		self.KeyDown:fire(kc, self.State)
	end
end)
uis.InputEnded:connect(function(obj)
	local _,kc = pcall(function() return obj.KeyCode end)
	if kc then
		self.Keys[kc] = {false,tick()}
		self.KeyUp:fire(kc, self.State)
	--	self.KeyUp:fire(kc, self.State)
	end
end)
local mouse = game.Players.LocalPlayer:GetMouse() 
--[[mouse.KeyUp:connect(function(key) 
	self.Keys[key:byte()] = {true, tick()}
end)
mouse.KeyDown:connect(function(key)
	self.Keys[key:byte()] = {false, tick()}
	OLDPRINT("Key down: "..key)
	self.KeyDown:fire(key, self.State)
end)--]]
local lastm1down = 0
local lastm2down = 0
mouse.Button1Down:connect(function()
	self.KeyDown:fire("m1", self.State)
	if os.time() - lastm1down < self.DoubleClickTime then
		self.DoubleClick:fire("m1", self.State)
	end
	lastm1down = os.time()
end)
mouse.Button2Down:connect(function()
	self.KeyDown:fire("m2", self.State)
	if os.time() - lastm2down < self.DoubleClickTime then 
		self.DoubleClick:fire("m2", self.State)
	end
	lastm2down = os.time()
end)
mouse.Button1Up:connect(function()
	self.KeyUp:fire("m1", self.State)

end)
mouse.Button2Up:connect(function()
	self.KeyUp:fire("m2", self.State)

end)
end

return KeyService

]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX31192306bbd94ddebbb3447c45f9b3a9">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Locale</string>
					<ProtectedString name="Source"><![CDATA[local Locale = {}

Locale.Default = "English"

Locale.Selected = "English"

Locale.AvailableLocales = {
	--"Francais",
	--"Deutsch",
	"English",
	--"Espanol",
	--"Italiano",	
	"Nederlands",
}

Locale.DefaultLocale = _G.Instinct.Include("LocaleFiles/"..Locale.Default)
Locale.SelectedLocale = Locale.DefaultLocale

function Locale.Get(str)
	-- BOOM TRANSLATIONS <3
	return Locale.SelectedLocale[str] or Locale.DefaultLocale or (str..">MISSING!")
end

function Locale.Set(lang)
	local found = false
	for i,v in pairs(Locale.AvailableLocales) do
		if v == lang then
			local try = Instinct.Include("LocaleFiles/"..v)
			if try then
				Locale.SelectedLocale = try
				found = true
				break
			else
				print("[Instinct Core] Locale not found: "..tostring(v))
			end
		end
	end
	if not found then
		print("[Instinct Core] Locale not found: "..tostring(lang))
	end
end

return Locale]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBXce479a9d9fed4db8adde0a1c61499ce9">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">NutritionService</string>
					<ProtectedString name="Source"><![CDATA[local NutritionService = {}

local ObjectService,Communicator

-- target: rbxinstance

function NutritionService:Constructor()
	ObjectService = _G.Instinct.Services.ObjectService
	Communicator= _G.Instinct.Communicator
end

function NutritionService:IsEdible(target)
	local name = target.Name 
	local o = ObjectService:GetObject(name)
	if o then
		return not (not o.Edible), o.Edible
	end
end

function NutritionService:GetNutritionInfo(target)
	local is_edible, data = self:IsEdible(target)
	if is_edible then
		local vol = ObjectService:GetVolume(target)
		if vol then
			local cp = {}
			for i,v in pairs(data) do
				cp[i] = v * vol;
			end
			return cp
		end
	end
	return {}
end

function NutritionService:Eat(target, edb_data)
	--> Eat Hunger=num Thirt = nu
	print("Eat!!")
	
	Communicator:Send("Eat", target, edb_data)
end

return NutritionService]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBXa5f1f3b213e2449880bbf6e5efa3a9cb">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">RecipeService</string>
					<ProtectedString name="Source"><![CDATA[-- RecipeService only checks if the recipe can be made
-- If so, and the world / user wants to execute this recipe
-- The context + resources list should be passed to an
-- additional service which constructs the new object

-- In theory it should be possible that this thing
-- Creates dynamic objects! (damn)

-- //////// DEPRECATED

local printm=print
local throw=print
local throwt=print


local ObjectService = Instinct.Include "Services/ObjectService"
local Object = Instinct.Include "Action/Object"

local RecipeService = {}

RecipeService.Categories = {}

RecipeService.Rules = {}

function RecipeService:Constructor()
	self.Categories = {}
	self.Rules = {}
end

function RecipeService:AddCategory(name)
	self.Categories[name] = {}
end 

function RecipeService:AddRecipe(recipe, cat)
	if not cat then
		warn(cat .. " category not provided, not adding recipe")
		return	
	end
	if not self.Categories[cat] then 
		self:AddCategory(cat)
	end 
	table.insert(self.Categories[cat], recipe) 
end

function RecipeService:AddRecipeToCategory(recipe, category)
	if not self.Categories[category] then 
		self:AddCategory(category)
	end 
	table.insert(self.Categories[category], recipe)
end 

RecipeService.UsedHelpers = {
	Add = function(self, ing, what)
		if not self[ing] then 
			self[ing] = {} 
		end 
		if not self[ing][what.Name] then 
			self[ing][what.Name] =  {what, Object = ObjectService:GetObject(what.Name)}
		else 
			table.insert(self[ing][what.Name], what)
		end
	end, 
	Delete = function(self, ing, what)
		if self[ing] then 
			self[ing].Deleted = true -- notify that something is being deleted
			if self[ing][what.Name] then 
				self[ing][what.Name].Deleted = true
				for i,v in pairs(self[ing][what.Name]) do 
					if v == what then 
						table.remove(self[ing][what.Name], i)
						break 
					end 
				end 
			end 
		end
	end,


}

-- Converts a list of Instances to WorkList
-- A WorkList should not be created a lot
-- It should be created before a recipe check round
-- It mainly consists of a linker object between the 
-- instance and the instinct object

-- preprocess the IL

-- contents
-- ipairs: {resource, obj}
-- [name] = {{res, obj}, {res2, obj}} etc



function RecipeService:CreateWorkList(InstanceList) 
	-- assertion is that instancelist 
	-- consists of roblox instances
	local out = {Used={}}
	local namelist = {}
	for i,v in pairs(InstanceList) do 
		local obj = ObjectService:GetObject(v.Name)
		if not obj then 
			throw("object " .. v.Name .. "not available")
			return nil, 1
		end 
		table.insert(out, {v, obj})
		if not namelist[v.Name] then 
			namelist[v.Name] = {out[#out][1], Object = out[#out][2]}
		else 
			table.insert(namelist[v.Name], out[#out][1])
		end
	end 
	for i,v in pairs(namelist) do 
		out[i] = v 
	end 
	setmetatable(out.Used, {__index = self.UsedHelpers})
	return out, 0 
end 



-- Checks if a recipe can be created;
-- Recipe is the recipe we want to create
-- Context is the context (backpack, in furnace, env temp, etc.)
-- List is a list of Objects provided to create the recipe
-- The Used field of this List should be filled
-- By the Rule functions with every INSTANCE which is used
-- To create the recipe

-- This service is a very complex service;
-- This function is the heart of it.
-- What does it do?
--> Check if the context exists
--> If so, figure out if the context is okay for this recipe
--> If nonexistant, okay too
--> Checkout the first rule.
--> EVERY RULE should test every ingredient

--> Mode:
--> 1 -> Diagnostic (for helpers)
--> 2 -> debug (verbose output)

function RecipeService:CheckRecipe(Recipe, Context, List, Mode)
	-- Check if all rules are present
	-- The minimal recipe only checks for ingredients.
	-- First check if the Recipe has any Context rules
	-- LIST is auto-changed to a WL
	local CanCreate = true
	local rl, err = self:CreateWorkList(List)
	if err > 0 then 
		throw "Worklist creation error, aborting .. "
		return false, 4
	end 
	local List = rl
	List.Used.Warnings = {}
	List.Used.WarningMessages = {}
	 
	local skip = {}

	local function EvalRuleProcedure(RuleName, RuleData,  RuleSet, RuleType, List, WholeList, errmsg, errcode)
		local ok, skipd, err = self:EvaluateRule(RuleName, RuleData, RuleSet, RuleType, Context, List, Recipe, WholeList, Mode )
		local err = err or 0
		if not ok then
			if Mode and Mode == 2 then 
				printm("RecipeService", "info", "rule not okay: " .. RuleName)
			end 
			if err > 0 then 
				throw(errmsg)
			end  
			return false ,errcode 
		elseif type(err) == "table" then 
			for _, skiprule in pairs(err) do 
				skip[skiprule] = true 
			end 
		end
		return ok, skipd, err 
	end 

	if Recipe.Context then
		skip = {} 
		-- We must evaluate all Context rules
		for RuleName, RuleData in pairs(Recipe.Context) do
			if not skip[RuleName] then  
				local ok, err = EvalRuleProcedure(RuleName, RuleData, Recipe.Context, {"Context", "NotAResource"}, List, List, "recipe check error clist", 3)
				if not ok then 
					CanCreate = false
				end 
			end 
		end
	end
	local nokrules = List.Used.Warnings
	local gotnok = false 
	local function nok(ing, rule)
		gotnok =true
		if nokrules[ing] then 
			nokrules[ing][rule] = true 
		else 
			nokrules[ing] = {[rule] = true}
		end 
	end 
	if Recipe.Ingredients then 
		for IngredientName, IngredientRules in pairs(Recipe.Ingredients) do 
			skip = {} -- clear skip cache 
			if Mode == 2 then 
				printm("RecipeService", "info", "Checking rules for ".. IngredientName)
			end 
			local ok, err = EvalRuleProcedure("Amount", IngredientRules.Amount, IngredientRules,  {"Ingredient", IngredientName}, List, List, "recipe check error inglist", 2)
			if not ok and not Recipe.DelFunc then 
				CanCreate = false
			else 
				table.insert(nokrules, IngredientName)
			end 
			for RuleName, RuleData in pairs(IngredientRules) do 
				printm("RecipeService", "info", "Evaluating rule " .. RuleName )
				if RuleName ~= "Amount" then 
					if not skip[RuleName] then 
						local ok, err = EvalRuleProcedure(RuleName, RuleData, IngredientRules, {"Ingredient", IngredientName}, List.Used[IngredientName], List, "recipe check error inglist", 2)
						if not ok then 
							if Recipe.DelFunc then 
								nok(IngredientName, RuleName)
								Recipe.DelFunc(nokrules, List.Used)
							end
							CanCreate = false
						end
					end
				end 
			end
			-- still amount ok?
			local atotal = 0 
			local chk = nil 
			local chksame = IngredientRules.Same ~= nil 
			if IngredientRules.AmountType == "Volume" then 
				-- check for volume 
				chk = true 
			end 
			local rem 
			local cando 
			if chksame then 
				rem = {}
				cando = false 
			end 

			if List.Used[IngredientName] then 
				for i,v in pairs(List.Used[IngredientName]) do 
					-- add amount proc
					if chk then 
						for ind, val in pairs(v) do 
							atotal = atotal + ObjectService:GetVolume(v)
						end 
					else
						atotal = atotal + #v
					end
					-- chksame rulekit
					if chksame then 
						if atotal >= IngredientRules.Amount then 
							if chksame then 
								cando = true 
							end 
						else
							rem[i] = true 
						end 
						atotal = 0 
					end 

				end 
				if chksame then 
					for i,v in pairs(rem) do 
						List.Used[IngredientName][i] = nil 
					end 
				end 
				List.Used[IngredientName].AmountNeeded = IngredientRules.Amount
			end
			print(atotal)
		--	List.Used[IngredientName].AmountNeeded = IngredientRules.Amount
			if atotal < IngredientRules.Amount then 
				if Recipe.DelFunc then 
					nok(IngredientName, "AFAmountCheck")
					Recipe.DelFunc(nokrules, List.Used)
				end 
				CanCreate = false
			elseif chksame and not cando then 
				if Recipe.DelFunc then 
					nok(IngredientName, "AFAmountCheck")
					Recipe.DelFunc(nokrules, List.Used)
				end 
				CanCreate = false -- NOPE recipe same check fail
			end
		end
	else 
	--[[	throw("recipe has no ingredients !?")
	return false, 1--]]
	-- heh lol thats actually possible
	end 	
	if Recipe.DelFunc and gotnok then 
		Recipe.DelFunc(nokrules, List.Used)
	end  

	return List.Used, CanCreate
end 

-- passed: 
function RecipeService:AddRule(name, rulefunc)
	if not self.Rules[name] then 
		self.Rules[name] = rulefunc 
	else 
		throw(name .. " rule already exists")
	end 
end 

-- Evaluate a Rule
-- Please create a default EQ checker for general rules
-- A good helper function to use is Object:HasConstant
-- EX pass:
-- {Temperature = {"Larger", 900}}
--> pass:
-- "Temperature", {"Larger", 900},  AllRulesForIngredient, {"Ingredient", IngredientName}, data.context, data.rlist, data
-- Second arg returned is 1: error, or 0: ok
-- first arg is if rule is ok or not (table or boolean, explained below)

-- Watch out! IngredientName can be misleading!
-- "Food" could be an ingredient name!
-- It is JUST to make recipes easier to read!

-- NOTE: 
-- A table may be returned: this holds a list of further rules 
-- for that current scope to ignore.
-- this is handy for an option list
-- be aware that these option may cause a rulename does not exist error
-- !
function RecipeService:EvaluateRule(RuleName, RuleData, RuleSet, RuleType, Context, List, Recipe, WholeList, Mode)
	if not self.Rules[RuleName] then 
		throw(RuleName .. " a rulename does not exist")
		return false, 1
	end 
	
	local arglist = {
	RuleName = RuleName,
	RuleData = RuleData, 
	RuleSet = RuleSet, 
	RuleType = RuleType, 
	Context = Context, 
	List = List, 
	WholeList = WholeList, 
	Recipe = Recipe, 
	Mode = Mode 
}

	return self.Rules[RuleName](arglist)

end

return RecipeService ]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBXdaeb6ee9fd044ca99c2284f231932617">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">SpawnService</string>
					<ProtectedString name="Source"><![CDATA[local SpawnService = {}
-- spawnservice handles chcreate

local ClothingService,Communicator

function SpawnService:Constructor()
	ClothingService = _G.Instinct.Services.ClothingService
	Communicator = _G.Instinct.Communicator
end

function SpawnService:ConvertPlayer(Player, Data)
	warn("IN CV")
		-- first undo player of all nonsense.
	local char = Player.Character
	local rem = {
		CharacterAppearance = true; Hat = true; BodyColors = true;
	}
	local function Recurse(r)
		for _,child in pairs(r:GetChildren()) do
			for class in pairs(rem) do
				if child:IsA(class) then
					child:Destroy()
				end
			end
			Recurse(child)
		end
	end
	Recurse(char)
	-- strapped of.

	local function SetSkinColor(color)	
		for _,part in pairs(char:GetChildren()) do
			if part:IsA("BasePart") then
				part.BrickColor = color
			end
		end
	end
	SetSkinColor(BrickColor.new "Pastel brown" )
	Communicator:Send(Player, "SetSkinColor", "Pastel brown")	
	
	local Backpack = ClothingService:GetCloth "Backpack"
	local RPants = ClothingService:GetCloth "RightPants"
	local LPants = ClothingService:GetCloth "LeftPants"
	local Shirt = ClothingService:GetCloth "Shirt"
	warn ( " --- " )
	print(Backpack, RPants, LPants, Shirt)
	
	for _, cloth in pairs {Backpack, RPants, LPants, Shirt} do
		local cl = cloth.Root:Clone()
		warn(cloth.Name)
		ClothingService:WearCloth(cloth.Name, cl, Player)
	end
end

function SpawnService:SpawnPlayer(Player)
	local SpawnLocations = {CFrame.new(103.624123, 16.1699066, -382.141144), CFrame.new(-216.283875, 16.1974716, -980.819397)}
	local loc = SpawnLocations[math.random(1, #SpawnLocations)]
	delay(0, function()
		for i = 1, 10 do 
			Player.Character.Torso.CFrame = loc
			wait()
		end
	end)
end



function SpawnService:CreateCorpse(Player)
	local Character = Player.Character 
	local clone = Instance.new("Model")
	clone.Name = Player.Name
	for i,v in pairs(Character:GetChildren()) do
		if v:IsA("BasePart") and v.Name ~= "HumanoidRootPart" then
			for ind, val in pairs(v:GetChildren()) do
				if val:IsA("JointInstance") then
					val:Destroy()
				end
			end
			local a = v:Clone()
			a.Parent = clone
			a.CanCollide = true
			a.Velocity = Vector3.new(0,0,0)
		end
	end
	local welds = {
		["Left Hip"] = {
			Part0 = "Torso",
			Part1 = "Left Leg"
		},
		["Left Shoulder"] = {
			Part0 = "Torso",
			Part1 = "Left Arm"
		},
		["Right Shoulder"] = {
			Part0 = "Torso",
			Part1 = "Right Arm"
		},
		["Right Hip"] = {
			Part0 = "Torso",
			Part1 = "Right Leg"
		},
		["Neck"] = {
			Part0 = "Torso",
			Part1 = "Head"
		}
	}	
	
	for i,v in pairs(welds) do
		local cpy = game:GetService("ServerStorage").WeldCache[i]
		local new = Instance.new("Rotate", clone.Torso)
		new.Part0 = clone[v.Part0]
		new.Part1 = clone[v.Part1]
		new.C0 = cpy.C0
		new.C1 = cpy.C1
	end
	-- hax start
	if Character:FindFirstChild("Clothing") then 
		for i,v in pairs(Character:FindFirstChild("Clothing"):GetChildren()	) do
			local cloth = ClothingService:GetCloth(v.Name)
			if cloth then
				ClothingService:WearCloth(cloth.Name, cloth.Root:Clone(), {Character = clone})
			end
		end
	end
	-- hax end
	Character:Destroy()
	wait(0.25)
	clone.Parent = game.Workspace.Corpses
	return clone
end

return SpawnService]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX8ce77fff623048c6af278fbccf96ff10">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ToolService</string>
					<ProtectedString name="Source"><![CDATA[-- manages tool equipping / unequipping, etc

local ToolService = {}



ToolService.EquippedLeft = nil
ToolService.EquippedRight = nil
ToolService.EquippedNP = nil -- nonphysical equipped

ToolService.MaxTools = 10

ToolService.PossibleHotkeys = {
	
	Enum.KeyCode.One,
	Enum.KeyCode.Two,
	Enum.KeyCode.Three,
	Enum.KeyCode.Four,
	Enum.KeyCode.Five,
	Enum.KeyCode.Six,
	Enum.KeyCode.Seven,
	Enum.KeyCode.Eight,
	Enum.KeyCode.Nine,
	Enum.KeyCode.Zero,
	Enum.KeyCode.M,
	Enum.KeyCode.B,
	Enum.KeyCode.E, -- very hackihs.
}

ToolService.HotkeyNames = {
	 "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "M", "B", "E"
}

for i,v in ipairs(ToolService.HotkeyNames) do
	local enum = ToolService.PossibleHotkeys[i]
	print(i)
	ToolService.HotkeyNames[enum] = v
end

local DataManager
local KeyService 
local ObjectService 
local Object
local ToolGui

local IsLocal = (game.Players.LocalPlayer ~= nil)


function ToolService:Constructor()
	if not IsLocal then
		DataManager = _G.Instinct.Services.DataManager
	else 
		ToolGui = _G.Instinct.UI.ToolGui
	end
	KeyService = _G.Instinct.Services.KeyService
	ObjectService = _G.Instinct.Services.ObjectService
	Object = _G.Instinct.Class.Object
	self.Tools = {}
	self.RegisteredTools = {}
	-- self.DefaultTool is IMPORANT!!	
	setmetatable(self.RegisteredTools,{__index = function() return self.DefaultTool end})
end

function ToolService:RegisterTool(Name, Tool)
	if not Tool.Type then
		error("didnt register tool because no type.")
	elseif Tool.Type == "Normal" then
		if Tool.Create and Tool.DoAction then
			self.RegisteredTools[Name] = Tool
		else
			error("didnt register because tool doesnt have a create and action funciton")
		end
	elseif Tool.Type == "NonPhysical" then
		if Tool.DoAction then
			self.RegisteredTools[Name] = Tool
		else
			error("tool doenst have create func")
		end
	else
		error("tool doesnt have type")
	end
end


function ToolService:ChangeHand(tool)
	if tool.Type == "Normal" then
		local waseq = tool.IsEquipped
		print(waseq, 'chke', tool.Hand)
		if tool.Hand == "Left" then

			if self.EquippedRight then
			
				self:GeneralUnequip(self.EquippedRight)
			end
			tool.Hand = "Right"
		else

			if self.EquippedLeft then
				
				self:GeneralUnequip(self.EquippedLeft)
			end
			tool.Hand = "Left"
		end
		if waseq then
		
			self:GeneralUnequip(tool)
			self:GeneralEquip(tool)
		
		end
	end 
end

-- setups st00f
function ToolService:GeneralEquip(tool)
	
	if tool.IsEquipped then
		self:GeneralUnequip(tool)
		return
	end
	print("equipping a tool")
	if tool.Type == "Normal" then
		if tool.Hand == "Left" then
			if self.EquippedLeft then 
				self:GeneralUnequip(self.EquippedLeft)
			end			
			self.EquippedLeft = tool
			tool.Other = self.EquippedRight
			tool.OtherNP = self.EquippedNP
			if self.EquippedNP then
				self.EquippedNP.OtherLeft = tool
			end
			if self.EquippedRight then
				self.EquippedRight.Other = tool
			end
			tool:Equip()
		elseif tool.Hand == "Right" then
			if self.EquippedRight then
				self:GeneralUnequip(self.EquippedRight)
			end
			self.EquippedRight = tool
			tool.Other = self.EquippedLeft
			tool.OtherNP = self.EquippedNP
			if self.EquippedNP then
				self.EquippedNP.OtherRight = tool
			end
			if self.EquippedLeft then
				self.EquippedLeft.Other = tool
			end
			tool:Equip()
		end
	elseif tool.Type == "NonPhysical" then
		if self.EquippedNP then
			self:GeneralUnequip(self.EquippedNP)
		end
		self.EquippedNP = tool
		tool.OtherLeft = self.EquippedLeft
		tool.OtherRight = self.EquippedRight
		if self.EquippedLeft then
			self.EquippedLeft.OtherNP = tool
		end
		if self.EquippedRight then
			self.EquippedRight.OtherNP = tool
		end
		tool:Equip()
	end
	tool.IsEquipped = true
	ToolGui:UpdatePositions()	
end

function ToolService:GeneralUnequip(tool)
	print("unequipping a tool")
	tool.IsEquipped = false
	tool:Unequip()
	if tool.Type == "Normal" then
		if tool.Hand == "Left" then
			if self.EquippedRight then
				self.EquippedRight.Other = nil
			end
			self.EquippedLeft = nil
		elseif tool.Hand == "Right" then
			if self.EquippedLeft then
				self.EquippedLeft.Other = nil
			end
			self.EquippedRight = nil
		end
	elseif tool.Type == "NonPhysical" then
		if self.EquippedRight then
			self.EquippedRight.OtherNP = nil
		end
		if self.EquippedLeft then
			self.EquippedLeft.OtherNP = nil
		end
		self.EquippedNP = nil
	end
	ToolGui:UpdatePositions()
end

function ToolService:Enable()

	KeyService.KeyDown:connect(function(key, state)
		if key then 
			if key == "m1" or key == "m2" then
				if not self.EquippedNP then
					if key == "m1" and self.EquippedLeft then
						self.EquippedLeft:DoAction(key)
					elseif key == "m2" and self.EquippedRight then
						self.EquippedRight:DoAction(key)
					end
				else
					self.EquippedNP:DoAction(key)
				end
			else 
				for _, tool in pairs(self.Tools) do

						if tool.Hotkey == key then
							self:GeneralEquip(tool)
						end

				end
			end
		end
	end)
	
	KeyService.DoubleClick:connect(function(key, state)
		if key then 
			if key == "m1" or key == "m2" then
				if not self.EquippedNP then
					if key == "m1" and self.EquippedLeft and self.EquippedLeft.DoDBCAction then
						self.EquippedLeft:DoDBCAction(key)
					elseif key == "m2" and self.EquippedRight and self.EquippedRight.DoDBCAction then
						self.EquippedRight:DoDBCAction(key)
					end
				elseif self.EquippedNP.DoDBCAction then
					self.EquippedNP:DoDBCAction(key)
				end
			end
		end
	end)
	
	
	self.ToolRoot = DataManager:GetContainer(game.Players.LocalPlayer, "Tools")
	if not self.ToolRoot then
		repeat
			self.ToolRoot = DataManager:GetContainer(game.Players.LocalPlayer, "Tools")
			wait()
		until self.ToolRoot
	end
	self.ToolRoot.ChildAdded:connect(function(toolroot)
		print('added tool kewl', toolroot.Name)
		self:AddTool(toolroot)
	end)
	self.ToolRoot.ChildRemoved:connect(function(toolroot)
		print('removing tool nu', toolroot.Name)
		self:RemoveTool(toolroot)
	end)
	for i,v in pairs(self.ToolRoot:GetChildren()) do
		self:AddTool(v)
	end
end

function ToolService:AddTool(root)
	wait()
	print("ADDED TOOL")
	local tname = root.Name
 	local tool = self.RegisteredTools[tname]
	print(tool)
	if tool then
		local new = tool:GetDelegate()
		self:SetHotkey(new, self:GetNewHotkey(new))
		if new.Type ~= "NonPhysical" then
			new.Tool = root:FindFirstChild("Tool"):GetChildren()[1]
			new.ToolRoot = root
		end
		table.insert(self.Tools, new)
		-- add a hotkey
		--print('call getnewhotkey', new)
	--	self:GetNewHotkey(new)
		-- call gui update
		if new.Type ~= "NonPhysical" then
			self:GeneralEquip(new)
		end
		ToolGui:AddTool(new)
		
		print("DONE")
	end
end

function ToolService:RemoveTool(root)
	-- remove from self.Tools
	local tool
	for i,v in pairs(self.Tools) do
		if v.ToolRoot == root then
			tool = v
			table.remove(self.Tools, i)
			break
		end
	end
	function scanl(tab, which)
		if tab and tab[which] and tab[which] == tool then
			tab[which] = nil
		end
	end
	scanl(self, "EquippedLeft")
	scanl(self, "EquippedRight")
	scanl(self.EquippedLeft, "Other")
	scanl(self.EquippedRight, "Other")
	-- cannot drop nonphysical tools so, thats not a porblem
	ToolGui:RemoveTool(tool)
end

-- serversided!
function ToolService:DropTool(tool)
	
end

function ToolService:RequestToolCreation(Name, ObjectList, IsDefault)
	if _G.Instinct.Communicator then
		_G.Instinct.Communicator:Send("RequestToolCreation", Name, ObjectList, IsDefault)
	end
end

function ToolService:GetHotkey(tool)
	return tool.Hotkey
end

function ToolService:SetHotkey(tool, hotkey)
	print("SET HOTKEY", hotkey)
	if tool and hotkey then 
		tool.Hotkey = hotkey
		-- and a setcontext
	end
end

-- sets the first available hotkey to the tool
function ToolService:GetNewHotkey(tool)
	print("tool type: " .. tool.Type)
	if tool.Type == "NonPhysical" then
		
		if tool.Name == "Build" then
			return Enum.KeyCode.B
		elseif tool.Name == "Move" then
			return Enum.KeyCode.M 
		elseif tool.Name == "Eat" then
			return Enum.KeyCode.E 
		else 
			-- custom building tool.
		end
	end
	print("in gnh, ", tool)
	local cp = {}
	for i,v in pairs(self.PossibleHotkeys) do
		
		cp[v] = true
	end
	for i, tool in pairs(self.Tools) do

		cp[tool.Hotkey] = false
	end
	for i,v in pairs(self.PossibleHotkeys) do
		if cp[v] == true then
			return v
		end
	end
end

-- {objname = {objectlist}}
function ToolService:CreateNormalTool(Player, ToolName, ObjectList)
	
	-- lets first create a root container
	if not IsLocal then
		local troot = DataManager:GetContainer(Player, "Tools")
		warn(tostring(troot))
		if troot then
			if #(troot:GetChildren()) >= self.MaxTools then
				if _G.Instinct.Mechanics.Chat then
					_G.Instinct.Mechanics.Chat:Send("You cannot create the tool: " .. ToolName .. " because you already have " .. self.MaxTools .. " tools!", Player)
				end
				return
			end
			warn(tostring(self.RegisteredTools[ToolName]))
			if self.RegisteredTools[ToolName] then
				local new = Instance.new("Model")
				new.Name = ToolName
				local Items = Instance.new("Model", new)
				Items.Name = "Items" -- where tool is built from
				local ToolModel = Instance.new("Model", new)
				ToolModel.Name = "Tool" -- where tool is put in later hue?
				for objname, objects in pairs(ObjectList) do
					local mod = Instance.new("Model", Items)
					mod.Name = objname
					for i, object in pairs(objects) do
						object.Parent = mod
					end
				end
				self.RegisteredTools[ToolName]:Create(ToolModel, ObjectList)				
				
				new.Parent = troot -- call ChildAdded on client ^_^
			end
		end
	end
end

function ToolService:ToSaveData(ToolRoot)
	local out = {} -- q data
	out.Name = ToolRoot.Name
	-- gewd
	out.Items = {}
	local items = ToolRoot:FindFirstChild("Items")
	if items then
		for i, container in pairs(items:GetChildren()) do
			out.Items[container.Name] = {}
			for id, item in pairs(container:GetChildren()) do 
				table.insert(out.Items[container.Name], ObjectService:GetSaveData(item))
			end
		end
	end
	return out
end

function ToolService:FromSaveData(Data)
	local Name = Data.Name
	local root = {}
	for ItemName, ItemList in pairs(Data.Items) do
		root[ItemName] = {}
		print("ItemName: " .. ItemName)
		for i, itemd in pairs(ItemList) do
			local data = ObjectService:CreateObjectFromSaveData(itemd)
			print(data)
			table.insert(root[ItemName], data)
		end
	end
	print(Name, root, "from toolservice")
	return Name, root
end

function ToolService:SetCooldown(Hand, Time)
	-- set cooldown, also in GUI
end


return ToolService]]></ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="Folder" referent="RBX43714b2a17664195ad74ff5f4ac0838a">
			<Properties>
				<string name="Name">Mechanics</string>
			</Properties>
			<Item class="Script" referent="RBXebb25874266c4dc8bb698a092d390fab">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Chat</string>
					<ProtectedString name="Source"><![CDATA[local Chat = {}

-- Chat provides everything necessary for backend chat. GUI should be loaded from anything else.

local IsLocal = (game.Players.LocalPlayer ~= nil)



Chat.EnergyTap = {
	Global = 50;
	Shout = 25;
	Yell = 10;
	Default = 0;
	Whisper = 0;
}

Chat.Range = {
	Global = math.huge;
	Shout = 300;
	Yell = 200;
	Default = 100;
	Whisper = 20;
}

Chat.Keywords = {
	["g/"] = "Global";
	["s/"] = "Shout",
	["kappa/"] = "Yell",
	["w/"] = "Whisper",
	["d/"] = "Default",
}

function Chat:Send(Message, Player)
	local Communicator = _G.Instinct.Communicator
	if IsLocal then

		Communicator:Send("Chat", Message, Player.Name)
	else
		Communicator:Send(Player, "Chat", Message, "Default", "_host")
	end
end

function Chat:SendGlobal(Message)
	local Communicator = _G.Instinct.Communicator
	Communicator:SendAll("Chat", Message, "Default", "_host")
end

-- returns energytap, range and "real message"
function Chat:GetAttributes(message)
	local mode = message:sub(1,2)
	local cmode = self.Keywords[mode] or "Default"
	local cmsg = message
	if self.Keywords[mode] then
		cmsg = message:match(mode.."%s*(.+)")
	end
	cmsg = self:FixMessage(cmsg)
	return self.EnergyTap[cmode], self.Range[cmode], (self.Keywords[mode] or "Default"), cmsg
end

-- makes msg nice.
function Chat:FixMessage(msg)
	if not msg then return "" end
	-- fix first
	local msg = msg:gsub("^%W*%w", function(what)  return string.upper(what) end)
	--local msg = msg:gsub("%.%W%w", function(what) print(2, what) return string.upper(what) end)
	local msg = msg:gsub("%.%s*%l", function(qq) return string.upper(qq) end)
	local msg = msg:gsub("\n", function(qq) return "" end)
	if msg:len() > 150 then
		msg = msg:sub(1,150)
	end
	return msg
end

return Chat]]></ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="Script" referent="RBXe26578bf3174437db317c90b40f12d50">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Communicator</string>
				<ProtectedString name="Source"><![CDATA[local Communicator = {}

local IsLocal = (game.Players.LocalPlayer~=nil)

function Communicator:Constructor()
	if IsLocal then
		-- war has begun god dammit
		_G.Counter = (_G.Counter or 0) + 1
		local DEBOUNCER = _G.Counter or 0
		
		self.Commands = _G.Instinct.Data.CommandsLocal
		self.SendData = game:GetService("ReplicatedStorage").ServerSocket
		self.AskData = game:GetService("ReplicatedStorage").ServerAsk
		-- START HAXY CODE --
		-- small env hack
		-- fix NON-GC'd connection (roblox memleak??)
		local ev = {}
		local function DISCONNECT()
			ev[1]:disconnect()
			ev[2]:disconnect()
			error("@------ DISCONNECTED FROM PREVIOUS EVENTS , ROBLOX GC FAILED? -----@")
		end
		
		ev[1] = self.SendData.OnClientEvent:connect(function(CommandName, ...)
			warn(_G.Counter, DEBOUNCER)
			if DEBOUNCER ~= _G.Counter then
				DISCONNECT()
			end
			print("<- " .. CommandName)
			if self.Commands[CommandName] then
				self.Commands[CommandName]({Type = "Event"}, ...)
			else

				warn(tostring(CommandName) .. " doesnt exist")
			end
		end)
		self.AskData.OnClientInvoke = function(CommandName, ...)
			print("<- " .. CommandName)
			--if DEBOUNCER ~= _G.Counter then
			--	DISCONNECT()
			--end
			if self.Commands[CommandName] then
				return self.Commands[CommandName]({Type="Function"}, ...)
			else
	
				warn(tostring(CommandName) .. " doesnt exist")
			end
		end
		-- END HAXY CODE -- 
	else
		self.Commands = _G.Instinct.Data.CommandsServer
		self.SendData = game:GetService("ReplicatedStorage").ServerSocket
		self.AskData = game:GetService("ReplicatedStorage").ServerAsk
		self.AskData:Destroy() self.SendData:Destroy()
		local new = Instance.new("RemoteEvent", game:GetService("ReplicatedStorage"))
		new.Name = "ServerSocket"
		self.SendData = new
		local new = Instance.new("RemoteFunction", game:GetService("ReplicatedStorage"))
		new.Name = "ServerAsk"
		self.AskData = new
		
		self.SendData.OnServerEvent:connect(function(Player, CommandName, ...)
		print("<- " .. CommandName)
			if self.Commands[CommandName] then
				self.Commands[CommandName]({Type = "Event", Player=Player}, ...)
			else
		
				warn(tostring(CommandName) .. " doesnt exist")
			end
		end)
		self.AskData.OnServerInvoke = function(Player, CommandName, ...)
			print("<- " .. CommandName)
			if self.Commands[CommandName] then
				return self.Commands[CommandName]({Type="Function", Player=Player}, ...)
			else
				
				warn(tostring(CommandName) .. " doesnt exist")
			end
		end
	end
end

if IsLocal then 
	function Communicator:Send(Command, ...)
		print("-> " .. Command)
		self.SendData:FireServer(Command, ...)
	end
	function Communicator:Ask(Command, ...)
		print("-> " .. Command)
		return self.AskData:InvokeServer(Command, ...)
	end
else
	function Communicator:Send(Player, Command, ...)
		print("-> " .. Command)
		self.SendData:FireClient(Player, Command, ...)
	end
	function Communicator:Ask(Player, Command, ...)
		print("-> " .. Command)
		return self.AskData:InvokeClient(Player, Command, ...)
	end
	function Communicator:SendAll(Command, ...)
		print("-> " .. Command)
		self.SendData:FireAllClients(Command, ...)
	end
end

return Communicator]]></ProtectedString>
			</Properties>
		</Item>
		<Item class="Folder" referent="RBX242ad18d623a4c4a8420cb97df88e156">
			<Properties>
				<string name="Name">Libraries</string>
			</Properties>
			<Item class="Script" referent="RBX7173b2e65d1a4df2a3976168efd04632">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Content</string>
					<ProtectedString name="Source"><![CDATA[local Content = {}

function Content:WaitForContent()

	local last = game:GetService("ContentProvider").RequestQueueSize
	while game:GetService("ContentProvider").RequestQueueSize > 0 do
		wait()
		if game:GetService("ContentProvider").RequestQueueSize ~= last then
			last = game:GetService("ContentProvider").RequestQueueSize
		end
	end
end

return Content]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX5b6342419c45425f97abeecfcaefb2bd">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Knapping</string>
					<ProtectedString name="Source"><![CDATA[-- Knapping function



local Knapping = {}

Knapping.Patterns = {
	Knife = {
		{false, false, false, false, false	},
		{false, false, false, false, false},
		{true, true, true, true, true},
		{true, true, true, true, false},
		{false, false, false, false, false}
	},
	Pickaxe = {
		{false, false, false, false, false},
		{false, true, true, true, false},
		{true, false, false, false, true},
		{false, false, false, false, false},
		{false, false, false, false, false},
		
	},
	Axe = {
		{false, false, false, false, true},
		{true, true, true, true, true},
		{true, true, true, true, true},
		{true, true, true, true, true},
		{false, false, false, false, true},
	}
}

function Knapping:Knap(What)
	if self.Knapping then
		self:StopKnap()
	end
	-- block tools
	_G.Instinct.Services.KeyService.State = "Knapping" 
	_G.Instinct.UI.Chat:PutLocal("Click on the rock to remove a piece. Press z to return. If nothing could be created the stone is lost.")
	self.KeyConnection = _G.Instinct.Services.KeyService.KeyDown:connect(function(key, state)
	--	OLDPRINT("KNAP KEYDOWN", key)
		if key == "m1" or key == "m2" then
			--OLDPRINT(Mouse.Target and Mouse.Target.Parent.Name)
			local Mouse = game.Players.LocalPlayer:GetMouse()
			local Camera = game.Workspace.CurrentCamera
			if Mouse.Target and  Mouse.Target.Parent == Camera:FindFirstChild("Knap") then
				Mouse.Target:Destroy()
			end 
		elseif key == Enum.KeyCode.Z then
			self:StopKnap()
		end
	end)
	local Camera = game.Workspace.CurrentCamera
	self.Knapping = What
	self.KnappingParent = What.Parent
	game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = 0
	self.LastCF = Camera.CoordinateFrame
	self:ConvertToKnapObject(What)
	Camera.CameraType = "Scriptable"
	Camera.CoordinateFrame = CFrame.new(What.Position + Vector3.new(0,5,0), What.Position)
	
end

function Knapping:StopKnap()
	if self.KeyConnection then
		self.KeyConnection:disconnect()
		self.KeyConnection = nil
	end
	local this = game.Workspace.CurrentCamera:FindFirstChild("Knap")
	local didhit = false
	local wrong
	local created
	-- chkcreate
	for createdname, data in pairs(self.Patterns) do
		wrong = false
		created = createdname
		for y, d in pairs(data) do
			for x, val in pairs(d) do
				print(val, this:FindFirstChild(y.."x"..x) ~= nil, x,y)
				if (this:FindFirstChild(y.."x"..x) ~= nil) == val then
					
				else
					if #(this:GetChildren()) ~= 25 then
						didhit = true
					end
					wrong = true
					created=nil
					break
				end 
			end
			if wrong then
				created=nil
				break
			end
			if created then
				--break
			end
		end
		if created then break end
	end

	
	if created then
		_G.Instinct.Communicator:Send("CreateKnap", self.Knapping, created)
	end
	
	if didhit then
		_G.Instinct.Communicator:Send("DestroyResource", self.Knapping, "KnappingError")
	end	
	
	game.Players.LocalPlayer.Character.Humanoid.WalkSpeed=16
	_G.Instinct.Services.KeyService.State = "Default"
	local Camera = game.Workspace.CurrentCamera
	Camera.CoordinateFrame = self.LastCF
	Camera.CameraType = "Custom"
	if self.Knapping then 
		self.Knapping.Parent = self.KnappingParent
	end
	if Camera:FindFirstChild("Knap") then
		for i,v in pairs(Camera:GetChildren()) do 
			if v.Name == "Knap" then 
				v:Destroy()
			end
		end
	end
	self.Knapping = nil
	self.KnappingParent = nil
end



function Knapping:ConvertToKnapObject(root)
	root.Parent = nil
	local center = root.CFrame
	local y = root.Position.y
	local Camera = game.Workspace.CurrentCamera
	local temp = Instance.new("Model", Camera)
	temp.Name = "Knap"
	for x = -0.4, 0.4, 0.2 do 
		for z = -0.4, 0.4, 0.2 do
			local new = root:Clone()
			new.FormFactor = "Custom"
			new.Size = Vector3.new(0.2,1,0.2)
			new.Anchored = true
			new.CFrame = CFrame.new(center.x + x, y, center.z + z)
			new.Name = math.abs(((x + 0.6) * 5) - 6) .. "x" .. ((z + 0.6) * 5)
			new.Parent = temp
		end
	end	
end

return Knapping]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX77161415a90746b5b6cf58b6b2835411">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Mover</string>
					<ProtectedString name="Source"><![CDATA[local Mover = {}

local KeyService

function Mover:Constructor()
	KeyService = _G.Instinct.Services.KeyService
end

local Mouse = game.Players.LocalPlayer:GetMouse()

Mover.MoveRoot = nil


Mover.Mode = "Nothing" 

Mover.CurrentAngles = {
	0,0,0
} -- Angles in RAD

Mover.AngleIncrement = math.pi/4 -- 45 degrees ^_^
Mover.StudIncrement = 1 -- snapper

function Mover:CreateBuilder()
	self.RemConn = {}
	local Gui = game:GetService("ReplicatedStorage").BuildGui:Clone()
	Gui.Parent = game.Players.LocalPlayer.PlayerGui
	local r = Gui.BuildGui.ContentClipper
	self.Gui = Gui
	self.ContentRoot = r	
	-- Connect all events to be very interactive ^_^
	local mv = r.Mode.Contents

	local arrow = mv.Arrow
	self.Arrow = arrow
	
	mv.Handle.MouseButton1Click:connect(function()
		if not self.MoveRoot then return end
		self:ToHandleMode()
		arrow:TweenPosition(UDim2.new(0.05, 0, 0, 35))
	end)
	mv.Resize.MouseButton1Click:connect(function()
		if not self.MoveRoot then return end
		local ok, err = self:CanResize() 
		if ok then 
			self:ToResizeMode()
			arrow:TweenPosition(UDim2.new(0.05, 0, 0, 60))
		else 
			self:SetStatus(err)
		end
	end)	
	mv.Rotate.MouseButton1Click:connect(function()
		if not self.MoveRoot then return end
		self:ToRotateMode()
		arrow:TweenPosition(UDim2.new(0.05, 0, 0,85))
	end)
	mv.Target.MouseButton1Click:connect(function()
		if not self.MoveRoot then return end
		arrow:TweenPosition(UDim2.new(0.05, 0, 0,10))
		self:ToMoveMode()
		
	end)
	-- Snap connections to change GripSnap size
	local sr = r.Snap.Contents.Target
	for i,v in pairs(sr:GetChildren()) do
		if v.Name ~= "Selection" then
			v.MouseButton1Click:connect(function()
				sr.Selection.Text = v.Text
				self.StudIncrement = tonumber(v.Text)
			end)
		end
	end
	-- Rotatoes
	local rr = r.Rotate.Contents.Target
	for i,v in pairs(rr:GetChildren()) do
		if v.Name ~= "Selection" then
			v.MouseButton1Click:connect(function()
				rr.Selection.Text = v.Text
				local num = tonumber(v.Text)
				local part = num/90
				self.AngleIncrement = part * math.pi/2
			end)
		end
	end
	r.Confirm.Contents.Target.MouseButton1Click:connect(function()
		print("CLICKED CONFIRM")
		if self.MoveRoot then
			self:Confirm()
		end
	end)
end

function Mover:CreateMover()
	self.RemConn = {}
end

function Mover:Confirm()
	-- notify server of size,cf
	self:SetStatus("Confirming...")
	local size = self.MoveRoot.Size
	if self.UseSize == size then
		size=nil
	end
	if self.MoverType == "Build" then
		_G.Instinct.Communicator:Ask("Build", self.MoveRoot, self.MoveRoot.CFrame, size)
	elseif self.MoverType == "Move" then
		_G.Instinct.Communicator:Ask("RequestMove", self.MoveRoot, self.MoveRoot.CFrame)
	end
	self:SetStatus("Click a resource to start")
	self.MoveRoot = nil
	self:InitializeActionChange()
end

function Mover:Clicked(m)
	print(m, self.Mode)
	if self.MoveRoot and self.MoverType == "Move" then
		self:Confirm()
		return
	elseif self.MoverType == "Move" then
		return
	end
	if m == "m1" and self.Mode == "Target" then
		self:CancelMovements()
	elseif self.MoveRoot and self.Mode == "Nothing" then
		if self.Arrow then
			self.Arrow:TweenPosition(UDim2.new(0.05, 0, 0, 10))
		end
		self:ToMoveMode()
	end
end

function Mover:DoubleClicked(m)
	-- confirm!
	print("DOUBLE LCIKC", m)
end

function Mover:CancelMovements()
	self.Mode = "Nothing"
	self:InitializeActionChange()
end

-- disown; return;
function Mover:Abort()
	self:CancelMovements()
	self:SetStatus("Cancelling...")
	_G.Instinct.Communicator:Ask("CancelResourceLock", self.MoveRoot)
	self:SetStatus("Click a resource to start")
	self.MoveRoot = nil
end

function Mover:SetStatus(Text)
	if not self.Gui then return end
	self.ContentRoot.Status.Contents.Target.Text=Text
end

function Mover:GetRootCFrame()
	if self.MoveRoot:IsA("Model") then
		-- FAK!
		return self.MoveRoot:GetModelCFrame()
	else
		return self.MoveRoot.CFrame
	end
end

function Mover:GetRootSize()
	if self.MoveRoot:IsA("Model") then
		return self.MoveRoot:GetModelSize()
	else
		return self.MoveRoot.Size
	end
end

function Mover:SetRootCFrame(CF)
	local Player = game.Players.LocalPlayer
	local Char = Player.Character
	if Char then
		if Char:FindFirstChild("Torso") then
			if (Char.Torso.Position - CF.p).magnitude > 20 then
				return
			end
		end
	end	
	
	
	if self.MoveRoot:IsA("Model") then
		local function moveModel(model,targetCFrame)
			for i,v in pairs(model:GetChildren()) do
				if v:IsA("BasePart") then
					v.CFrame=targetCFrame:toWorldSpace(model:GetModelCFrame():toObjectSpace(v.CFrame))
				end
				moveModel(v, targetCFrame)
			end
		end

		moveModel(self.MoveRoot, CF)
	else
		if self.MoveRoot:FindFirstChild("chParent") then
			for i,v in pairs(self.MoveRoot:GetChildren()) do
				if v:IsA("BasePart") and v.Name == "chParent" then
					local weld = v:FindFirstChild("Weld")
					if weld then
						local c0 = weld.C0
						v.CFrame = CF * c0
					end
				end
			end
			self.MoveRoot.CFrame = CF
		else
			self.MoveRoot.CFrame = CF
		end
	end
end

function Mover:SetRootSize(Size)
	local v = Size.x * Size.y * Size.z 
	local mv = self.UseSize.x * self.UseSize.y * self.UseSize.z 
	if v > mv then
		self:SetStatus("The volume of the resize is bigger than the original")
		return false
	end
	if self.MoveRoot:IsA("Model") then
		-- ... wat ... 
		warn("cannot resize models")
		return false
	end
	self.MoveRoot.Size=Size
	return true
end

function Mover:SelectTarget(Root)
	-- First check if we can get..
	warn("HERE")
	print(self.MoverType,  self.MoverType == "Build")
	if self.MoverType == "Build" then
	
		local o = _G.Instinct.Services.ObjectService:GetObject(Root.Name)
		local c = o:GetConstant("BuildingMaterial")
		print(#c)
		if #c==0 then
			self:SetStatus("This is not a building material!")
			return
		end
		for i,v in pairs(c) do
			if not v then
				self:SetStatus("This is not a building material!")
				return
			end
		end
		local size = _G.Instinct.Services.ObjectService:GetSize(Root)
		if size.x < 1 or size.y  < 1 or size.z < 1 then
			self:SetStatus("This resource is too small.")
			return
		end

	end	
	
	
	self.GettingMoveRoot = true
	-- call server to lock resource for self.
	self:SetStatus("Trying to lock resource...")
	local CanGet, msg = _G.Instinct.Communicator:Ask("RequestResourceLock", Root)
	
	if CanGet then
		self.MoveRoot = Root
		self.MoveRoot.Parent = game.Workspace 
	
		if Root:IsA("Model") then
			self.UseSize = Root:GetModelSize()
			function scan(f) 
				for i,v in pairs(f:GetChildren()) do
					if v:IsA("BasePart") then
						v.Anchored=true
						v.CanCollide=false
						v.Locked=true -- .. k
					end
					scan(v)
				end
			end
		
		else
			Root.Anchored=true
			Root.Locked=true
			Root.CanCollide=false
			self.UseSize = Root.Size
		end
		
		if self.MoverType == "Build" then
			local size = _G.Instinct.Services.ObjectService:GetSize(Root)
			local rs = {x=size.x, y=size.y, z=size.z}
			for i,v in pairs(rs) do
				rs[i] = math.floor(v) -- round down to lowest.
			end
			self:SetRootSize(Vector3.new(rs.x,rs.y,rs.z))
		end
	else
		self:SetStatus(msg or "")
	end
	self.GettingMoveRoot = false

end

-- Move to close grid number
local function close(num, tonext)
	local upv = (num + (tonext - (num % tonext)))
	if upv - num > tonext * 0.5 then
		return (num - (num % tonext))
	end
	return upv
end



function Mover:ResetAngles()
	self.CurrentAngles = {0,0,0}
end

-- Function to clean up OldActions
function Mover:InitializeActionChange()
	if self.CurrentHandles then
		self.CurrentHandles:Destroy()
	end
	for i,v in pairs(self.RemConn) do
		v:disconnect()
	end
	self.RemConn = {}
end

function Mover:CanResize() -- should return false + err
	if self.MoveRoot:IsA("BasePart") then
		if self.MoveRoot:FindFirstChild("chParent") == nil then
			local o = _G.Instinct.Services.ObjectService:GetObject(self.MoveRoot.Name)
			if o:GetConstant("ResizeTool") then
				local tr = o:GetConstant("ResizeTool")
				local tools = _G.Instinct.Services.ToolService
				if tools.EquippedRight and tools.EquippedRight.Tool.Name == tr[1] then
					return true
				elseif tools.EquippedLeft and tools.EquippedLeft.Tool.Name == tr[1] then
					return true
				else
					return false, "You need a " .. tr[1] .. " equipped to resize this!"
				end
			end			
			
			return true
		else
			return false, "You cannot resize this resource!"
		end
	else
		return false, "You cannot resize this resource!"	
	end

end

function Mover:ToResizeMode()
	if self:CanResize() then
		
		self:InitializeActionChange()
		self.Mode = "Resize"
		self:SetStatus("Drag the handles to resize the resource.")
		local handles = Instance.new("Handles", game.Players.LocalPlayer.PlayerGui)
		handles.Adornee = self.MoveRoot
		handles.Style = "Resize"
		self.CurrentHandles = handles
		self.LockedCF = self:GetRootCFrame() -- origin cframe, can be used for resets
		self.OrigSize = self:GetRootSize()
		local last = {}
		setmetatable(last, {__index=function() return 0 end})
	
		local low = 0.2 
		handles.MouseDrag:connect(function(face, delta)
			if math.abs(last[face] - delta) >= self.StudIncrement then 
				local nDist = last[face] - delta
				local size_now = self:GetRootSize()
				local r = Enum.NormalId 

				local x,y,z = size_now.x, size_now.y, size_now.z 
				local dx, dy, dz = 0,0,0
				local fx,fy,fz = x,y,z
				local mod = 1
				local snap = close(nDist, self.StudIncrement)
				if face == r.Back then --
					z = -snap + z 
				elseif face == r.Right then 
					x = -snap + x 
				elseif face == r.Left then 
					mod = -1 -- ?
					x = -snap + x
				elseif face == r.Front then  --
					z = -snap + z
					mod = -1
				elseif face == r.Top then 
					y = -snap + y
					
				elseif face == r.Bottom then 
					y = -snap + y 
					mod = -1
				end
				print(face)
				last[face] = last[face] - nDist

				if x < low or y < low or z < low then 
					return 
				end
				local rcf = self:GetRootCFrame()
				local ok = self:SetRootSize(Vector3.new(x,y,z))
				local vec = Vector3.new(x,y,z) - Vector3.new(fx,fy,fz)
				if not ok then
					vec = Vector3.new(0,0,0)
				end
				local mod = (vec) * 0.5 * mod 
				--print(Vector3.new(offset.x, offset.y, offset.z))
				self.LockedCF = rcf * CFrame.new(mod)
				self:SetRootCFrame(self.LockedCF)-- * CFrame.new(Vector3.new(-use.x/2, -use.y/2, -use.z/2)))
			end
		end)
		--print("connectiong")
		-- ONLY GETS FIRED WHEN UP @ HANDLE, CONNECT TO UINPUT
		table.insert(self.RemConn, KeyService.KeyUp:connect(function(mouse, state)
			if mouse ~= "m1" then return end
		--	print("UP")
			for i,v in pairs(last) do
				last[i] = 0
			
			end

		end))
	end
end

function Mover:ToHandleMode()
	self:InitializeActionChange()
	self.Mode = "Move"
	self:SetStatus("Drag the handles to move the resource.")
	local handles = Instance.new("Handles", game.Players.LocalPlayer.PlayerGui)
	handles.Adornee = self.MoveRoot
	handles.Style = "Movement"
	self.CurrentHandles = handles
	self.LockedCF = self:GetRootCFrame() -- origin cframe, can be used for resets
	local offset = {x=0,y=0,z=0}
	local root = {x=0,y=0,z=0}
	handles.MouseDrag:connect(function(face, delta)
		--print(face)
		local cfd = { -- unit delta vectors.
			[Enum.NormalId.Top] = Vector3.new(0,1,0); --
			[Enum.NormalId.Back] = Vector3.new(0,0,1);  --
			[Enum.NormalId.Left] = Vector3.new(-1,0,0); --
			[Enum.NormalId.Right] =Vector3.new(1,0,0);
			[Enum.NormalId.Front] = Vector3.new(0,0,-1); --
			[Enum.NormalId.Bottom] = Vector3.new(0,-1,0); --
		}
		local mvpos = cfd[face] * delta
		--local rpos = Vector3.new(close(mvpos.x, self.StudIncrement), close(mvpos.y, self.StudIncrement), close(mvpos.z, self.StudIncrement))
		for _,i in pairs({"x", "y", "z"}) do
			if mvpos[i] ~= 0 then
				offset[i] = close(cfd[face][i] * delta, self.StudIncrement) + root[i]
			end
		end
		local vec = offset 
		self:SetRootCFrame(self.LockedCF * CFrame.new(Vector3.new(offset.x, offset.y, offset.z)))
	end)
	table.insert(self.RemConn, KeyService.KeyUp:connect(function(mouse, state)
		if mouse ~= "m1" then return end
		for i,v in pairs(offset) do
			root[i] = root[i] + v
		end
	end)
	)
	
end



function Mover:ToRotateMode()
	self:InitializeActionChange()
	self.Mode = "Rotate"
	local handles = Instance.new("ArcHandles", game.Players.LocalPlayer.PlayerGui)
	handles.Adornee = self.MoveRoot
	self:SetStatus("Drag the handles to rotate the resource.")
	self.CurrentHandles = handles
	self.LockedCF = self:GetRootCFrame() -- origin cframe, can be used for resets
	local offset = {X=0,Y=0,Z=0}
	local root = {X=0,Y=0,Z=0}
	handles.MouseDrag:connect(function(face, delta)
		--print(face)
		local mvpos = delta
		--local rpos = Vector3.new(close(mvpos.x, self.StudIncrement), close(mvpos.y, self.StudIncrement), close(mvpos.z, self.StudIncrement))
		for _,i in pairs({"X", "Y", "Z"}) do
			if face == Enum.Axis[i] then
				offset[i] = (close(delta, self.AngleIncrement) + root[i]) % (math.pi * 2)
			end
		end
		local vec = offset 
		--print(offset.X/(math.pi/2), offset.Y/(math.pi/2), offset.Z/(math.pi/2))
		self:SetRootCFrame( self.LockedCF * CFrame.Angles(offset.X, offset.Y, offset.Z))
	end)
	table.insert(self.RemConn, KeyService.KeyUp:connect(function(mouse, state)
		if mouse ~= "m1" then return end
		for i,v in pairs(offset) do
			root[i] = (root[i] + v) % (math.pi * 2)
		end
	end))
end

-- Where should targ move? (For Target mode)
function Mover:GetTransformedCFrame()
	-- Move MoveRoot away so we can get the current target and hit..
	self.MoveRoot.Parent = nil
	local Target = Mouse.Target
	local Hit = Mouse.Hit
	if not Target then return end
	
		-- Rotate
	local Rotates = {
		[Enum.NormalId.Top] = CFrame.Angles(0,0,0); --
		[Enum.NormalId.Back] = CFrame.Angles(math.pi/2,0,0);  --
		[Enum.NormalId.Left] = CFrame.Angles(0,0, math.pi/2); --
		[Enum.NormalId.Right] = CFrame.Angles(0, 0,-math.pi/2);
		[Enum.NormalId.Front] = CFrame.Angles(-math.pi/2, 0, 0); --
		[Enum.NormalId.Bottom] = CFrame.Angles(math.pi, 0, 0); --
	}	
	
	
	local Surface = (Mouse.TargetSurface)
	--print(Surface)
	
	-- Get a rotated cframe so we can get a "local axis" offset.
	local RotatedCFrame = (Target.CFrame * Rotates[Surface])


	self.MoveRoot.Parent = game.Workspace
	-- Strip rotation matrix..
	local TargetRot = RotatedCFrame:toObjectSpace(CFrame.new(Target.Position))
	
	local Hit = CFrame.new(Hit.p) * TargetRot -- rotate the cframe. (Just copy target cframe)
	-- Retrieve offset.
	local offset = RotatedCFrame:toObjectSpace(Hit).p;
	-- Tansform target (this strips the rotation of the hit cframe and aligns it)
	--print(offset)
	-- y is always UP; noffset the rest.
	local noffset = Vector3.new(close(offset.x, self.StudIncrement), offset.y, close(offset.z, self.StudIncrement))	
	--print(noffset)
	--local vcf = Target.CFrame * CFrame.new(noffset)
	
	
	--[[local CenterCF = Target.CFrame * Rotates[Surface] -- rotated;
	local CenterSize = Target.Size
	local CenterCF = CenterCF * CFrame.new(0, CenterSize/2, 0)
	local Offset = Hit:toObjectSpace(CenterCF)
	print(Offset.p)--]]
	local newcf = RotatedCFrame * CFrame.new(noffset)
	
	-- Specific wedgepart top surface chk
	if Target:IsA("WedgePart") then 
		if Surface == Enum.NormalId.Top then 
			local real_ang = math.atan2(Target.Size.x, Target.Size.z)
	--		print(real_ang)
			newcf = newcf * CFrame.Angles(-real_ang, 0, 0)
		end
	end
	

	
	local Transform = CFrame.Angles(unpack(self.CurrentAngles))
	-- Here are hooks for possible r/t keys to rotate!
	local ax, ay, az = self.CurrentAngles[1], self.CurrentAngles[2], self.CurrentAngles[3]
	
	local Size =  self:GetRootSize()/2
	local newSize = Vector3.new(Size.x * math.sin(ax), Size.y * math.cos(ay), Size.z * math.sin(az))
	
	--print(newSize)	

	return newcf * CFrame.new(newSize) * Transform
end

function Mover:ToMoveMode()
	if not self.MoveRoot then return end
	self:InitializeActionChange()
	self.Mode = "Target"
	self:SetStatus("The resource moves to the mouse cursor. Click to lock position.")
	local id = (self.ModeID or 0) + 1
	self.ModeID = id
	print("moving..")
	while self.MoveRoot and self.Mode == "Target" and self.ModeID == id do -- breaks other threads.
		
		local newCF = self:GetTransformedCFrame()
	--	print(newCF)
		if newCF then
			self:SetRootCFrame(newCF)
		end
		wait()
	end
end


if false then
delay(1, function()
	Mover:ToHandleMode()
	wait(1)
	Mover:ToRotateMode()
	wait(1)
	Mover:ToResizeMode()
end)
Mover:ToMoveMode()
end

return Mover]]></ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="Folder" referent="RBXd007e989ad384e06aa709c38fdcd8be3">
			<Properties>
				<string name="Name">Utilities</string>
			</Properties>
			<Item class="Script" referent="RBXa73bea995fd747e486ca66cb71bdc5fd">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Event</string>
					<ProtectedString name="Source"><![CDATA[local Event = {}

function Event:Call()
	self:fire()
end

function Event:Constructor()
	self.List = {}
end

function Event:connect(func)
	table.insert(self.List, func)
	local ret = {}
	local link = self
	function ret:disconnect()
		for i,v in pairs(link.List) do
			if v == func then
				link.List[i] = nil
				break
			end
		end
	end
	return ret
end

function Event:fire(...)
	local args = {...}
	for i,v in pairs(self.List) do 
		delay(0, function() v(unpack(args)) end)
	end
end

function Event:wait()
	-- well well well HOW IN THE WORLD ARE WE GOING TO DO THIS!?
	--> BUSY WAIT!? (no?)
	--> any kind of awesome coroutine hack?
end

return Event]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX87fbe84c689949519f7d152baa34fe69">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Option</string>
					<ProtectedString name="Source"><![CDATA[--[[
	Option
	Purpose:
		Create Option functions
		Similiar to roblox enums
		The name "Option" is chosen in order to prevent confusion
		Roblox uses enums
		Instinct uses options
		QQ
--]]

-- DEFINE ALL OPTIONS HERE!

local Options = {}

local opt_meta = {}

function opt_meta:__tostring()
	return "Option."..self[1]..self[2]
end

function Options.New(option_type, option_list)
	Options[option_type] = {}
	for i,v in pairs(option_list) do
		Options[option_type][v] = {option_type, v}
		Options[option_type][i] = Options[option_type][v]
		setmetatable(Options[option_type][v], opt_meta) -- tostring
	end
end

-- 

--Options.New("ConsolePriority", {"Low", "Normal", "High", "Extreme"})

return Options]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX77567f67cc834b14b5b0f15b9d0af3c7">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">BrickColorUtils</string>
					<ProtectedString name="Source"><![CDATA[local BrickColorUtils = {}

BrickColorUtils.Data = {

["Deep pink"] = {
1032,
1015,
1016,
},
Purple = {
104,
1026,
1006,
1031,
1023,
},
["Deep yellow"] = {
226,
24,
1008,
1017,
1009,
},
Green = {
37,
1020,
141,
1021,
151,
29,
28,
1028,
119,
1022,
},
["Light pink"] = {
1025,
9,
},
White = {
1029,
1001,
1,
1002,
194,
208,
},
Brown = {
105,
106,
217,
192,
18,
1014,
38,
133,
},
["Deep blue"] = {
1011,
1012,
107,
23,
1013,
1010,
},
["Light yellow"] = {
5,
125,
1030,
},
Black = {
199,
26,
1003,
},
["Light blue"] = {
1019,
102,
1018,
11,
135,
45,
1024,
1027,
},
Red = {
1007,
21,
101,
1004,
153,
},
}

return BrickColorUtils]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBXcf03ca7f2ca54ce2b86d3781265345fc">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">CFrameTools</string>
					<ProtectedString name="Source"><![CDATA[local CFrameTools = {}

local acos=math.acos
local v3=Vector3.new
local components=CFrame.new().components
local inverse=CFrame.new().inverse
local fromAxisAngle=CFrame.fromAxisAngle

function CFrameTools:AxisAngleInterpolate(c0,c1,t)--CFrame0,CFrame1,Tween
	local _,_,_,xx,yx,zx,xy,yy,zy,xz,yz,zz=components(inverse(c0)*c1)
	local c=(xx+yy+zz-1)/2
	return c0*fromAxisAngle(v3(yz-zy,zx-xz,xy-yx),acos(c>1 and 1 or c<-1 and -1 or c)*t)+(c1.p-c0.p)*t
end


return CFrameTools]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX23046ed5ea04441e8aa94ebf5116dd17">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ColorTools</string>
					<ProtectedString name="Source"><![CDATA[local ColorTools = {}

function ColorTools.RGBToColor3(r,g,b)
	return Color3.new(r/255,g/255,b/255)
end

return ColorTools]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBXb132f70ec89945ae96d80fa3a980c46c">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Date</string>
					<ProtectedString name="Source"><![CDATA[local Date = {}

Date.Constants = {
	millisecond = 0.001,
	second = 1,
	minute = second * 60,
	hour = minute * 60,
	day = hour * 24,
	week = day * 7,
	year = day * 365,
	lyear = day * 366,
	lsyear = day * 366 + second,
	syear = day * 365,
}

Date.Months = {
	{"Jan", 31}, {"Feb", 28},
	{"Mar", 31}, {"Apr", 30},
	{"May", 31}, {"Jun", 31},
	{"Jul", 31}, {"Aug", 30},
	{"Sep", 31}, {"Oct", 30},
	{"Nov", 31}, {"Dec", 30}	
}

Date.Start = 30 * Date.Constants.year + 7 * Date.Constants.day -- 2000 start

function Date.YearIsLeap(year) -- a full year
	return (year % 4) == 0
end

function Date.UnixToDate(time)
	local time = math.floor( ( time or os.time() ) + 0.5)
	-- 1 january 1970 00:00:00 -> 0
	local from2000 = time - Date.Start
	
	local yearsleft = from2000 % ( Date.Constants.year	)
	from2000 = from2000 - yearsleft * Date.Constants.year
	
	
end

return Date]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBXc29663af548744568919b7331e29db70">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Palette</string>
					<ProtectedString name="Source"><![CDATA[local Palette = {}



local ct = _G.Instinct.Utilities.ColorTools

local rgb = ct.RGBToColor3


Palette.Data = {
	Default = {
		Default = rgb( 43,125, 43),
		Shade0 = rgb(180,255, 180),
		Shade1 = rgb(120,186,120),
		Shade2 = rgb( 73,151, 73),
		Shade3 = rgb( 20, 95, 20),
		Shade4 = rgb(  2, 63,  2),
	},
	Stats = {
		Hunger = rgb(186,186,120),
		Thirst = rgb(120,120,186),
		Health = rgb(120,186,120),
		Energy = rgb(186, 120,120)
	},
	Shade1 ={
		Default = rgb( 32, 94, 94),
		Shade1 = rgb( 90,140,140),
		Shade2 = rgb( 54,113,113),
		Shade3 = rgb( 15, 72, 72),
		Shade4 = rgb(  2, 47, 47),
	},
	Shade2 = {
		Default = rgb(114,146, 51),
		Shade1 = rgb(191,217,140),
		Shade2 = rgb(146,177, 85),
		Shade3 = rgb( 82,111, 23),
		Shade4 = rgb( 50, 73,  3),
	},
	Complement = {
		Default = rgb(156, 54, 54),
		Shade1 = rgb(233,150,150),
		Shade2 = rgb(189, 91, 91),
		Shade3 = rgb(119, 25, 25),
		Shade4 = rgb( 78,  3,  3),
	},
	Console = {
		Default = rgb(0,0,0),
		Text = rgb(255,255,255),
	},
	Text = {
		Default = rgb(0,0,0),
		White = rgb(255,255,255)
	},
	Background = {
		Default = rgb(0,0,0),
		Shade1 = rgb(20,20,20),
		Shade2 = rgb(40,40,40),
		Shade3 = rgb(60,60,60),
		Shade4 = rgb(80,80,80),
	},
	SFX = {
		Default = rgb(0,0,0), -- shade color
	},
	ColorLabel = { -- colorlabel tags!
		black = rgb(0,0,0),
		red = rgb(128,0,0),
		green = rgb(0,128,0),
		yellow = rgb(128,128,0),
		blue = rgb(0,0,128),
		purple = rgb(128,0,128),
		cyan = rgb(0,128,128),
		white = rgb(192,192,192)
		
		
	},
	ColorLabelLight = {
		black = rgb(128,128,128),
		red = rgb(255,0,0),
		green = rgb(0,255,0),
		yellow = rgb(255,255,0),
		blue = rgb(0,0,255),
		purple = rgb(255,0,255),
		cyan = rgb(0,255,255),
		white = rgb(255,255,255)		
		
	}
	
	
	--[[ 0 #000000  1 #800000  2 #008000  3 #808000  4 #000080  5 #800080  6 #008080  7 #c0c0c0
 8 #808080  9 #ff0000 10 #00ff00 11 #ffff00 12 #0000ff 13 #ff00ff 14 #00ffff 15 #ffffff--]]
}

function Palette:Get(Type, Which)
	local Type = Type or "Default"
	local Which = Which or "Default"
	if self.Data and self.Data[Type] then 
		return self.Data[Type][Which] or self.Data[Type].Default 
	else 
		return self.Data.Default[Which] or self.Data.Default.Default
	end
end

function Palette:GetRaw(Type, Which) -- can return nil! raw checks
	return self.Data[Type] and self.Data[Type][Which]
end

return Palette]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX49fa6cbff1bc4e24a25a39614d7f8983">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Random</string>
					<ProtectedString name="Source"><![CDATA[local Random = {}

function Random:FromWeightsTable(tab)
	local tweight = 0
	for i,v in pairs(tab) do
		tweight = tweight + v
	end
	local portion = math.random() * tweight
	local start = 0
	for i,v in pairs(tab) do 
		start = start + v
		if start > portion then
			return i
		end
	end
end

return Random]]></ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="Folder" referent="RBXc7596cbb6e60431997fd04612672948c">
			<Properties>
				<string name="Name">UI</string>
			</Properties>
			<Item class="Script" referent="RBXa016c59ff4e044439706ed9e223d077b">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">MainMenu</string>
					<ProtectedString name="Source"><![CDATA[-- MainMenu provides the main menu for the game
-- Additional modules can be launched from here
-- Insertion points are provided



local MainMenu = {}

MainMenu.TitleFont = "ArialBold"
MainMenu.FontSize = "Size36"
MainMenu.TitleShade = 3

MainMenu.BarSize = 4
MainMenu.BarOffset = 3
-- elegant is to put this in constructor
MainMenu.BarColor = _G.Instinct.Utilities.Palette:Get()  -- meh?
MainMenu.BarScale = 0.8 -- 80% of the original size

MainMenu.TextWhiteSpace = 10

MainMenu.ButtonFont = "ArialBold"
MainMenu.ButtonFontSize = "Size24"
MainMenu.VersionFontSize = "Size14"

MainMenu.WhiteSpace = 20
MainMenu.ButtonShading = 2 -- wow so much shading
MainMenu.XOffset = 50

MainMenu.Choosen = nil --


function MainMenu:Constructor()
	self.Choosen = _G.Instinct.Create(_G.Instinct.Utilities.Event)
end

local Player = game.Players.LocalPlayer

function MainMenu:CreateFromList(title, list) -- creates the main menu from gui items
	local Palette = _G.Instinct.Utilities.Palette 
	local Locale = _G.Instinct.Services.Locale 
	local Presets = _G.Instinct.Gui.GuiPresets 
	local Dim = _G.Instinct.Gui.DimTools
	local VERSION = _G.Instinct.Version
	local title = title 
	local Root = Instance.new("ScreenGui", Player.PlayerGui)
	self.Root = Root
	local Backdrop = Presets.Backdrop(5)
	local MMLabel, x, y = Presets.CustomButton(
		title,		self.TitleShade, self.TitleFont, self.FontSize, 
		 Palette:Get("Text"),  Palette:Get("Complement"), 
		self.TextWhiteSpace) 
	local curry = self.WhiteSpace
	Backdrop.Parent = Root
	MMLabel.Parent = Backdrop
	local curry = curry + y + self.WhiteSpace
	MMLabel.Position = UDim2.new(0.5, -x/2, 0, self.WhiteSpace)
	local max_x = x
	table.insert(list, 1, "Version "..VERSION)
	for i,v in pairs(list) do
		local DeltaY = -( self.TextWhiteSpace - self.BarOffset )
		local inspos = curry + DeltaY 
	--	local new = Instance.new("Frame", BackDrop) -- ?????????
		local b,x,y
		if i ~= 1 then 
			b,x,y = Presets.CustomButton(v, self.ButtonShading, self.ButtonFont, 
			self.ButtonFontSize, Palette:Get("Text"), Palette:Get("Complement", "Shade2"), 
			self.TextWhiteSpace
			)
		else 
			b,x,y = Presets.CustomButton(v, self.ButtonShading, self.ButtonFont,
			self.VersionFontSize,  Palette:Get("Text"), Palette:Get("Complement", "Shade1"), 
			self.TextWhiteSpace
			)
		end 
		b.Parent = Backdrop
		b.Position = UDim2.new(0.5, -x/2, 0, curry)
		b.MouseButton1Click:connect(function()
			self.Choosen:fire(b.Text)
		end)
		curry = curry + y + self.WhiteSpace
		if x > max_x then
			x = max_x
		end
	end
	
	Backdrop.Size = UDim2.new(0, max_x + self.WhiteSpace, 0, curry)
	Backdrop.Position = UDim2.new(1,-(max_x + self.WhiteSpace) - self.XOffset, 0.5, -curry/2)
end

function MainMenu:Close()
	self.Root:Destroy()
end


return MainMenu]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX221aba7c3a7d4ac0a2c6ec34816f8a69">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Menu</string>
					<ProtectedString name="Source"><![CDATA[-- Defines modules;
local ButtonBar, Palette, SFX, WindowServer, DDMenu, DimTools

local Player = game.Players.LocalPlayer

local Menu = {}

Menu.Offset = 4
Menu.YSize = 30
Menu.Shade = 2
Menu.BorderSize = 3
Menu.FontSize = "Size14"
Menu.LastDropDown = nil
Menu.LastDropDownButton = nil

function Menu:Constructor()
	-- Updates ENV to new modules
	ButtonBar = _G.Instinct.UI.ButtonBar 
	Palette = _G.Instinct.Utilities.Palette 
	SFX = _G.Instinct.UI.SFX
	WindowServer = _G.Instinct.UI.WindowServer 
	DDMenu =_G.Instinct.UI.DropDown 
	DimTools = _G.Instinct.UI.DimTools
end

function Menu:Init()
	local Scr = Instance.new("ScreenGui", Player.PlayerGui)
	Scr.Name = "Menu"
	self.Root = Scr
	local bar = Instance.new("Frame", Scr)
	self.Bar= bar
	bar.Size=UDim2.new(0,0,0,self.YSize)
	bar.BorderSizePixel = self.BorderSize
	bar.BorderColor3 = Palette:Get("Default", "Shade4")
	bar.BackgroundColor3 = Palette:Get("Default", "Shade2")
	self.Bar = bar
	-- create dropdown button
	bar.Position = UDim2.new(0.5, 0, 0, 0)
end

function Menu:GetButton(type, openlist)
	local DropDown = Instance.new("TextButton", self.Bar)
	local offset = self.YSize - self.Offset * 2
	DropDown.BackgroundColor3 = Palette:Get("Complement")
	DropDown.TextColor3 = Palette:Get("Text")
	DropDown.Font = "ArialBold"
	DropDown.FontSize = self.FontSize
	DropDown.Text = "V"
	DropDown.BorderSizePixel = 0
	SFX.Shade(DropDown,self.Shade)
	if type == "DropDown" and openlist then 
		DropDown.MouseButton1Click:connect(function()
		if self.LastDropDown then
			self.LastDropDown:Destroy()
		end
		if self.LastDropDownButton == DropDown then
			self.LastDropDownButton = nil
			return
		end
		self.LastDropDownButton = DropDown
		local new = _G.Instinct:Create(DDMenu)
		self.LastDropDown = new
		new:Create(self.Root, UDim2.new(0,0,0, self.YSize + self.BorderSize), Palette:Get("Default", "Shade1"), Palette:Get("Default", "Shade4"), 
			{	which = DropDown,
				left = false,
				right = true,
				up = false,
				down = true,
				bordersize = self.BorderSize,
		})
		for i,v in pairs(openlist) do 
			local NewButton = new:AddButton(v)
			NewButton.MouseButton1Click:connect(function()
				WindowServer.RequestOpen(NewButton.Text, NewButton)
			end)
		end
		end)
	else 
		-- negotiate with winserver
		local Window
		DropDown.MouseButton1Click:connect(function() 
			local xWindow = WindowServer.RequestOpen(DropDown.Text, DropDown)
		
		end)
	end
	return DropDown
end

function Menu:AddButton(button_name, type, openlist)
	local button = self:GetButton(type or "Window", openlist)
	button.Text = button_name
	local max = 0
	for i,v in pairs(self.Root:GetChildren()) do
		if v.Position.X.Offset + v.Size.X.Offset + self.Offset + self.Shade > max then 
			max = v.Position.X.Offset + v.Size.X.Offset + self.Offset + self.Shade
		end
	end
	button.Position = UDim2.new(0,max,0,self.Offset)
	local offset = self.YSize - self.Offset * 2
	local x = DimTools.TextSize(button_name, button.Font, button.FontSize)
	button.Size = UDim2.new(0, x + 10, 0, offset)
	local nsize = max + button.Size.X.Offset + self.Offset + self.Shade
	delay(1/30, function() self.Bar.Size = UDim2.new(0, nsize, 0, self.YSize) end)
end

return Menu ]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX2fd9ab31135047efb98e98a51ea25cfb">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ButtonBar</string>
					<ProtectedString name="Source"><![CDATA[local ButtonBar = {}

local Dim, Presets

function ButtonBar:Constructor()
	Dim = _G.Instinct.UI.DimTools
	Presets = _G.Instinct.UI.GuiPresets
end

ButtonBar.Font = "ArialBold"
ButtonBar.FontSize = "Size12"
ButtonBar.WhiteSpace = 5
ButtonBar.Shade = 2
ButtonBar.TextWhiteSpace = 10 -- total whitespace


-- zomg u wanna msutfit? kthen
-- we will fit ur bar yes
-- we like that we like to fit the bar
-- pls


-- does not respect text size yes only y size
ButtonBar.MustFit = false
-- omg how much left; between buttons; etc
ButtonBar.FitGap = 10




function ButtonBar:Init(where, pos, size, parent)
	local frame = parent or Instance.new("Frame", where)
	frame.ClipsDescendants = true
	frame.BackgroundTransparency = 1
	local x_size, y_size = Dim.TextSize("test", self.Font, self.FontSize)
	frame.Size = size or UDim2.new(1,0, 0, y_size + self.Shade)
	frame.Position = pos or UDim2.new(0,0,0,0)
	self.Root = frame
end


function ButtonBar:AddButton(name)
	local button = Presets.Button(self.Shade)
	button.Parent = self.Root
	local max_x = -math.huge
	for i,v in pairs(self.Root:GetChildren()) do
		if v.Position.X.Offset + v.AbsoluteSize.X > max_x then
			max_x = v.Position.X.Offset + v.AbsoluteSize.X
		end
	end
	
	local new = max_x + self.WhiteSpace
	local size, ysize = Dim.TextSize(name, self.Font, self.FontSize)
	button.Size = UDim2.new(0, size + self.TextWhiteSpace, 0, ysize)
	button.Position = UDim2.new(0,new,0,0)
	button.Text = name 
	
	if self.MustFit then
		self:FixFit()
	end
	
	return button
end

return ButtonBar]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX910774dedcb540ec85c9c2bb5e6de55c">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Chat</string>
					<ProtectedString name="Source"><![CDATA[local Chat = {}

local ScrollBar, Palette, ChatData, SFX, DimTools

Chat.IsFocussed = false

function Chat:Constructor()
	ScrollBar = _G.Instinct.UI.ScrollBar
	Palette  = _G.Instinct.Utilities.Palette
	ChatData = _G.Instinct.Mechanics.Chat
	SFX = _G.Instinct.UI.SFX
	DimTools = _G.Instinct.UI.DimTools
end

function Chat:SelectMode(char)
	local kw = ChatData.Keywords[char.."/"]
	if kw and self.SelectedText then
		self.SelectedText.Text = kw .. " [" .. ChatData.EnergyTap[kw]  .. "]"
		
	end
end

function Chat:Enable()
	self.Enabled=true
	warn("creating")
	warn(tostring(self))
	local Screen = Instance.new("ScreenGui", game.Players.LocalPlayer.PlayerGui)
	local Root = Instance.new("Frame")
	Root.Parent = Screen
	Root.BackgroundColor3 = Palette:Get("Default", "Shade2")
	Root.BackgroundTransparency = 0
	Root.Size = UDim2.new(0,260,0,200)
	Root.BorderColor3 = Palette:Get("Default", "Shade4")
	Root.BorderSizePixel = 2;
	Root.Position = UDim2.new(0,20,0,20)
	--Root.ClipsDescendants = true
	Root.BackgroundTransparency = 1
	local ChatModes = {"w", "d", "y", "s", "g"}
	local ChatETap = {}
	for i,v in pairs(ChatModes) do
		local kw = ChatData.Keywords[v.."/"]
		if kw then
			ChatETap[v] = ChatData.EnergyTap[kw]
		end
	end
	self.ChatContainer = Root
	print(Root:GetFullName())
	local ChatBar = Instance.new("Frame", Screen)
	ChatBar.Position = UDim2.new(0, 20, 0, 200 + 20 + 10)	
	ChatBar.BorderSizePixel = 2
	ChatBar.BorderColor3 = Palette:Get("Default", "Shade4")
	ChatBar.BackgroundColor3 = Palette:Get("Default", "Shade2")
	
	ChatBar.Size = UDim2.new(0, 220, 0, 36)
	local CX = 0
	local selected
	for i,v in pairs(ChatModes) do
		local new = Instance.new("TextButton", ChatBar)
		new.BorderSizePixel = 1
		new.BorderColor3 = Palette:Get("Default", "Shade3")
		new.BackgroundColor3 = Palette:Get("Default", "Shade1")
		new.Text = v
		new.Size = UDim2.new(0, 15, 0, 18)
		new.Position = UDim2.new(0, 15 * (i - 1) + i * 1, 0, 0)
		new.Font = "ArialBold"
		new.TextColor3 = Palette:Get("Text", "White")
		new.TextStrokeColor3 = Palette:Get("Text")
		new.TextStrokeTransparency = 0
		new.FontSize = "Size14"
		CX = 15 * (i ) + (i-1) * 1
		if v == "d" then
			selected=new
			new.BackgroundColor3 = Palette:Get("Shade1", "Shade2")
		end
		new.MouseButton1Click:connect(function()
			self:SelectMode(v)
			selected.BackgroundColor3 = Palette:Get("Default", "Shade1")
			new.BackgroundColor3 = Palette:Get("Shade1", "Shade2")
			selected=new
		end)
	end
	
	local SelectedText = Instance.new("TextLabel", ChatBar)
	SelectedText.BorderColor3 = Palette:Get("Default", "Shade3")
	SelectedText.BackgroundColor3 = Palette:Get("Default", "Shade1")
	SelectedText.Text = ""
	SelectedText.Size = UDim2.new(0, CX, 0, 16)
	SelectedText.Position = UDim2.new(0, 1, 0, 19)
	SelectedText.Font = "ArialBold"
	SelectedText.TextColor3 = Palette:Get("Text", "White")
	SelectedText.TextStrokeColor3 = Palette:Get("Text")
	SelectedText.TextStrokeTransparency = 0
	SelectedText.FontSize = "Size14"

	
	self.SelectedText = SelectedText	
	self:SelectMode("d")	
	
	ChatBar.Size = UDim2.new(0, CX+2, 0, 36)
	
	local Form = Instance.new("TextBox", ChatBar)
	Form.BorderColor3 = Palette:Get("Default", "Shade3")
	Form.BackgroundColor3 = Palette:Get("Default", "Shade1")
	Form.Text = "Click here or press / to chat"
	Form.Size = UDim2.new(0, 260 - CX - 8 - 2, 0, 16)
	Form.Position = UDim2.new(0, CX + 8, 0, 10)
	Form.Font = "ArialBold"
	Form.TextColor3 = Palette:Get("Text", "White")
	Form.TextStrokeColor3 = Palette:Get("Text")
	Form.TextStrokeTransparency = 0
	Form.FontSize = "Size14"
	local osize =  UDim2.new(0, 260 - CX - 8 - 2, 0, 16)
	Form.Changed:connect(function(prop)
		if prop == "Text" then
			if Form.TextBounds.X + 10 > Form.Size.X.Offset then
				Form.Size = UDim2.new(0, Form.TextBounds.X + 10, 0, Form.Size.Y.Offset)
				
			end
		end
	end)
	
	Form.FocusLost:connect(function(t)
		if not t then return end
		self.IsFocussed = false
		if selected.Text == "d" then
			_G.Instinct.Communicator:Send("Chat", Form.Text)
		else
			_G.Instinct.Communicator:Send("Chat", selected.Text.."/ "..Form.Text)
		end
		Form.Size = osize
		Form.Text = "Click here or press / to chat"
	end)
	
	local uis = game:GetService("UserInputService")
	uis.InputBegan:connect(function(obj)
		local _,key = pcall(function() return obj.KeyCode end)
		
		if key == Enum.KeyCode.Slash then
			if self.IsFocussed then return end
			self.IsFocussed = true
			Form:CaptureFocus()
		end
	end)
	
	return Root
end

function Chat:Push(delta, ignore)
	for i,v in pairs(self.ChatContainer:GetChildren()) do
		if v ~= ignore then 
			v.Position = UDim2.new(0,0,1, v.Position.Y.Offset - delta)
		end
		if (v.Position.Y.Offset + v.Size.Y.Offset + 2) < -self.ChatContainer.Size.Y.Offset then
			v:Destroy()
		end
	end
end

function Chat:PutLocal(Message)
	self:Process(Message, "Default", "_local")
end

function Chat:Process(Message, Mode, Receipent)
	warn(tostring(self.ChatContainer))
	warn(tostring(self))
	-- I WANT A FUCKING STACK TRACE< WTF
	--error("err, mes was : " .. Message)
	if not self.ChatContainer then return end
	if not self.Enabled then return end
	local transform = {
		Default = "said",
		Whisper = "whispered",
		Yell = "yelled",
		Shout = "shouted",
		Global = "screamed"
	}	
	
	local text = Instance.new("TextLabel", self.ChatContainer)
	local font = "ArialBold"
	local fonts = "Size18"
	
	local Receipent=Receipent
	local put = Receipent .. " " .. (transform[Mode] or "ERR_NOMODSTR") .. ": " .. Message
	if Receipent == "_host" then
		text.BackgroundColor3 = Palette:Get("Shade1", "Shade2")
		put = "Server notified: " .. Message
	elseif Receipent == "_local" then
		put = Message
		text.BackgroundColor3 = Palette:Get("Complement", "Shade1")
	else
		text.BackgroundColor3 = Palette:Get("Complement", "Shade2")
	end
	
	local x,y = DimTools.TextSize(put, font, fonts)
	text.Size = UDim2.new(0, x + 10, 0, y + 6)
	SFX.Shade(text,2)

	text.Font = font
	text.FontSize = fonts
	text.Text = put
	text.TextColor3 = Palette:Get("Text", "White")
	text.TextStrokeColor3 = Palette:Get("Text")
	text.TextStrokeTransparency = 1
	
	text.Position = UDim2.new(0, 0, 1, -(y + 6 + 2))
	
	self:Push(y + 6 + 6, text) -- 3 = whitespace qq
end


return Chat]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBXb74f253b7045420b97ad678f6a8aaf6d">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ColorLabel</string>
					<ProtectedString name="Source"><![CDATA[local ColorLabel = {}

local Palette, Dim

function ColorLabel:Constructor()
	Palette = _G.Instinct.Utilities.Palette
	Dim = _G.Instinct.UI.DimTools
end

ColorLabel.FontSize = "Size12"
ColorLabel.Font = "Arial"
ColorLabel.BoldFont = "ArialBold"

ColorLabel.DefaultColor = Palette:Get("Text")

-- Parsing:
-- default escape; %{red light bold}

function ColorLabel:GetElementList(txt)
	-- returns a table with elements to build labels from
	-- ret: {txt, font, fontcolor}
	local out = {}
	local dmode = {self.Font, self.DefaultColor} -- default mode
	local cmode = dmode -- current mode
	local last
	for match, newmode in string.gmatch(txt, "([^%%]*)(%b%})") do
		last = newmode
		table.insert(out, {match, cmode[1], cmode[2]}) --unpack(cmode)
		cmode = {}
		local elements = {} -- elements provided;
		for element in string.gmatch(newmode, "[^{} ]+") do
			elements[element:lower()] = true
		end
		if not elements.reset then 
			if elements.bold then
				cmode[1] = self.BoldFont
				elements.bold = nil
			else
				cmode[1] = self.Font
			end
			local palette = "ColorLabel"
			if elements.light then
				palette = "ColorLabelLight"
				elements.light = nil
			end
			for i,v in pairs(elements) do
				local color = Palette:Get(palette, i) 
				if color then 
					cmode[2] = color
				end
			end
		else 
			cmode = dmode
		end
		if not cmode[2] then
			cmode[2] = self.DefaultColor
		end
	end
	local tail 
	if last then 
		tail = txt:match("%"..last.."(.-)$")
		local test = tail
		local loop = 0
		while test do
			test = tail:match("%"..last.."(.-)$")
			if test then
				tail = test
			end
			loop = loop + 1
			if loop > 50 then 
				break
			end
		end 
	end

	if not tail then
		tail = txt -- no escapes provided, kthen
	end
	table.insert(out, {tail, cmode[1], cmode[2]})
	return out
	
	
end


function ColorLabel:GetLabel(txt,c)
	if c then
		self.DefaultColor = c
	end
	local list = self:GetElementList(txt)
	local root
	local x = 0 -- offsetz
	local function newlabel(text, font, color)
		local new = Instance.new("TextLabel", root)

		local xsize, ysize = Dim.TextSize(text, font, self.FontSize)
		new.Size = UDim2.new(0,xsize,0,ysize)
		new.TextColor3 = color
		new.Text = text
		new.Font = font
		new.FontSize = self.FontSize
		new.BackgroundTransparency = 1
		new.Position = UDim2.new(1,x,0,0)
		if not root then
			root = new
		else 
			x = x + xsize
		end
	end
	for item_id, item_data in pairs(list) do
		local Text = item_data[1]
		local Font = item_data[2]
		local Color = item_data[3]
		newlabel(Text, Font, Color)
	end
	return root
end

return ColorLabel]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBXc726796dc8a94777b30c82250a1f7717">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">DimTools</string>
					<ProtectedString name="Source"><![CDATA[-- DimTools define functions for moving and reszing GUIs around
-- They dont respect the parent GUIs

local DimTools = {}

function DimTools.GetScreenSize()
	if not game.Players.LocalPlayer.PlayerGui:FindFirstChild("FontCHK") then 
		local new = Instance.new("ScreenGui", game.Players.LocalPlayer.PlayerGui)
		new.Name = "FontCHK"
		local x = Instance.new("TextButton", new)
		x.Visible = false
	end
	local gui = game.Players.LocalPlayer.PlayerGui:FindFirstChild("FontCHK")
	while not (gui.AbsoluteSize.X > 0 and gui.AbsoluteSize.Y > 0) do
		wait()
	end
	return gui.AbsoluteSize
end

function DimTools.Center(Gui)
	Gui.Position = UDim2.new(0.5 - (Gui.Size.X.Scale/2), -Gui.Size.X.Offset * 0.5, 0.5 - (Gui.Size.Y.Scale/2), -Gui.Size.Y.Offset * 0.5)
end

function DimTools.TextSize(text, font, fontsize)
	if not game.Players.LocalPlayer.PlayerGui:FindFirstChild("FontCHK") then 
		local new = Instance.new("ScreenGui", game.Players.LocalPlayer.PlayerGui)
		new.Name = "FontCHK"
		local x = Instance.new("TextButton", new)
		x.Visible = false
	end
	local my = game.Players.LocalPlayer.PlayerGui.FontCHK.TextButton

	my.FontSize = fontsize
	my.Text = text
	my.Font = font
	if my.TextBounds.X <= 0.99 or my.TextBounds.Y <= 0.99 then
		repeat wait(1/60) 
		until my.TextBounds.X >0.99 and my.TextBounds.Y >0.99
	end
	local x = my.TextBounds.X
	local y = my.TextBounds.Y
	return x, y
end

return DimTools]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBXc0cde8d811694316b6e16a58e79cd0b4">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">DropDown</string>
					<ProtectedString name="Source"><![CDATA[local DropDown = {}

DropDown.XOffset = 10
DropDown.YOffset = 5
DropDown.TextOffset = 5
DropDown.Shade = 2

local SFX, Palette, Dim 

function DropDown:Constructor()
	SFX = _G.Instinct.UI.SFX
	Presets = _G.Instinct.UI.GuiPresets
	Dim = _G.Instinct.UI.DimTools
end

function DropDown:Create(Parent, Position, BackgroundC3, BorderC3, BorderSize)
	local new = Presets.Canvas(BackgroundC3)
	new.Position = Position or UDim2.new(0,0,0,0)
	new.Parent = Parent
	if type(BorderSize) == "table" then
		local need = { "left", "right", "down", "up", "bordersize"}
		local wrong = false
		for i,v in pairs(need) do 
			if BorderSize[v] == nil then 
				wrong = true
				break
			end
		end
		if not wrong then
			SFX.MakeBorder(new, BorderSize.left, BorderSize.right, BorderSize.up, BorderSize.down, BorderC3, BorderSize.bordersize)
		end
	else
		new.BorderSizePixel = BorderSize or 0
		new.BorderColor3 = BorderC3 or Palette:Get()
	end
		
	self.Root = new
end

function DropDown:AddButton(text)
	local new = Presets.Button(self.Shade)
	local numbuttons = 0
	for i,v in pairs(self.Root:GetChildren()) do
		if v.Name ~= "Border" then
			numbuttons = numbuttons + 1
		end
	end
	local ypos = (self.YOffset + self.Shade + new.Size.Y.Offset) * numbuttons + self.YOffset
	new.Text = text
	new.FontSize = "Size12"
	local xt, yt = Dim.TextSize(text, "ArialBold", "Size12")
	new.Size = UDim2.new(0, xt + self.TextOffset * 2, 0, new.Size.Y.Offset)
	new.Position = UDim2.new(0, self.XOffset, 0, ypos)
	new.Parent = self.Root
	local max_x = 0
	for i,v in pairs(self.Root:GetChildren()) do
		if v.Name ~= "Border" then 
			local new_x = self.XOffset * 2 + v.Size.X.Offset
			if new_x > max_x then
				max_x = new_x
			end
		end
	end
	for i,v in pairs(self.Root:GetChildren()) do
		if v.Name ~= "Border" then 
			v.Size = UDim2.new(0, max_x - self.XOffset * 2, 0, new.Size.Y.Offset)
		end
	end
	local ysize = ypos + new.Size.Y.Offset + self.Shade + self.YOffset
	self.Root.Size = UDim2.new(0,max_x, 0, ysize)
	
	return new
	
end


function DropDown:Destroy()
	self.Root:Destroy()
end

return DropDown]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBXc70a5bf59ed4417f94ec677002430c15">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">GuiPresets</string>
					<ProtectedString name="Source"><![CDATA[local GuiPresets = {}

local Palette, SFX, Dim
function GuiPresets:Constructor()
	Palette = _G.Instinct.Utilities.Palette
	SFX = _G.Instinct.UI.SFX
	Dim = _G.Instinct.UI.DimTools
end

function GuiPresets.Button(shade)
	local DropDown = Instance.new("TextButton")
	DropDown.BackgroundColor3 = Palette:Get("Complement")
	DropDown.TextColor3 = Palette:Get("Text")
	DropDown.Font = "ArialBold"
	DropDown.Text = ""
	DropDown.BorderSizePixel = 0
	DropDown.Size = UDim2.new(0,10,0,20)
	DropDown.FontSize = "Size12"
	if shade then 
		SFX.Shade(DropDown,shade)
	end
	return DropDown
end

-- for easy creationz
-- returns button, xsize, ysize
-- omg it so awesome
function GuiPresets.CustomButton(ButtonText, ButtonShade, ButtonFont, ButtonFontSize, TextColor, BackgroundColor, WhiteSpace)
	local ButtonText = ButtonText or ""
	local ButtonShade = ButtonShade or 0
	local ButtonFont = ButtonFont or "ArialBold"
	local ButtonFontSize = ButtonFontSize or "Size12"
	local TextColor = TextColor or Palette:Get("Text")
	local BackgroundColor = BackgroundColor or Palette:Get("Complement")
	local WhiteSpace = WhiteSpace or 10	
	local new = Instance.new("TextButton")
	new.Text = ButtonText
	new.Font = ButtonFont
	new.FontSize = ButtonFontSize
	new.TextColor3 = TextColor
	new.BackgroundColor3 = BackgroundColor
	new.BorderSizePixel = 0
	if ButtonShade > 0 then
		SFX.Shade(new, ButtonShade)
	end
	local size_x , size_y = Dim.TextSize(ButtonText, ButtonFont, ButtonFontSize)
	local rs = size_x + WhiteSpace
	new.Size = UDim2.new(0, rs, 0, size_y)
	return new, rs, size_y 
	
end

function GuiPresets.Canvas(color)
	local canvas = Instance.new("Frame")
	canvas.BackgroundColor3 = color or Palette:Get()
	canvas.BorderSizePixel = 0
	return canvas
end

function GuiPresets.Backdrop(bsize)
	local bar = Instance.new("Frame")
	bar.Size=UDim2.new(0,0,0,0)
	bar.BorderSizePixel = bsize
	bar.BorderColor3 = Palette:Get("Default", "Shade4")
	bar.BackgroundColor3 = Palette:Get("Default", "Shade1")	
	return bar
end


return GuiPresets]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX38774dfd6ebf4bf893a762fa51530b1b">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">SFX</string>
					<ProtectedString name="Source"><![CDATA[local SFX = {}

local Palette

function SFX:Constructor()
	Palette = _G.Instinct.Utilites.Palette
end

function SFX.Shade(which, size)
	local size = size or 3
	local shadeunder = Instance.new("Frame", which)
	shadeunder.BorderSizePixel = 0
	shadeunder.BackgroundColor3 = Palette:Get("SFX", "Default")
	shadeunder.Name = "Shade"
	local shaderight = shadeunder:Clone()
	shaderight.Parent = which
	shaderight.Size = UDim2.new(0,size,1,0)
	shadeunder.Size = UDim2.new(1,0,0,size)
	shaderight.Position = UDim2.new(1,0,0,size)
	shadeunder.Position = UDim2.new(0,size,1,0)
	
end

function SFX.RemoveShade(which)
	for i,v in pairs(which:GetChildren()) do
		if v:IsA("Frame") and v.Name == "Shade" then
			v:Destroy()
		end
	end
end

function SFX.MakeBorder(which, left, right, up, down, color, bordersize)
	function get()
		local new = Instance.new("Frame", which)
		new.BackgroundColor3 = color
		new.BorderSizePixel = 0
		new.Name = "Border"
		return new
	end
	-- left
	if left then 
	local x = get()
	local yoffset = -((up and bordersize) or 0)
	x.Position = UDim2.new(0, -bordersize, 0, yoffset)
	x.Size = UDim2.new(0, bordersize, 1, -yoffset + ((down and bordersize) or 0))
	end
	-- right
	if right then
	local x = get()
	local yoffset = -((up and bordersize) or 0)
	x.Position = UDim2.new(1,0,0, yoffset)
	x.Size = UDim2.new(0, bordersize, 1, -yoffset + ((down and bordersize) or 0))
	end
	-- down
	if down then 
	local y = get()
	local xoffset = -((left and bordersize) or 0)
	y.Position = UDim2.new(0,xoffset,1, 0)
	y.Size = UDim2.new(1, xoffset + ((right and bordersize) or 0), 0, bordersize)
	end
	-- up
	if up then 
	local y = get()
	local xoffset = -((left and bordersize) or 0)
	y.Position = UDim2.new(0,xoffset,0, -bordersize)
	y.Size = UDim2.new(0, xoffset + ((right and bordersize) or 0), 0, bordersize)
	end	
end

return SFX]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBXf1ef0cf0d7454c518aea6dbd4855af5a">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ScrollBar</string>
					<ProtectedString name="Source"><![CDATA[-- A scrollbar
-- The :Add function should generate a Gui item which is then aligned

-- Call :Initialize() first after setting options to init the GUI

local ScrollBar = {}

ScrollBar.Type = "Vertical" -- not implemented horizontally yet, placeholder

ScrollBar.Parent = nil
ScrollBar.Size = nil
ScrollBar.BackgroundColor = Color3.new(0,0,0) -- THIS is just a placeholder;
-- > default is transparent
ScrollBar.BackgroundTransparency = 1

ScrollBar.WhiteSpace = 10 -- pixels between LIST items

ScrollBar.Align = "Middle" --> FOR HOOKS LATER ALIGN LEFT, RIGHT, etc
ScrollBar.Speed = 20

function ScrollBar:Constructor()
	self.Items = {}
end

function ScrollBar:Create(size)
	if not self.Parent then
		warn("No parent set, aborting ScrollBar creation")
		return
	end
	local new = Instance.new("Frame", self.Parent)
	new.BackgroundTransparency  = self.BackgroundTransparency
	new.BackgroundColor3 = self.BackgroundColor
	new.ClipsDescendants = true --> hehe
	new.Size = size or self.Size or UDim2.new(1,0,1,0)
	new.MouseWheelBackward:connect(function()
		self:Scroll(-1)
	end)
	new.MouseWheelForward:connect(function()
		self:Scroll(1)
	end)
	self.Root = new
	return new
end

function ScrollBar:PushGUIsAfterPos(pos, amount)
	for i = pos+1, #self.Items do
		local gui = self.Items[i]
		gui.Position = gui.Position + UDim2.new(0,0,0,amount)
		--x = x + itersize + self.WhiteSpace
	end
end

--> INTERNAL GUI insertion 

function ScrollBar:Insert(GUI, pos)
	local pos = pos or (#self.Items + 1)
	table.insert(self.Items, pos, GUI)
	GUI.Parent = self.Root
	local last_item = self.Items[pos-1]
	local x
	if not last_item then
		x = 0
	else
		--> OTHER HOOKS FOR HORIZONTAL!
		x = last_item.Position.Y.Offset + last_item.AbsoluteSize.Y + self.WhiteSpace
	end
	
	local barxsize = self.Root.AbsoluteSize.X	
	
	local alignsize = GUI.AbsoluteSize.X
	local loffset = (barxsize - alignsize)/2
	GUI.Position = UDim2.new(0,loffset,0,x)
	
	local plus = GUI.AbsoluteSize.Y + self.WhiteSpace
	print(plus)	
	self:PushGUIsAfterPos(pos, plus)
end

function ScrollBar:Scroll(dir)
	if not self.Items[1] then 
		return -- no items kthen
	end
	local mysize = self.Root.AbsoluteSize.Y
	local lgui = self.Items[#self.Items]
	local y = lgui.Position.Y.Offset + self.Speed * dir
	if y + lgui.AbsoluteSize.Y < mysize and dir < 0 then
		return -- end of scroll
		
	end
	if self.Items[1].Position.Y.Offset + self.Speed * dir > 0 then
		--print(self.Items[1].Position.Y.Offset + self.Speed * dir)

		return -- start of scroll
	end
	for i,v in pairs(self.Items) do
		v.Position = v.Position + UDim2.new(0,0,0,self.Speed*dir)
	end
end

function ScrollBar:Add(...)
	warn("No Add Function set -> return a GUI item please")
end

-- helper

function ScrollBar:FindGuiIndex(GUI)
	for i,v in pairs(self.Items) do
		if v == GUI then
			return i
		end
	end
end

function ScrollBar:AddBefore(GUI, ...)
	local gpos = self:FindGuiIndex(GUI) or 1
	local GUI_Item = self:Add(...)
	self:Insert(GUI_Item, gpos)
	return GUI_Item
end

function ScrollBar:AddAfter(GUI, ...)
	local gpos = self:FindGuiIndex(GUI)
	--> the insertion position is AFTER the gui so our actual pos is +1
	local gpos = (gpos and gpos+1) or 1
	local GUI_Item = self:Add(...)
	self:Insert(GUI_Item, gpos)
	return GUI_Item
end

function ScrollBar:Place(_,...)
	if #self.Items ~= 0 then 
		warn("sb is not emtpy use addafter or addbefore")
		return
	end
	ScrollBar:AddAfter(nil,...)
end

function ScrollBar:AddToEnd(...)
	local gpos = #self.Items+1
	local GUI_Item = self:Add(...)
	self:Insert(GUI_Item, gpos)
	return GUI_Item
end

-- DO NOT CHANGE GUI SIZE BEFORE CALLING THIS
-- WILL CHANGE GUI SIZE
function ScrollBar:ChangeGUISize(Gui, NewSize)
	local pos = self:FindGuiIndex(Gui)
	local osize = Gui.Size.Y.Offset
	local nsize = NewSize.Y.Offset
	local delta = nsize - osize
	self:PushGUIsAfterPos(pos, delta)
	Gui.Size = NewSize
end

function ScrollBar:AddToStart(...)
	local gpos = 1
	local GUI_Item = self:Add(...)
	self:Insert(GUI_Item, gpos)
	return GUI_Item
end

function ScrollBar:Remove(GUI)
	local lepos = self:FindGuiIndex(GUI)
	if not lepos or not self.Items[lepos] then
		warn("cannot find item!?")
		return -- wat dafaq
	end
	local ledelta = self.Items[lepos].AbsoluteSize.Y + self.WhiteSpace	
	table.remove(self.Items, lepos)
	for i = lepos, #self.Items do
		local gui = self.Items[i]
		gui.Position = gui.Position - UDim2.new(0,0,0,ledelta)
	end
	GUI:Destroy() -- .. !? why wasnt this there...
end

return ScrollBar]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBXa6550b1c29ec42658b832b7e2bf9fd8d">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ScrollText</string>
					<ProtectedString name="Source"><![CDATA[local ScrollText = {}

local Window, Palette, Dim, ColorLabel


ScrollText.Font = "ArialBold"
ScrollText.FontSize = "Size12"

ScrollText.TextColor = Palette:Get("TextColor", "Black")

function ScrollText:Constructor()
	Window = _G.Instinct.UI.Window
	Palette = _G.Instinct.Utilities.Palette
	Dim = _G.Instinct.UI.DimTools
	ColorLabel = _G.Instinct.UI.ColorLabel
end

function ScrollText:Create(where, size, pos)
	local new = Instance.new("Frame", where)
	new.Size = size or UDim2.new(1,0,1,0)
	new.Position = pos or UDim2.new(0,0,0,0)
	new.ClipsDescendants = true
	new.BackgroundTransparency = 1
	self.Root = new
end

function ScrollText:CreateWindow(size)
	
end

function ScrollText:Push(txt, tcolor)
	local new = _G.Instinct:Create(ColorLabel)
	new.FontSize = self.FontSize
	new.DefaultColor = tcolor or Palette:Get "Text"
	new = new:GetLabel(txt, tcolor or Palette:Get("Text"))
	new.Position = UDim2.new(0, 0, 1, 0)
	new.Parent = self.Root
	local size_x, size_y = Dim.TextSize("test", self.Font, self.FontSize)
	for i,v in pairs(self.Root:GetChildren()) do
		v.Position = v.Position - UDim2.new(0,0,0,size_y)
		if v.Position.Y.Offset < -v.Parent.AbsoluteSize.Y then
			v:Destroy()
		end
	end
end

return ScrollText]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX750ffb4d616c4d71bf6576c3cddf0e60">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">SelectionMenu</string>
					<ProtectedString name="Source"><![CDATA[local Window = Instinct.Include("Gui/Window")
local Palette = Instinct.Include("Utilities/Palette")
local SFX = Instinct.Include("Gui/SFX")
local DimTools = Instinct.Include "Gui/DimTools"
local GuiPresets = Instinct.Include "Gui/GuiPresets"


-- Selecitonmenu builds a GUI with a list of items
-- The user selects and item (highlights)
-- Once OK is clicked the SelectionMenu.Selected will fire:
--> button text AND button instnace as argument
--> NIL if the user did NOT SELECT ANYTHING
--> A close button will also be generated; this will do the same

local SelectionMenu = {}


-- Style

-- Size offset per text item
SelectionMenu.SelectionOffset = 6

-- Color map -> index % 2 + 1 -> color index in color table
--> used as background color
SelectionMenu.Colors = {
	Palette:Get("Shade2", "Shade1"),
	Palette:Get("Shade2", "Shade2"),
}

SelectionMenu.SelectionColor = Palette:Get("Shade1", "Shade1")

-- Shades the selection 
-- >= selectionoffset to prevent overflows
SelectionMenu.Shade = 0


-- Horizontal total whitespace per selection
-- On the left side (and right size) this / 2


SelectionMenu.HorizontalWS = 10

-- Vertical space; how much offset between window title, the items, the OK button and the end

SelectionMenu.VerticalSpace = 5

SelectionMenu.OKColor = Palette:Get("Complement")
SelectionMenu.CreateOK = true


SelectionMenu.TextWS = 10

function SelectionMenu:Constructor()
	print("constr")
	self.SelectionDone = Instinct.Create(Instinct.Event)
end



-- No tooltip supported yet
function SelectionMenu:CreateWindow(ItemList, Title, DefaultSelection, Description) 
	assert(ItemList, "No itemlist provided")
	local Window = Instinct.Create(Instinct.Gui.Window)	
	Window.DestroyOnClose = true
	
	
	-- Create a list of text bound items
	
	local TextBounds = {} -- only horizontal
	
	local button = GuiPresets.Button()
	local max = 0
	local tmax = 0	
	
	function chk(txt)
		local s =  DimTools.TextSize(txt, button.Font, button.FontSize)
		TextBounds[txt] = s
		if s > max then
			max = s
		end
	end
	
	for i,v in pairs(ItemList) do
		chk(v)
	end
	
	chk "OK"	
	
	local TitleSizeMinimum = DimTools.TextSize(Title or "Select an item...", Window.TitleFont, Window.TitleFontSize)

	if (TitleSizeMinimum) * 0.5 > max then
		max = TitleSizeMinimum * 2
	end
	
	local ysize_needed = 4 * self.VerticalSpace + (#ItemList * (button.Size.Y.Offset + self.SelectionOffset))	
	
	Window:Create(UDim2.new(0, max + self.HorizontalWS + self.TextWS , 0,  ysize_needed), Title or "Select an item...")
	
	local curry = self.VerticalSpace -- yum
	
	
	
	for i,v in pairs(ItemList) do
			-- Selection Item
			local color_index = ( i % 2 ) + 1
			local color = self.Colors[color_index]
			local cl = button:Clone()
			cl.Parent = Window.Canvas
			cl.Position = UDim2.new(0, self.HorizontalWS/2, 0, curry)
			cl.Size = UDim2.new(0, max + self.TextWS, 0, cl.Size.Y.Offset)
			cl.BackgroundColor3 = color
			cl.Text = v
			if v == DefaultSelection and not self.SelectedButton then 
				self:ChangeSelection(cl)
			end
			cl.MouseButton1Click:connect(function() self:ChangeSelection(cl) end)
			curry = curry + cl.Size.Y.Offset + self.SelectionOffset
	end
	if self.CreateOK then 
				-- OK button
			curry = curry - self.SelectionOffset + self.VerticalSpace
			local cl = button:Clone()
			cl.Parent = Window.Canvas
			cl.Position = UDim2.new(0.5, -TextBounds["OK"]/2,0,curry)
			cl.BackgroundColor3 = self.OKColor
			cl.Text = "OK"
			cl.Size = UDim2.new(0, TextBounds["OK"] + self.TextWS, 0, cl.Size.Y.Offset)
			SFX.Shade(cl, self.Shade)
			cl.MouseButton1Click:connect(function()
				self:Done(true) -- and close window
			end)
	end
	self.Window = Window
	Window.CloseCallback = function()
		self:Done(true)
	end
end

function SelectionMenu:ChangeSelection(newbutton)
	SFX.Shade(newbutton, self.Shade)
	if self.SelectedButton then 
		SFX.RemoveShade(self.SelectedButton)
		self.SelectedButton.BackgroundColor3 = self.OldColor
	end
	self.OldColor = newbutton.BackgroundColor3 
	self.SelectedButton = newbutton
	self.SelectedText = newbutton.Text
	newbutton.BackgroundColor3 = self.SelectionColor
end


function SelectionMenu:Done(do_window_close)
	if not self.CycleDone then 
		self.CycleDone = true
		self.SelectionDone:fire(self.SelectedText)
		if do_window_close then
			self.Window:Close()
		end
	end
end

return SelectionMenu ]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX93c559bcb3ef4fed8815984a4275a419">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">SideBar</string>
					<ProtectedString name="Source"><![CDATA[local SideBar = {}
-- old sidebar, deprecated --


local ObjectService, ScrollBar, ToolService, Dim
SideBar.IsOpen = true

SideBar.ForceClosed = false

SideBar.OpenTime = 0.125
SideBar.MinimalXOpen = 75

function SideBar:Constructor()
	ObjectService = _G.Instinct.Services.ObjectService
	ScrollBar = _G.Instinct.UI.ScrollBar
	ToolService = _G.Instinct.Services.ToolService
	Dim = _G.Instinct.UI.DimTools
	print("CREATED SB")
	local new = game:GetService("ReplicatedStorage").Inventory:Clone()
	new.Parent = game.Players.LocalPlayer.PlayerGui
	self.XSize = new.Sidebar.Size.X.Offset
	local ResourceCategoryContainer = new.Sidebar.RealBar.Inventory.Ore:Clone()
	self.InventoryYBase = ResourceCategoryContainer.Size.Y.Offset
	local Contents = ResourceCategoryContainer.Contents
	local Line = Contents.Cassiterite.Line:Clone()
	local Resource = Contents.Cassiterite:Clone()
	self.InventoryYDelta = Resource.Size.Y.Offset
	--Contents:ClearAllChildren()
	self.ResourceCategoryContainer = ResourceCategoryContainer
	--self.Contents = Contents
	self.Line = Line
	self.Resource = Resource
	self.Resource.Line:Destroy()
	ResourceCategoryContainer.Contents:ClearAllChildren()	
	new.Sidebar.RealBar.Inventory:ClearAllChildren()
	self.Inventory = _G.Instinct:Create(ScrollBar)
	self.Inventory.Parent = new.Sidebar.RealBar.Inventory
	self.Inventory:Create()
	
	function self.Inventory:Add(GUI)
		return GUI -- HAX
	end
	
	self.Data = {}	
	
	self.Root = new
end

function SideBar:Destroy()
	self.Root:Destroy()
end


SideBar.DefaultCategory = "Miscallerous"
function SideBar:GetObjectCategory(Object)
	return (Object and Object.Material) or self.DefaultCategory
end

function SideBar:Work()
	local mouse = game.Players.LocalPlayer:GetMouse()
	self.Root.Sidebar.Visible=true
	delay(0, function()
		while wait() do 
			local xs = Dim.GetScreenSize().X
			local mx = mouse.X
			--print(xs, mx)
			if not self.ForceClosed then 
				if not self.IsOpen then 
					if xs - mx <= self.MinimalXOpen then
						self:Open()
					end
				elseif xs - mx >= self.MinimalXOpen + self.XSize then
					-- check if mouse is away; close
					self:Close()
				end
			end
		end
	end)
end

function SideBar:MakeVisible()
	self.Root.Sidebar.Visible = true
end

function SideBar:ForceClose()
	self.ForceClosed=true
	self:Close()
end

function SideBar:EnableOpen()
	self.ForceClosed=false
	
end

function SideBar:Open()
	self.IsOpen = true
	self.Root.Sidebar:TweenPosition(UDim2.new(1,-self.XSize,0,0), "Out", "Quad", self.OpenTime, true)
end

function SideBar:Close()
	self.IsOpen = false
	self.Root.Sidebar:TweenPosition(UDim2.new(1,0,0,0), "Out", "Quad", 0.125, true)
end



function SideBar:AddBackpackItem(resource)
	local obj = ObjectService:GetObject(resource.Name)
	local Category = self:GetObjectCategory(obj)
	if not self.Data[Category] then
		local RootGui = self.ResourceCategoryContainer:Clone()
		RootGui.Title.CategoryText.Text = Category
		self.Data[Category] = {GUI = RootGui}
		RootGui.Title.Collapse.MouseButton1Click:connect(function()
			-- TODO: change rectangle thing
			if RootGui.Contents.Visible then
				RootGui.Contents.Visible = false
				RootGui.Title.Collapse.Arrow.Rotation = 0
				self.Inventory:ChangeGUISize(RootGui, UDim2.new(1,0,0,self.InventoryYBase))
			else
				RootGui.Contents.Visible = true
				local NumItems = #(self.Data[Category])
				RootGui.Title.Collapse.Arrow.Rotation = 180
				self.Inventory:ChangeGUISize(RootGui, UDim2.new(1, 0,0, self.InventoryYBase + NumItems * self.InventoryYDelta))
			end
		end)
		if Category == self.DefaultCategory then
			self.Inventory:AddToEnd(RootGui)
		else
			self.Inventory:AddToStart(RootGui)
		end
	end
	local CatGUI = self.Data[Category].GUI
	local UseTable = self.Data[Category]
	local NumChildren = #(UseTable)
	local NewResource = self.Resource:Clone()
	NewResource.RealText.Text = resource.Name
	NewResource.Parent = CatGUI.Contents
	NewResource.Position = UDim2.new(0,0,0, NumChildren * self.InventoryYDelta)
	-- bind to events
	NewResource.MouseButton1Click:connect(function()
		self:RequestDrop(resource)
	end)
	NewResource.MouseButton2Click:connect(function()
		self:RequestCreateTool(resource)
	end)
	if NumChildren > 0 then
		local LastGui = UseTable[#UseTable]
		if LastGui then
			self.Line:Clone().Parent = LastGui
		end
	end
	-- Setup data to find it back
	table.insert(UseTable, NewResource)
	UseTable[resource] = NewResource
	-- figure out if changesize should be called to fix scrollbar st00f
	if CatGUI.Contents.Visible then
		self.Inventory:ChangeGUISize(CatGUI, UDim2.new(1, 0, 0, (NumChildren+1) * self.InventoryYDelta + self.InventoryYBase))
	end
end

function SideBar:RemoveBackpackItem(resource)
	local obj = ObjectService:GetObject(resource.Name)
	local Category = self:GetObjectCategory(obj)
	local Tab = self.Data[Category]
	local GUI = Tab[resource]
	local ID
	for i,v in ipairs(Tab) do 
		if v == GUI then
			ID = i
			break
		end
	end
	print(ID)
	-- first PUSHDOWN all remaing things
	for i = ID+1, #Tab do 
		print(i)
		Tab[i].Position = UDim2.new(0,0,0,(i-2) * self.InventoryYDelta)
	end
	if ID == #Tab then -- never remove line from first ID
		local LineGUI = Tab[ID-1]
		if LineGUI and LineGUI:FindFirstChild("Line") then
			LineGUI.Line:Destroy()
		end
	end
	Tab[resource] = nil
	table.remove(Tab, ID)
	GUI:Destroy()
	if #Tab == 0 then
		self.Inventory:Remove(Tab.GUI)
		self.Data[Category] = nil
	else
		if Tab.GUI.Contents.Visible then
			self.Inventory:ChangeGUISize(Tab.GUI, UDim2.new(1, 0, 0, (#Tab) * self.InventoryYDelta + self.InventoryYBase))
		end
	end
end

function SideBar:Show(WName)
	-- later. show craft/inventory
end

function SideBar:RequestDrop(resource)
	local comm = _G.Instinct.Communicator
	comm:Send("Drop", resource)
end

function SideBar:RequestCreateTool(resource)
	ToolService:RequestToolCreation("DefaultTool", {name={resource}})
end



return SideBar]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX88192b7c0e11467e9053499173957fd2">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ToolGui</string>
					<ProtectedString name="Source"><![CDATA[local ToolGui = {}

ToolGui.ToolWhitespace = 15; -- whitespace between tools
ToolGui.CategoryWhitespace = 50; -- whitespace between categories, left,right, etc.
ToolGui.UnequippedY = -70;
ToolGui.EquippedY = -130;
ToolGui.ExpandedDX = 30; -- how many pixels dem tool increases

ToolGui.CanUpdate = true

function ToolGui:Constructor()
	self.Root = game:GetService("ReplicatedStorage").ToolGui:Clone()
	self.Root.Parent = game.Players.LocalPlayer.PlayerGui
	local use = self.Root.ToolCardShadowed:Clone()
	self.Template = use
	self.XUnit = use.Size.X.Offset
	
	self.Root:ClearAllChildren()
	self.Tools = {
		Left = {},
		Right = {},
		NonPhysical = {},
	}
	self.GUIs = {} -- [tool] = gui
end

function ToolGui:UpdatePositions()
	if not self.CanUpdate then return end
	local TotalGUIs = #self.Tools.Left + #self.Tools.Right + #self.Tools.NonPhysical
	-- lets use a trick to make it simpler
	-- first build everything from 0, then actually place it offsetted to the middle.
	local cpos = 0 
	-- start with nonphysicla, then left, then right
	local newpos = {}	
	local gotother = false
	for index, tool in pairs(self.Tools.NonPhysical) do
		gotother = true
		local gui = self.GUIs[tool]
		if index  > 1 then
			cpos = cpos + self.ToolWhitespace
		end
		if gui then
			local y = self.UnequippedY
			local sizex = self.XUnit
			if tool.IsEquipped then
				y = self.EquippedY
				sizex = self.XUnit + self.ExpandedDX
			end
			newpos[gui] = {cpos, y, sizex}
			cpos = cpos + self.XUnit
		end
	end

	for i, tab in pairs {self.Tools.Left, self.Tools.Right} do
		for index, tool in pairs(tab) do
			
			if index == 1 and gotother then
				cpos = cpos + self.CategoryWhitespace
			else
				cpos = cpos + self.ToolWhitespace
			end
			gotother = true
			local gui = self.GUIs[tool]
			if gui then
				 local y = self.UnequippedY
				local sizex = self.XUnit
				if tool.IsEquipped then
					y = self.EquippedY
					sizex = self.XUnit + self.ExpandedDX
				end
				newpos[gui] = {cpos, y, sizex}
				cpos = cpos + self.XUnit
		
			end
		end
	end
	local sizeof = cpos -- LOL ok.
	local xmux = -sizeof/2
	
	for gui, data in pairs(newpos) do
		local xpos = data[1]
		local ypos = data[2]
		local sizex = data[3]
		if sizex > self.XUnit then -- is expanded
			xpos = xpos - self.ExpandedDX/2
		end
		gui:TweenSizeAndPosition(UDim2.new(0, sizex, 0, gui.Size.Y.Offset), UDim2.new(0.5, xpos + xmux, 1,ypos), "Out", "Quad", 1, true)
	end
end

function ToolGui:RemoveTool(toolobj)
	local ftab
	if toolobj.Type == "Normal" then
		if toolobj.Hand == "Left" then
			-- hakes
			ftab = self.Tools.Left
		elseif toolobj.Hand == "Right" then
			ftab = self.Tools.Right
		end
	elseif toolobj.Name == "NonPhysical" then
		ftab = self.Tools.NonPhysical
	end
	local fi 
	for i,v in pairs(ftab) do
		if v == toolobj then
			fi = i
			break
		end
	end
	local ToolService = _G.Instinct.Services.ToolService
	local function getkeystr(enum)
		return ToolService.HotkeyNames[enum]
	end

	table.remove(ftab, fi)
	table.sort(ftab, function(a,b) return getkeystr(a.Hotkey) < getkeystr(b.Hotkey) end)
	self.GUIs[toolobj]:Destroy()
	self.GUIs[toolobj] = nil
	self:UpdatePositions()
end

function ToolGui:AddTool(toolobj)
	-- Cannot direct include toolservice QQ	
	local ToolService = _G.Instinct.Services.ToolService
	local KeyService = _G.Instinct.Services.KeyService
	
	-- helper
	local function getkeystr(enum)
	
		return ToolService.HotkeyNames[enum]
	end
	
	local new = self.Template:Clone()
	new.Parent = self.Root
	if toolobj.Type == "NonPhysical" then
		new.ContentClipper.Drop:Destroy()
		new.ContentClipper.ChangeHand:Destroy()
		new.ContentClipper.ToolName.Text = toolobj.Name
		
	else
		new.ContentClipper.Drop.MouseButton1Click:connect(function()
			_G.Instinct.Communicator:Send("DropTool", toolobj.ToolRoot)
		end)
		new.ContentClipper.ToolName.Text = toolobj.Tool.Name -- handle name = toolname

		new.ContentClipper.ChangeHand.MouseButton1Click:connect(function()

			if toolobj.Type == "Normal" then
				local i
				for index, tool in pairs(self.Tools[toolobj.Hand]) do
					if tool == toolobj then
						i = index
						break
					end
				end
				table.remove(self.Tools[toolobj.Hand], i)
				-- force quit update
				self.CanUpdate = false
				ToolService:ChangeHand(toolobj)
				self.CanUpdate = true
				local ftab
				if toolobj.Hand == "Left" then
					ftab = self.Tools.Left
				else
					ftab = self.Tools.Right
				end
		
				table.insert(ftab, toolobj)
				table.sort(ftab, function(a,b) return getkeystr(a.Hotkey) < getkeystr(b.Hotkey) end)
				self:UpdatePositions()
			end
		end)
	end
	
	new.ContentClipper.Hotkey.Text = getkeystr(toolobj.Hotkey)
	new.ContentClipper.ToolName.MouseButton1Click:connect(function()
		ToolService:GeneralEquip(toolobj)
	end)
	warn("CONNECT KEYSERVICE")
	--[[KeyService.KeyDown:connect(function(key)
		print(key, toolobj.Hotkey)
		if key == toolobj.Hotkey then
			ToolService:GeneralEquip(toolobj)
		end
	end)--]]
	-- register tool in data
	local ftab
	if toolobj.Type == "Normal" then
		if toolobj.Hand == "Left" then
			-- hakes
			ftab = self.Tools.Left
		elseif toolobj.Hand == "Right" then
			ftab = self.Tools.Right
		end
	elseif toolobj.Type == "NonPhysical" then
		ftab = self.Tools.NonPhysical
	end
	table.insert(ftab, toolobj)
	table.sort(ftab, function(a,b) return getkeystr(a.Hotkey) < getkeystr(b.Hotkey) end)
	self.GUIs[toolobj] = new
	
	self:UpdatePositions()
end

return ToolGui]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX5742373ecb3742ffa9ca6e68a8596e58">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ToolTip</string>
					<ProtectedString name="Source"><![CDATA[-- omg a tooltip
-- how awesome is dat
-- very awesome
-- such wow

local ToolTip = {}

local DT, PAL, ObjectService

ToolTip.Colors = {
	info = PAL:Get("Shade1", "Shade1")
}

ToolTip.BackgroundColor = PAL:Get("Default", "Shade2")
ToolTip.InfoColor = PAL:Get("Default", "Shade1")
ToolTip.ErrorColor = PAL:Get("Complement", "Shade1")
ToolTip.SeperationColor = PAL:Get("Background", "Shade4")
ToolTip.TextColor = PAL:Get("Text", "White")
ToolTip.TextBoundsColor = PAL:Get("Text")
ToolTip.WhiteSpace = 10
ToolTip.YWhiteSpace = 6
ToolTip.SeperationSize = 2

ToolTip.Font = "Arial"
ToolTip.FontSize = "Size14"

ToolTip.TitleFontSize = "Size18"
ToolTip.TitleFont = "ArialBold"

function ToolTip:Constructor()
	DT = _G.Instinct.UI.DimTools
	PAL = _G.Instinct.Utilities.Palette
	ObjectService = _G.Instinct.Services.ObjectService
	self.Mouse = game.Players.LocalPlayer:GetMouse()
	local gui = Instance.new("ScreenGui", game.Players.LocalPlayer.PlayerGui)
	local fr = Instance.new("TextLabel", gui)
	fr.Visible = false 
	fr.BackgroundColor3 = self.BackgroundColor
	fr.TextColor3 = Color3.new(0,0,0)
	fr.Size = UDim2.new(0,10,0,20)
	self.Frame = fr
	fr.Font = self.TitleFont
	fr.FontSize = self.TitleFontSize
	fr.TextColor3 = self.TextColor
	fr.TextStrokeColor3 = self.TextBoundsColor
	fr.TextStrokeTransparency = 0
	fr.BorderSizePixel = 0
end

function ToolTip:Destroy()
	self.Frame.Parent:Destroy()
end

function ToolTip:Hide()
	self.Frame.Visible = false
end

-- SHOW A TOOLTIP!! AWESMEEE!
function ToolTip:Show(RBXInstance, WarnList, InfoCap, Raw, UseName) 
	-- ples
	local Mouse = self.Mouse
	local fr = self.Frame
	self.Frame.Visible=true
	self.Frame:ClearAllChildren()
	local o = ObjectService:GetObject(RBXInstance.Name)
--[[	if not o then 
		warn("Yeah I'm not gonna show a tooltip if it doesnt have an object, hiding")
		self:Hide()
		return
	end--]]
	
	fr.Text = UseName or RBXInstance.Name
	local x,y = DT.TextSize(fr.Text, fr.Font, fr.FontSize)
	fr.Size = UDim2.new(0,x+self.WhiteSpace,0,y + self.YWhiteSpace)
	local props = ObjectService:GetInfo(RBXInstance.Name, RBXInstance)
	local max_x = x + self.WhiteSpace
	local max_y = 0
	local wr = {}
	
	local function add(t,c)
			local new = fr:Clone()
			new:ClearAllChildren()
			new.Parent = fr
			new.BackgroundColor3 = c
			new.Font = self.Font
			new.FontSize = self.FontSize
			new.Text = t -- yeah we need some helper funcitons
			local sep = Instance.new("Frame", new)
			sep.BorderSizePixel = 0
			sep.BackgroundColor3 = self.SeperationColor
			sep.Size = UDim2.new(1,0,0,self.SeperationSize)
			sep.Position = UDim2.new(0,0,1,-self.SeperationSize)
			sep.ZIndex=2
			local x,y = DT.TextSize(t, fr.Font, fr.FontSize)
			local x = x + self.WhiteSpace
			max_x = (x > max_x and x) or max_x
			max_y = (y > max_y and y) or max_y
			table.insert(wr,new)
	end
		
	if not Raw then
	for i,v in pairs(props) do
	--	print(i,v)
		local propinfo = ObjectService:GetProperty(i)
	
		if propinfo and propinfo.Mode.ShowInfo then
			add(i .. " : " .. tostring(v), self.InfoColor)
		end
	end
	end
	-- push warnings here
	for i,v in pairs(WarnList or {}) do
		add(v, self.ErrorColor)
	end
	-- end push warn block
	
	if InfoCap then
		for i,v in pairs(InfoCap) do 
			if type(v) == "table" then -- k
				local iname = v[1]
				local txt = v[2]
				if iname and txt and self.Colors[iname] then
					add(txt,self.Colors[iname])
				end
			end
		end
	end

	fr.Size = UDim2.new(0, max_x, 0, y + self.YWhiteSpace)
	
	for i,v in pairs(wr) do
		v.Size = UDim2.new(0, max_x,0,max_y+self.YWhiteSpace)
		v.Position = UDim2.new(0.5, -v.Size.X.Offset/2, 1, (i-1) * (y+self.YWhiteSpace))
	end
	
	fr.Position = UDim2.new(0, Mouse.X - max_x, 0, Mouse.Y)
end

return ToolTip]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX7e15a270d1fb496ab8a7aecd6a415b7a">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Window</string>
					<ProtectedString name="Source"><![CDATA[local Window = {}

local Palette, Dim, WindowServer, SFX

Window.Canvas = nil
Window.Root = nil
Window.DestroyOnClose = false
Window.TitleFont = "ArialBold"
Window.TitleFontSize = "Size18"

local Player = game.Players.LocalPlayer

function Window:Constructor()
	Palette = _G.Instinct.Utilities.Palette
	Dim = _G.Instinct.UI.DimTools
	WindowServer = _G.Instinct.UI.WindowServer
	SFX = _G.Instinct.UI.SFX
end

function Window:Create(Size, Title)
	if Player.PlayerGui:FindFirstChild("Windows") == nil then 
		Instance.new("ScreenGui", Player.PlayerGui).Name = "Windows"
	end
	print(Title)
	self.TheTitle = Title
	local Root = Player.PlayerGui.Windows
	local new = Instance.new("Frame", Root)
	new.BackgroundColor3 = Palette:Get("Background", "Shade4") 
	new.BackgroundTransparency = 0.5
	new.Size = Size or UDim2.new(0.5,0,0.5,0)
	new.BorderSizePixel = 0
	Dim.Center(new)
	-- Create header
	local header = Instance.new("Frame", new)
	header.Position = UDim2.new(0,0,0,-20)
	header.Size = UDim2.new(1,0,0,20)
	header.BorderSizePixel = 0
	header.BackgroundColor3 = Palette:Get("Default", "Shade4")
	-- Create title
	local title = Instance.new("TextLabel", header)
	title.Position = UDim2.new(0.25, 0, 0, -6)
	title.Size = UDim2.new(0.5, 0, 0, 20)
	title.Text = Title or ""
	title.Font = "ArialBold"
	title.FontSize = "Size18"
	title.TextColor3 = Palette:Get("Text")
	title.BorderSizePixel = 0
	title.BackgroundColor3 = Palette:Get("Default", "Shade2")
	self.Title = title
	SFX.Shade(title, 3)
	-- Create buttons
	local close = Instance.new("TextButton", header)
	close.Size = UDim2.new(0,30, 0,12)
	close.Position = UDim2.new(1, -40, 0, 4)
	close.Text = "X"
	close.BorderSizePixel = 0
	close.TextColor3 = Palette:Get("Text", "Default")
	close.BackgroundColor3 = Palette:Get("Complement", "Default")
	close.MouseButton1Click:connect(function()
		WindowServer:Notify(new, "Close")
		self:Close()
	end)
	SFX.Shade(close, 2)
	self.Canvas = new
end

function Window:Close()
	self.Canvas.Visible = false
	self.State = "Closed"
	if self.Button then
		self.Button.BackgroundColor3 = Palette:Get("Complement")
	end
	if self.CloseCallback then
		self.CloseCallback()
	end
	if self.DestroyOnClose then
		self.Canvas:Destroy()
	end
	-- THSI API!? WTF
	-- oh wait
	local new = _G.Instinct.Windows[self.TheTitle]
	
	if _G.Instinct.Windows[self.TheTitle] then
		_G.Instinct.Windows[self.TheTitle]:Close(self)
	end
end

function Window:Open()
	self.Canvas.Visible = true
	self.State = "Open"
	if self.Button then
		self.Button.BackgroundColor3 = Palette:Get("Shade1")
	end
	if self.OpenCallback then 
		self.OpenCallback()
	end
	print(self.TheTitle)
	local new = _G.Instinct.Windows[self.TheTitle]
	
	if _G.Instinct.Windows[self.TheTitle] then
		_G.Instinct.Windows[self.TheTitle]:Open(self)
	end
end

function Window:SetButton(Button)
	self.Button = Button
end

function Window:Toggle()
	if self.State == "Open" then
		self:Close()
	else
		self:Open()
	end
end

function Window:SetTitle(title)
	self.Title.Text = title
end

return Window]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX95611417b85f4d82a86ebd1f348c9c79">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">WindowServer</string>
					<ProtectedString name="Source"><![CDATA[local WindowServer = {}

WindowServer.Windows = {}

function WindowServer.Notify(Window, StateChange)
	
end

function WindowServer.RequestOpen(WindowName, Button)
	local new
	if WindowServer.Windows[WindowName] then
		WindowServer.Windows[WindowName]:Toggle()

		
	else
		new = _G.Instinct.Create(_G.Instinct.Gui.Window)
		new:Create(nil, WindowName)
		if Button then
			new:SetButton(Button)
		end
		new:SetTitle(WindowName)
		new:Open()
		WindowServer.Windows[WindowName] = new

	end
	for i,v in pairs(WindowServer.Windows) do
		if i ~= WindowName then
			v:Close()
		end
	end
	return new
end

return WindowServer]]></ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="Folder" referent="RBXff89c879d56545569908c74ff9831cee">
			<Properties>
				<string name="Name">Player</string>
			</Properties>
			<Item class="Script" referent="RBXf775c52a50384ae3a949a9316d28c6f4">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">DataManager</string>
					<ProtectedString name="Source"><![CDATA[-- DataManager
-- Used to Create/Get/Write to Server data (and create this data) in an organized way

local DataManager = {}
DataManager.ContainerClassName = "Folder"

local Root = game:GetService("ReplicatedStorage")

-- Find containerName inside RootContainer
-- if not exist make it
function DataManager:GetSubContainer(RootContainer, ContainerName)
	if not RootContainer or not ContainerName then
		error("Missing argument @DataManager:GetSubContainer")
	end
	if not RootContainer:FindFirstChild(ContainerName) then
		Instance.new(self.ContainerClassName, RootContainer).Name = ContainerName
	end
	return RootContainer[ContainerName]
end

function DataManager:GetContainer(CName, Player)
	local Player = Player or game.Players.LocalPlayer
	if not Player or not CName then
		error("Missing argument @DataManager:GetContainer")
	end
	local Root = self:GetSubContainer(Root, "LocalPlayerData")
	local UserData = self:GetSubContainer(Root, tostring(Player.userId))
	return self:GetSubContainer(UserData, CName)
end

function DataManager:PlayerGetStat(StatName, Player)
	local Player = Player or game.Players.LocalPlayer
	if not StatName or not Player then
		error("Missing argument @DataManager:PlayerGetStat")
	end
end

return DataManager]]></ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="Folder" referent="RBX968a4139110e4e158961df4e4d3b22d8">
			<Properties>
				<string name="Name">Class</string>
			</Properties>
			<Item class="Script" referent="RBXaa7822386dc446f28eac786d7e5967a4">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Object</string>
					<ProtectedString name="Source"><![CDATA[-- Object is interface to data --

local Object = {}

Object.PropertyContainerClassName = "Configuration"
Object.PropertyContainerName = "Properties"
Object.NoGroupPrefix = "."
Object.GroupPrefix = ".Group."

function Object:Constructor()
	self.Groups = {}
end 

-- USES buildin extend class
-- All objects can only have one extension!!
-- Other "groups" should be added via :AddGroup
-- Properly document that in group database


function Object:CreateExtension(name)
	if self.Name ~= "Object" then 
		local new = _G.Instinct:Create(self)
		new.Extends = self 
		new.Name = name or "Object"
		return new 
	else 
		error("Change name first")
	end
end 

-- Object:SetProperty
-- Instance = Roblox instance
-- PropertyName = name of property. wow
-- PropertyValue - value of property (wow)
-- > if PropertyValue == nil -> REMOVES property!
-- Group: (optional) puts it inside a PropertyGroup
function Object:SetProperty(Instance, PropertyName, PropertyValue, Group)
	if not Instance then
		error("No Instance provided to Object:SetProperty")
	end 
	if not PropertyName then
		error("No PropertyName provided to Object:SetProperty")
	end 
	if not Instance:FindFirstChild(self.PropertyContainerName) then 
		Instance.new(self.PropertyContainerClassName, Instance).Name = self.PropertyContainerName
	end 
	local root = Instance[self.PropertyContainerClassName]
	if Group then 
		local nstr = self.GroupPrefix .. Group
		if not root:FindFirstChild(nstr) then 
			local GroupInstance = Instance.new(self.PropertyContainerClassName, root)
			GroupInstance.Name = nstr
		end 
		root = root[nstr]
	end
	local Name = ((Group == nil and self.NoGroupPrefix) or "") .. PropertyName 
	

	if _G.Instinct.Type == "Server" then 
		-- OK to write changes
		if PropertyValue == nil then 
			-- removing ..
			-- lol this solution...
			if root:FindFirstChild(Name) then
				root[Name]:Destroy() -- awh
				if #(root:GetChildren()) == 0 then 
					root:Destroy()
				end 
			end 
		else 
			if root:FindFirstChild(Name) then 
				root[Name].Value = PropertyValue
			else 
				local typeof = tostring(type(PropertyValue))
				local make
				if typeof == "number" then 
					make = "NumberValue"
				elseif typeof == "string" then 
					make = "StringValue"
				elseif typeof == "boolean" then 
					make = "BoolValue"
				elseif typeof == "userdata" then 
					error("No handle for userdata")
				else 
					error("No handle for unknown type: " .. typeof)
				end
				local nprop = Instance.new(make, root) 
				nprop.Name = Name 
				nprop.Value = PropertyValue
			end 
		end 
	elseif _G.Instinct.Type == "Local" then 
		error("Cannot write to resource: is local")
	end 
end

-- Gets a property from Objct
-- Group is optional
function Object:GetProperty(Instance, PropertyName, Group)
	if not Instance or not PropertyName then 
		error("Missing argument for GetProperty")
	end 
	if Instance:FindFirstChild(self.PropertyContainerName) then 
		local root = Instance[self.PropertyContainerName]
		if Group then 
			local nstr = self.GroupPrefix .. Group
			if root:FindFirstChild(nstr) then 
				if root[nstr]:FindFirstChild(PropertyName) then 
					return root[nstr][PropertyName].Value
				end 
			end 		
		else
			local nstr = self.NoGroupPrefix .. PropertyName 
			if root:FindFirstChild(nstr) then 
				return root[nstr].Value 
			end 
		end 
	end
	return nil;
end 

-- Object:SetContext removed
-- Object:RemoveContext removed
-- Object: GetContext removed


-- Remove a property by calling SetProperty with PropertyValue =nil
function Object:RemoveProperty(Instance, PropertyName, Group)
	self:SetProperty(Instance, PropertyName, nil, Group)
end 

-- Object v2 doesn't need context;
-- Cannot get higher level values.

-- New api for "groups"
-- use pairs to loop over groups; 
-- can also be manually set via resources (better)

function Object:AddGroup(GroupName)
	table.insert(self.Groups, GroupName)
end 

function Object:IsInGroup(GroupName)
	for i,v in pairs(self.Groups) do 
		if v == GroupName then 
			return true 
		end 
	end 
	return false 
end 


-- Digs inside all extended objects and returns a list of all properties
-- if automerge is present, unpack tables in the returned table
function Object:GetAnchestryProperties(PropName, AutoMerge) 
	local Out = {}
	if rawget(self, PropName) then 
		table.insert(Out, self.PropName)
	end 
	local target = self 
	while target.Extends do 
		target = target.Extends 
		if rawget(target, PropName) then 
			table.insert(Out, target.PropName)
		end 
	end 
	if AutoMerge then 
		-- handy for rule lists;
		-- only merges 'lists'
		local MergedOut = {}
		for i,v in pairs(Out) do 
			if type(v) == "table" then 
				for ind, val in ipairs(v) do 
					table.insert(MergedOut, val)
				end 
			else 
				table.insert(MergedOut, v)
			end 
		end 
		return MergedOut
	end 
	return Out 
end 

function Object:GetSaveDataList()
	return self:GetAnchestryProperties("SaveDataList", true)
end 

function Object:GetMoveDataList()
	return self:GetAnchestryProperties("MoveRuleList", true)
end 

function Object:IsA(ObjectName)
	if self.Name == ObjectName then 
		return true 
	end 
	local target = self 
	while target.Extends do 
		target = target.Extends 
		if target.Name == ObjectName then 
			return true 
		end 
	end 
	return false 
end 

return Object

]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX6028639ed17546719b5b4d27093f056f">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Property</string>
					<ProtectedString name="Source"><![CDATA[-- Property provides MetaData about properties;
-- For instance, show material in GUI, etc.

local Property = {}

-- amazing.
 
return Property]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBXf87625c3b25d4cb8962b42e21e8d504f">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Tool</string>
					<ProtectedString name="Source"><![CDATA[local Tool = {}

-- ! adding useful properties? add them to cpy list too. (in delegate function)

Tool.Grip = nil -- cf

Tool.IsEquipped = false
Tool.Hand = "Left"
Tool.Hotkey = 1
Tool.Type = "Normal"

function Tool:Constructor()
	local Event = _G.Instinct.Utilities.Event
	local Instinct = _G.Instinct
	self.Equipped = Instinct:Create(Event)
	self.Unequipped = Instinct:Create(Event)
	self.HotkeyChanged = Instinct:Create(Event)
	self.IsEquipped = false
--	self:CreateWelds()
end

function Tool:UpdateWeld(part1, part2, c1, c2)
	if part1:FindFirstChild("Weld") then
		part1.Weld:Destroy()
	end
	local Weld = Instance.new("Weld", part1)
	Weld.Name = "Weld"
	Weld.Part0 = part2
	Weld.Part1 = part1
	Weld.C0 = c2:toObjectSpace(c1)
end

function Tool:Transform(part)
	print('transform', part.Name)
	part.CanCollide = false
	part.Anchored = false
end

function Tool:CreateWelds(root, weld_to, grip, dontweldtoroot)
	local hand = hand
	local handle = root
--	handle.Parent = game.Workspace
	if not root then return end
	local mainpart = root


	for i,v in pairs(mainpart:GetChildren()) do
		if v:IsA("BasePart") and v ~= mainpart then
			self:UpdateWeld(v, mainpart, v.CFrame, mainpart.CFrame)
			if not dontweldtoroot then
				self:Transform(v)
			end
		end
	end
	if not dontweldtoroot and mainpart:IsA("BasePart") then
		self:Transform(mainpart)
	end
	local Weld
	if not dontweldtoroot then
		Weld = Instance.new("Weld", weld_to)
		Weld.Name = "Weld"
		Weld.Part1 = weld_to
		Weld.Part0 = mainpart
		Weld.C1 = grip or CFrame.new()
		Weld.C0 = CFrame.new()
	end
	return 
end

function Tool:GetGrip()
	return self.Grip
end

function Tool:Equip()
	if _G.Instinct.Communicator then
		
		_G.Instinct.Communicator:Send("EquipTool", self.Tool, self.Hand, self:GetGrip())
	end
	if self.OnEquip then
		self:OnEquip()
	end
	--self.Equipped:fire()
end

function Tool:Unequip()
	if _G.Instinct.Communicator then
		_G.Instinct.Communicator:Send("UnequipTool", self.Tool)
	end
	if self.OnUnequip then
		self:OnUnequip()
	end
end

function Tool:CacheAction()
	-- figure out if we can do action, should return a string indication what it is
end

function Tool:GetDelegate()
	-- ?? = create func?
	return setmetatable({}, {__index=self})
end

return Tool]]></ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="Folder" referent="RBX0380b7edf562445494f9b5db592a744d">
			<Properties>
				<string name="Name">UnstableUntested</string>
			</Properties>
			<Item class="Script" referent="RBX229d76a9e8934f179835b2bcf21b0ba2">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">FireService</string>
					<ProtectedString name="Source"><![CDATA[-- FireService

local ObjectService = require "Services/ObjectService"
local Object = require "Action/Object"

local FireService = {}

local function tick()
	if game then 
	else 
		tick=os.clock()
	end 
end 

function FireService:GetEnvironmentTemperature(root)
	return 20 
end 

function FireService:Light(inst, plust, spark)
	local o = ObjectService:GetObject(inst.Name)
	if o then 
		if o:HasConstant("Lighteable", true) then 
			local bt = o:GetConstant("BurnTemperature")
			if not bt then 
				print("no burn temp found")
				return 
			end 
			if spark and o:HasConstant("Sparkable", true) then 
				o:SetContext("Temperature", bt)
				o:SetContext("Lit", tick() )
			elseif plust then 
				local lt = o:GetConstant("LightTemperature")
				if lt then 
					local nt = o:GetContext(inst, "Temperature") or 20
					if nt then 
						
						if nt + plust > lt then 
							o:SetContext(inst, "Temperature", bt)
							o:SetContext(inst, "Lit", tick())
						else 
							o:SetContext(inst, "Temperature", nt  + plust)
						end 
					end 
				end 
			end 
		end 
	end 
end 

-- returns fuel with the highest temperature
function FireService:GetFuel(root)
	local max = 0
	local found 
	local fuels = {}
	for i,v in pairs(root:GetChildren()) do 
		if ObjectService:IsResource(v) then 
			local o = ObjectService:GetObject(v.Name)
			if o:GetConstant("IsFuel") and o:GetProperty(v, "Lit") then 
				local t = o:GetProperty(v, "Temperature")
				if t > max then 
					max=t 
					found = v 
				end 
			elseif o:GetConstant("IsFuel") then 
				table.insert(fuels,v)
			end 
		end 
	end 
	if found then 
		for i,v in pairs(fuels) do 
			if Object:SetProperty(v, )
		return vfound,max 
	end 
end 

-- root is a root entity, this contains the ingredients
-- this doesnt have to be a building
-- note: only suitable for buildings with range == 0 for ings.
function FireService:HandleRoot(root)
	local tmul = 1
	local dt = tick() - (Object:GetContext(root, "LastCheck") or (tick() - 1))
	local remt = dt 
	Object:SetContext(root, "LastCheck", tick())
	local bb = Object:GetContext(root, "BurnBoost")
	if bb then 
		remt = dt * bb
		if tmul < bb then 
			tmul = bb 
		end 
		local be = Object:GetContext(root, "BurnBoostTime")
		if be then 
			Object:SetContext(root, "BurnBoostTime", be-dt)
			if be-dt <= 0 then
				Object:RemoveContext(root, "BurnBoost")
				Object:RemoveContext(root, "BurnBoostTime")
			end 
		end 
	end 
	local envt = self:GetEnvironmentTemperature(root)
	local fuel 
	-- first get fuel

	local fuel, ft  = self:GetFuel(root)

	for i,v in pairs(root:GetChildren()) do 
		if ObjectService:IsResource(v) then 
			local t = Object:GetContext(v, "Temperature") or envt 

			if fuel then 
				-- very sipmle 
				if t < ft and not v == fuel then 
					t = t + 1 * dt 
				end 
			elseif t < envt then 
				t = t - 1 * dt 
			end 
		end 
	end 


end 

return FireService]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBXcc100e99be0e4e14b8a39747887f7c98">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Sidebar2</string>
					<ProtectedString name="Source"><![CDATA[local Sidebar = {}

-- Sidebar is a special GUI.
-- It creates a sidebar which opens on the right side of the screen.
-- It also features a menu button bar on top of the bar


local Palette = Instinct.Include "Utilities/Palette"
local SFX = Instinct.Include "Gui/SFX"
local Dim = Instinct.Include "Gui/DimTools"
local ButtonBar = Instinct.Include "Gui/ButtonBar"

-- If mouse is x pixels right of it; open;
Sidebar.OpenXMinimum = 75
Sidebar.XSize = 150
Sidebar.Background = Palette:Get("Default", "Shade2")
Sidebar.Border = Palette:Get("Default", "Shade4")
Sidebar.BorderSize = 3
Sidebar.ButtonBarReserve = 30


function Sidebar:Create(buttonlist)
	local player = game.Players.LocalPlayer
	local root = Instance.new("ScreenGui", player.PlayerGui)
	root.Name = "Sidebar"
	self.Screen = root
	local bar = Instance.new("Frame", root)
	bar.BackgroundColor3 = self.Background
	bar.BorderSizePixel = self.BorderSize
	bar.BorderColor3 = self.Border
	bar.Size = UDim2.new(0, self.XSize, 1,0)
	bar.Position = UDim2.new(1, 0, 0, 0)
	local swbar = Instance.new("Frame", bar)
	swbar.Size = UDim2.new(0, self.XSize, 0, self.BorderSize)
	swbar.Position = UDim2.new(0,0,0,self.ButtonBarReserve)
	swbar.BorderSizePixel = 0
	swbar.BackgroundColor3 = self.Border
	-- reserve regions for menu and content
	local menu = Instance.new("Frame", bar)
	menu.Size = UDim2.new(1,0,0, self.ButtonBarReserve)
	menu.BackgroundTransparency = 1
	self.Menu = menu

	local content = Instance.new("Frame", bar)
	content.Size = UDim2.new(1,0,1, -(self.ButtonBarReserve + self.BorderSize))
	content.Position = UDim2.new(0,0,0, self.ButtonBarReserve + self.BorderSize)
	content.BackgroundTransparency = 1
	
	self.Content = content	
	
	local bb = Instinct.Create(ButtonBar)
	
	bb:Init(self.Menu)
	for i,v in pairs(buttonlist) do
		bb:AddButton(v)		
	end	
	bb.Root.Position = bb.Root.Position + UDim2.new(0,0,0,10)
	
	self.Root = bar
end


-- opens the work task to detect the mouse, etc.
function Sidebar:Work(showhelp)
	local mouse = game.Players.LocalPlayer:GetMouse()
	delay(0, function()
		while wait() do 
		local xs = Dim.GetScreenSize().X
		local mx = mouse.X
	--print(xs, mx)
		if not self.IsOpen then 
			if xs - mx <= self.OpenXMinimum then
				self:Open()
				self.IsOpen = true
			end
		elseif xs - mx >= self.OpenXMinimum + self.XSize then
			-- check if mouse is away; close
			self:Close()
			self.IsOpen = false
		end
		end
	end)
	if showhelp then
		local TextLabel = Instance.new("TextLabel", self.Screen)
		TextLabel.BackgroundColor3 = Palette:Get("Default", "Shade2")
		TextLabel.Size = UDim2.new(0, 200, 0, 50)
		TextLabel.BorderSizePixel = 0
		TextLabel.Text = "Hover your mouse here to show the sidebar!"
		TextLabel.TextColor3 = Palette:Get("Text", "White")
		TextLabel.TextStrokeColor3 = Palette:Get("Text")
		TextLabel.TextStrokeTransparency = 0
		TextLabel.Font = "Arial"
		TextLabel.FontSize = "Size18"
		TextLabel.TextWrapped = true
		TextLabel.Position = UDim2.new(1, - 250, 0.5, -25)
		self.Help = TextLabel
	end
end

function Sidebar:Open()
	if self.Help then
		self.Help:Destroy()
	end
	self.IsOpen = true
	self.Root:TweenPosition(UDim2.new(1,-self.XSize,0,0), "Out", "Quad", 0.125, true)
end

function Sidebar:Close()
	self.IsOpen = false
	self.Root:TweenPosition(UDim2.new(1,0,0,0), "Out", "Quad", 0.125, true)
end



return Sidebar]]></ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="Folder" referent="RBX5d38a64c91f54839846ec2edf3eecb67">
			<Properties>
				<string name="Name">Locale</string>
			</Properties>
			<Item class="Script" referent="RBX34953ea7e9924ea7bb7f011bd629b87f">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Deutsch</string>
					<ProtectedString name="Source"><![CDATA[local Locale = {

	
	
}

return Locale
]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX4cbf2b3544cf4fb6bd3d891f934da26a">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">English</string>
					<ProtectedString name="Source"><![CDATA[local Locale = {
	MENU_BACKPACK = "Backpack",
	MENU_TRIBE = "Tribe",
	MENU_RECIPES = "Recipes",
	MENU_HELP = "Help",
	MENU_CONSOLE = "Console",
	MENU_ADMINISTRATION = "Administration",
	MENU_SERVER = "Server"
	
	
}

return Locale
]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBXe93fe53ec1d6444f86b3d91bc6cbfda6">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Espanol</string>
					<ProtectedString name="Source"><![CDATA[local Locale = {

	
	
}

return Locale
]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX201ecb37dba94347b0a2805ffb363c2f">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Francais</string>
					<ProtectedString name="Source"><![CDATA[local Locale = {

	
	
}

return Locale
]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX350fca3c9d204bb8a362f7b920816ac2">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Italiano</string>
					<ProtectedString name="Source"><![CDATA[local Locale = {

	
	
}

return Locale
]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX8ea7a2b4acb04385bb40b1dfddf3ef61">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Nederlands</string>
					<ProtectedString name="Source"><![CDATA[local Locale = {
	MENU_BACKPACK = "Rugzak",
	MENU_TRIBE = "Stam",
	MENU_RECIPES = "Recepten",
	MENU_HELP = "Hulp",
	MENU_CONSOLE = "Console",
	MENU_ADMINISTRATION = "Administratie",
	MENU_SERVER = "Server",
	
	
}

return Locale
]]></ProtectedString>
				</Properties>
			</Item>
		</Item>
	</Item>
</roblox>