<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Model" referent="RBX4bf6ce7690704b9aa760154214859e43">
		<Properties>
			<CoordinateFrame name="ModelInPrimary">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
				<R00>1</R00>
				<R01>0</R01>
				<R02>0</R02>
				<R10>0</R10>
				<R11>1</R11>
				<R12>0</R12>
				<R20>0</R20>
				<R21>0</R21>
				<R22>1</R22>
			</CoordinateFrame>
			<string name="Name">Include_old</string>
			<Ref name="PrimaryPart">null</Ref>
		</Properties>
		<Item class="Script" referent="RBX42c659bd29d74563b2a4b105be33cfdf">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Option</string>
				<ProtectedString name="Source"><![CDATA[--[[
	Option
	Purpose:
		Create Option functions
		Similiar to roblox enums
		The name "Option" is chosen in order to prevent confusion
		Roblox uses enums
		Instinct uses options
		QQ
--]]

-- DEFINE ALL OPTIONS HERE!

local Options = {}

local opt_meta = {}

function opt_meta:__tostring()
	return "Option."..self[1]..self[2]
end

function Options.New(option_type, option_list)
	Options[option_type] = {}
	for i,v in pairs(option_list) do
		Options[option_type][v] = {option_type, v}
		Options[option_type][i] = Options[option_type][v]
		setmetatable(Options[option_type][v], opt_meta) -- tostring
	end
end

-- 

Options.New("ConsolePriority", {"Low", "Normal", "High", "Extreme"})

return Options]]></ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX9235bb520d0b468798e10cbce8f9fc65">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Instinct</string>
				<ProtectedString name="Source"><![CDATA[--[[
	Instinct
		Loads the Framework
		
	Usage:
		require(Instinct).Load("Client" | "Server")
		This will setup the Instinct Framework environment
		in the Instinct namespace
--]]

-- Probe environment

return function()

local pre = _G.__InstinctPresets
local ltype
if pre then
	ltype = pre.LoadType
end

if not pre then
	error("[Instinct Master Error] Could not load Instinct, _G.__InstinctPresests is not defined.")
end

if not ltype then
	error("[Instinct Master Error] Could not find LoadType, Instinct cannot load.")
end

-- Define Instinct lib
if not _G.Instinct then 
	_G.Instinct = {} 
else 
	for i,v in pairs(_G.Instinct) do 
		_G.Instinct[i] = nil
	end
end 
local Instinct = _G.Instinct

Instinct.Global = [=[
Version
Option
Create
Services/Locale
Event
]=]

Instinct.Client = [=[
]=]

Instinct.Server = [=[
Utilities/ColorTools
Utilities/Palette
]=]



local root = game:GetService("ReplicatedStorage").Instinct

--[[ Instinct.Load
	@arg1: List (newline seperated module load list)
--]]
function Instinct.Load(List, only, server)
	for ModuleName in List:gmatch("[^\n]+") do 
		local newroot = root
		if server then
			newroot = game:GetService("ServerStorage").Instinct
		end
		local objpointer = Instinct -- pointer to the table 
		local previous = objpointer
		for NameMatch in ModuleName:gmatch("(%w+)/?") do
			local try = newroot:FindFirstChild(NameMatch)
			if try then
				newroot = try
				if try:IsA("Model") and not objpointer[try.Name] then 
					objpointer[try.Name] = {} 
					objpointer = objpointer[try.Name]
					previous = objpointer
				elseif try:IsA("Model") then
					objpointer = objpointer[try.Name]
					previous = objpointer
				end
			else 
				newroot = nil 
				break
			end	
		end
		if newroot and newroot:IsA("ModuleScript") and previous then 
			local Name = newroot.Name
			print("Info", "Load: "..Name, newroot:GetFullName())
			if not previous[Name] then
			local out = require(newroot)
			if type(out) == "table" and Instinct.Create and not out.__noreg then		
				Instinct.Create.Register(out)
				Instinct.Create.RegisterClassName(Name, out)
			end
			if type(out) == "table" then 
			out.IsAClass=Name
			end
			if not previous[Name] then
				previous[Name] = (Instinct.Create and Instinct.Create(out)) or out 
			end
			end
			if only then 
				return previous[Name]
			end
		else
			print("Error", "Load: Unable to load module: "..ModuleName..", module does not exist!")
		end
	end
end

-- where is new option: if it should be loaded from server
function Instinct.Include(name, where)
	return Instinct.Load(name, true)
end

function Instinct.Initialize(mode)
	
	if mode == "Server" then
		Instinct.Client = nil
		Instinct.Load(Instinct.Global)
		Instinct.Load(Instinct.Server)
	elseif mode == "Client" then
		Instinct.Server = nil
		Instinct.Load(Instinct.Global)
		Instinct.Load(Instinct.Client)
	end
end

--Instinct.Initialize(ltype)
return Instinct
end ]]></ProtectedString>
			</Properties>
		</Item>
		<Item class="Model" referent="RBX10093be6ae464e709f8d8989859501d0">
			<Properties>
				<CoordinateFrame name="ModelInPrimary">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<string name="Name">Services</string>
				<Ref name="PrimaryPart">null</Ref>
			</Properties>
			<Item class="Script" referent="RBX5aef0e5fb8c24c12851e796b64a94205">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Locale</string>
					<ProtectedString name="Source"><![CDATA[local Locale = {}

Locale.Default = "English"

Locale.Selected = "English"

Locale.AvailableLocales = {
	--"Francais",
	--"Deutsch",
	"English",
	--"Espanol",
	--"Italiano",	
	"Nederlands",
}

Locale.DefaultLocale = Instinct.Include("LocaleFiles/"..Locale.Default)
Locale.SelectedLocale = Locale.DefaultLocale

function Locale.Get(str)
	-- BOOM TRANSLATIONS <3
	return Locale.SelectedLocale[str] or Locale.DefaultLocale or (str..">MISSING!")
end

function Locale.Set(lang)
	local found = false
	for i,v in pairs(Locale.AvailableLocales) do
		if v == lang then
			local try = Instinct.Include("LocaleFiles/"..v)
			if try then
				Locale.SelectedLocale = try
				found = true
				break
			else
				print("[Instinct Core] Locale not found: "..tostring(v))
			end
		end
	end
	if not found then
		print("[Instinct Core] Locale not found: "..tostring(lang))
	end
end

return Locale]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBXba49832437144df48ecaccf902bd02aa">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">RecipeService</string>
					<ProtectedString name="Source"><![CDATA[-- RecipeService only checks if the recipe can be made
-- If so, and the world / user wants to execute this recipe
-- The context + resources list should be passed to an
-- additional service which constructs the new object

-- In theory it should be possible that this thing
-- Creates dynamic objects! (damn)

local printm=print
local throw=print
local throwt=print


local ObjectService = Instinct.Include "Services/ObjectService"
local Object = Instinct.Include "Action/Object"

local RecipeService = {}

RecipeService.Categories = {}

RecipeService.Rules = {}

function RecipeService:Constructor()
	self.Categories = {}
	self.Rules = {}
end

function RecipeService:AddCategory(name)
	self.Categories[name] = {}
end 

function RecipeService:AddRecipe(recipe, cat)
	if not cat then
		warn(cat .. " category not provided, not adding recipe")
		return	
	end
	if not self.Categories[cat] then 
		self:AddCategory(cat)
	end 
	table.insert(self.Categories[cat], recipe) 
end

function RecipeService:AddRecipeToCategory(recipe, category)
	if not self.Categories[category] then 
		self:AddCategory(category)
	end 
	table.insert(self.Categories[category], recipe)
end 

RecipeService.UsedHelpers = {
	Add = function(self, ing, what)
		if not self[ing] then 
			self[ing] = {} 
		end 
		if not self[ing][what.Name] then 
			self[ing][what.Name] =  {what, Object = ObjectService:GetObject(what.Name)}
		else 
			table.insert(self[ing][what.Name], what)
		end
	end, 
	Delete = function(self, ing, what)
		if self[ing] then 
			self[ing].Deleted = true -- notify that something is being deleted
			if self[ing][what.Name] then 
				self[ing][what.Name].Deleted = true
				for i,v in pairs(self[ing][what.Name]) do 
					if v == what then 
						table.remove(self[ing][what.Name], i)
						break 
					end 
				end 
			end 
		end
	end,


}

-- Converts a list of Instances to WorkList
-- A WorkList should not be created a lot
-- It should be created before a recipe check round
-- It mainly consists of a linker object between the 
-- instance and the instinct object

-- preprocess the IL

-- contents
-- ipairs: {resource, obj}
-- [name] = {{res, obj}, {res2, obj}} etc



function RecipeService:CreateWorkList(InstanceList) 
	-- assertion is that instancelist 
	-- consists of roblox instances
	local out = {Used={}}
	local namelist = {}
	for i,v in pairs(InstanceList) do 
		local obj = ObjectService:GetObject(v.Name)
		if not obj then 
			throw("object " .. v.Name .. "not available")
			return nil, 1
		end 
		table.insert(out, {v, obj})
		if not namelist[v.Name] then 
			namelist[v.Name] = {out[#out][1], Object = out[#out][2]}
		else 
			table.insert(namelist[v.Name], out[#out][1])
		end
	end 
	for i,v in pairs(namelist) do 
		out[i] = v 
	end 
	setmetatable(out.Used, {__index = self.UsedHelpers})
	return out, 0 
end 



-- Checks if a recipe can be created;
-- Recipe is the recipe we want to create
-- Context is the context (backpack, in furnace, env temp, etc.)
-- List is a list of Objects provided to create the recipe
-- The Used field of this List should be filled
-- By the Rule functions with every INSTANCE which is used
-- To create the recipe

-- This service is a very complex service;
-- This function is the heart of it.
-- What does it do?
--> Check if the context exists
--> If so, figure out if the context is okay for this recipe
--> If nonexistant, okay too
--> Checkout the first rule.
--> EVERY RULE should test every ingredient

--> Mode:
--> 1 -> Diagnostic (for helpers)
--> 2 -> debug (verbose output)

function RecipeService:CheckRecipe(Recipe, Context, List, Mode)
	-- Check if all rules are present
	-- The minimal recipe only checks for ingredients.
	-- First check if the Recipe has any Context rules
	-- LIST is auto-changed to a WL
	local CanCreate = true
	local rl, err = self:CreateWorkList(List)
	if err > 0 then 
		throw "Worklist creation error, aborting .. "
		return false, 4
	end 
	local List = rl
	List.Used.Warnings = {}
	List.Used.WarningMessages = {}
	 
	local skip = {}

	local function EvalRuleProcedure(RuleName, RuleData,  RuleSet, RuleType, List, WholeList, errmsg, errcode)
		local ok, skipd, err = self:EvaluateRule(RuleName, RuleData, RuleSet, RuleType, Context, List, Recipe, WholeList, Mode )
		local err = err or 0
		if not ok then
			if Mode and Mode == 2 then 
				printm("RecipeService", "info", "rule not okay: " .. RuleName)
			end 
			if err > 0 then 
				throw(errmsg)
			end  
			return false ,errcode 
		elseif type(err) == "table" then 
			for _, skiprule in pairs(err) do 
				skip[skiprule] = true 
			end 
		end
		return ok, skipd, err 
	end 

	if Recipe.Context then
		skip = {} 
		-- We must evaluate all Context rules
		for RuleName, RuleData in pairs(Recipe.Context) do
			if not skip[RuleName] then  
				local ok, err = EvalRuleProcedure(RuleName, RuleData, Recipe.Context, {"Context", "NotAResource"}, List, List, "recipe check error clist", 3)
				if not ok then 
					CanCreate = false
				end 
			end 
		end
	end
	local nokrules = List.Used.Warnings
	local gotnok = false 
	local function nok(ing, rule)
		gotnok =true
		if nokrules[ing] then 
			nokrules[ing][rule] = true 
		else 
			nokrules[ing] = {[rule] = true}
		end 
	end 
	if Recipe.Ingredients then 
		for IngredientName, IngredientRules in pairs(Recipe.Ingredients) do 
			skip = {} -- clear skip cache 
			if Mode == 2 then 
				printm("RecipeService", "info", "Checking rules for ".. IngredientName)
			end 
			local ok, err = EvalRuleProcedure("Amount", IngredientRules.Amount, IngredientRules,  {"Ingredient", IngredientName}, List, List, "recipe check error inglist", 2)
			if not ok and not Recipe.DelFunc then 
				CanCreate = false
			else 
				table.insert(nokrules, IngredientName)
			end 
			for RuleName, RuleData in pairs(IngredientRules) do 
				printm("RecipeService", "info", "Evaluating rule " .. RuleName )
				if RuleName ~= "Amount" then 
					if not skip[RuleName] then 
						local ok, err = EvalRuleProcedure(RuleName, RuleData, IngredientRules, {"Ingredient", IngredientName}, List.Used[IngredientName], List, "recipe check error inglist", 2)
						if not ok then 
							if Recipe.DelFunc then 
								nok(IngredientName, RuleName)
								Recipe.DelFunc(nokrules, List.Used)
							end
							CanCreate = false
						end
					end
				end 
			end
			-- still amount ok?
			local atotal = 0 
			local chk = nil 
			local chksame = IngredientRules.Same ~= nil 
			if IngredientRules.AmountType == "Volume" then 
				-- check for volume 
				chk = true 
			end 
			local rem 
			local cando 
			if chksame then 
				rem = {}
				cando = false 
			end 

			if List.Used[IngredientName] then 
				for i,v in pairs(List.Used[IngredientName]) do 
					-- add amount proc
					if chk then 
						for ind, val in pairs(v) do 
							atotal = atotal + ObjectService:GetVolume(v)
						end 
					else
						atotal = atotal + #v
					end
					-- chksame rulekit
					if chksame then 
						if atotal >= IngredientRules.Amount then 
							if chksame then 
								cando = true 
							end 
						else
							rem[i] = true 
						end 
						atotal = 0 
					end 

				end 
				if chksame then 
					for i,v in pairs(rem) do 
						List.Used[IngredientName][i] = nil 
					end 
				end 
				List.Used[IngredientName].AmountNeeded = IngredientRules.Amount
			end
			print(atotal)
		--	List.Used[IngredientName].AmountNeeded = IngredientRules.Amount
			if atotal < IngredientRules.Amount then 
				if Recipe.DelFunc then 
					nok(IngredientName, "AFAmountCheck")
					Recipe.DelFunc(nokrules, List.Used)
				end 
				CanCreate = false
			elseif chksame and not cando then 
				if Recipe.DelFunc then 
					nok(IngredientName, "AFAmountCheck")
					Recipe.DelFunc(nokrules, List.Used)
				end 
				CanCreate = false -- NOPE recipe same check fail
			end
		end
	else 
	--[[	throw("recipe has no ingredients !?")
	return false, 1--]]
	-- heh lol thats actually possible
	end 	
	if Recipe.DelFunc and gotnok then 
		Recipe.DelFunc(nokrules, List.Used)
	end  

	return List.Used, CanCreate
end 

-- passed: 
function RecipeService:AddRule(name, rulefunc)
	if not self.Rules[name] then 
		self.Rules[name] = rulefunc 
	else 
		throw(name .. " rule already exists")
	end 
end 

-- Evaluate a Rule
-- Please create a default EQ checker for general rules
-- A good helper function to use is Object:HasConstant
-- EX pass:
-- {Temperature = {"Larger", 900}}
--> pass:
-- "Temperature", {"Larger", 900},  AllRulesForIngredient, {"Ingredient", IngredientName}, data.context, data.rlist, data
-- Second arg returned is 1: error, or 0: ok
-- first arg is if rule is ok or not (table or boolean, explained below)

-- Watch out! IngredientName can be misleading!
-- "Food" could be an ingredient name!
-- It is JUST to make recipes easier to read!

-- NOTE: 
-- A table may be returned: this holds a list of further rules 
-- for that current scope to ignore.
-- this is handy for an option list
-- be aware that these option may cause a rulename does not exist error
-- !
function RecipeService:EvaluateRule(RuleName, RuleData, RuleSet, RuleType, Context, List, Recipe, WholeList, Mode)
	if not self.Rules[RuleName] then 
		throw(RuleName .. " a rulename does not exist")
		return false, 1
	end 
	
	local arglist = {
	RuleName = RuleName,
	RuleData = RuleData, 
	RuleSet = RuleSet, 
	RuleType = RuleType, 
	Context = Context, 
	List = List, 
	WholeList = WholeList, 
	Recipe = Recipe, 
	Mode = Mode 
}

	return self.Rules[RuleName](arglist)

end

return RecipeService ]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBXe71621a58c24441daa5411580ce9266b">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ObjectService</string>
					<ProtectedString name="Source"><![CDATA[-- Resource service is a very specific high level service
-- It basically is a class system for objects
-- Objects can be everything:
-- Resources, tools, houses, etc.
-- It extends roblox parts and models by providing extra info 
-- on game entities 

-- Used on both server and client as LUT

-- recipe user guide;
-- > figure out if recipe can be created, take Uselist
-- > pass uselist to CreationService
--  > figure out if multipel options; if so, 
-- 			provide user choices
--  > if not; make
-- > this service will convert UseList resources to an
-- > actual roblox instance
-- > this is then returned
-- > it is not parented, 
-- > as buildings will need a different placement than resources
local throw=warn
local Property = Instinct.Include "Action/Property"

print("DONE")

local ObjectService = {}

-- x meters per studs; used for all kinds of calculations
ObjectService.StudsLength = 0.2 
ObjectService.MaximumGatherVolume = 3^3; -- maximum volume to put something in backpack. 

ObjectService.ObjectData = {}
ObjectService.PropertyData = {}
ObjectService.PWarned = {}

warn("Need a property class")

function ObjectService:Constructor()
	self.ObjectData = {} -- global lut
	self.ObjectConstants = {} -- objconstants
	self.ObjectConstantsDescriptions = {} -- for later use for descriptions
	self.PropertyData = {} -- possible props
	self.PWarned = {}
	self.Rules = {}
	self.MoveRules = {}
end

function ObjectService:AddMoveRule(Rule, Name)
	self.MoveRules[Name] = Rule
end

function ObjectService:GetMoveRule(Name)
	if self.MoveRules[Name] then
		return self.MoveRules[Name]
	end
	warn(Name .. " a moverule doesnt exist, returning nil")
end

function ObjectService:AddProperty(Property) -- is a property class
	-- property class has integrated "no that is not a valid property" things.
	if self.PropertyData[Property.Name] then
		warn(Property.Name .. " already exists (a property)")
		return
	end

	self.PropertyData[Property.Name] = Property
end 

function ObjectService:GetProperty(Name)

	return self.PropertyData[Name]
end

-- possible static value values setter function
function ObjectService:AddPropertyValues(Name, Values)
	if not self.PropertyData[Name] then 
		throwt("ObjectService", Name .. "Object " .. Name .. " not available")
		return 
	end 
	local o = self.PropertyData[Name] 
	if o.PValues and o.PValuesLut then 
		for i,v in pairs(Values) do 
			if not o.PValues[v] then 
				table.insert(o.PValuesLut, v)
				o.PValues[v] = true 
			end
		end 
	else 
		o.PValuesLut = Values 
		o.PValues = {}
		for i,v in pairs(Values) do 
			o.PValues[v] = true 
		end 
	end 
end 

function ObjectService:AddObjects(list)
	for _, obj in pairs(list) do 
		self:AddObject(obj)
	end 
end

function ObjectService:GetObjectList()
	local out = {}
	for i,v in pairs(self.ObjectData) do
		table.insert(out, i)
	end 
	return out 
end

function ObjectService:CheckProperty(name)

end 

function ObjectService:AddObject(Object)
	-- if the resource has an extend field:
	--> check if extended resource is available
	--> not? throw error

	-- first _G.a = 3 o = getfenv() setfenv(1, setmetatable({o=o}, {__index = function(tab,ind) return tab.o[ind] or  _G[ind] end})) print(a) for non-props 

	local excl = {ExtendedBy = true, __root = true }

	for i,v in pairs(Object) do 
		if not excl[i] then 
			if not self.PropertyData[i] and not self.PWarned[i] then 
				warn("Property " .. i .. " does not exist")
				self.PWarned[i] = true 
			end 
		end 
	end 

	if Object.ExtendedBy then 
		if type(Object.ExtendedBy) == "string" then 
			if not self.ObjectData[Object.ExtendedBy] then 
				throw(Object.ExtendedBy .. " does not exist")
				return
			end 
		elseif type(Object.ExtendedBy) == "table" then 
			local ok = true 
			for i,v in pairs(Object.ExtendedBy) do 
				if not self.ObjectData[v] then 
					ok = false 
					throw(i .. " does not exist")
				end
			end
			if not ok then 
				return 
			end 
		end
	end 
	if self.ObjectData[Object.Name] then 
		throw (Object.Name .. " already exists")
	end 
	self.ObjectData[Object.Name] = Object 
end 

function ObjectService:GetInfo(ObjectName, Inst)
	local out = {}
	local o = self:GetObject(ObjectName)
	if not o then
		return {}
	end 
	-- yay 
	function r(o)
		for i,v in pairs(o) do 
			if not out[i] then 
				out[i] = v 
			end 
			if i == "ExtendedBy" and self:GetObject(v) then 
				r(self:GetObject(v))
			end 
		end 
	end 
	r(o)
	if Inst then
		local info = "objinfo"
		if Inst:FindFirstChild(info) then
			for i,v in pairs(Inst[info]:GetChildren()) do 
				if not out[i] then 
					out[i] = v.Value
				end
			end
		end
	end
	return out 
end 

-- gets volume from rbx instance 
function ObjectService:GetVolume(inst)
	--print("NO FUNCTION GETVOLUME DEFINED, SET THIS PLEASE, return 1 for test purposes")
	local o = self:GetObject(inst.Name)
	--warn(tostring( o and o:GetConstant("CustomVolume")[1]))
	if o and o:GetConstant("CustomVolume")[1] then
		local ret = o:GetConstant("CustomVolume")[1](o, inst)
		if ret then return ret end
	end
	if inst and inst:IsA("BasePart") then 
		return inst:GetMass()
	elseif inst and inst:IsA("Model") then
		local v = inst:GetModelSize()
		return v.x * v.y * v.z
	else
	--	warn("provided a non-part and non-model to objservice")
	end
	return nil
end 

function ObjectService:GetSize(inst)
	if inst and inst:IsA("BasePart") then 
		return inst.Size
	elseif inst and inst:IsA("Model") then
		local v = inst:GetModelSize()
		return v
	else
		warn("provided a non-part and non-model to objservice")
	end
	return nil
	
end


function ObjectService:IsResource(inst)
	if game then 
		return inst:IsA("BasePart") or inst:IsA("Model")
	else 
		if inst.islres then 
			return true 
		end 
	end 
end 

-- returns a resource from name
-- with handy functions yay
function ObjectService:GetObject(ObjectName)
	if type(ObjectName) ~= "string" then 
		throw("Provide a string for ObjectService")
		return
	end 
	return self.ObjectData[ObjectName]
end 

function ObjectService:ToBackpack(Resource, Backpack)
	--print("INTOBACKPACK", Resource:GetFullName())
	local obj = self:GetObject(Resource.Name)
	if not obj then return end
	for i,v in pairs(obj:GetMoveDataList()) do 
		local rule = self:GetMoveRule(v)
		if rule then
			rule(Resource)
		end
	end	
	
	if obj.CheckClean then 
		obj.CheckClean()
	end
	if Backpack then 
		Resource.Parent = Backpack
	end
end

-- gets a studvolume from GetMass and returns "real" volume
function ObjectService:ConvertStudVolume(studvolume)
	local Real = studvolume * self.StudsLength ^ 3
	-- is m^3
	return Real * 1000 -- is dm^3 - liters
end 

-- lelelelle
function ObjectService:GetSaveData(inst)
	local obj = self:GetObject(inst.Name)
	local out = {Name=inst.Name}
	if obj then
		if obj.SaveDataList then
			for _, rulename in pairs(obj:GetSaveDataList()) do
				if rulename ~= "Context" and self:GetRule(rulename) then
					out[rulename] = self:GetRule(rulename).To(inst)
				end
			end
			for i,v in pairs(inst:GetChildren()) do
				if v:IsA(obj.InfoClassName) then
					if not out.Context then
						out.Context = {}
					end
					out.Context[v.Name] = {}
					for ind, val in pairs(v:GetChildren()) do
						out.Context[v.Name][val.Name] = val.Value
					end
				end
			end			
			
		else
			warn("Cannot save " .. inst.Name .. " because no rules are available")
			return nil
		end
	else
		return nil
	end
	return out
end

function ObjectService:AddRule(Rule)
	if Rule.To and Rule.From and Rule.Name then
		self.Rules[Rule.Name] = Rule
	else
		error("provide a valid rule with fields To, From and Name")
	end
end

function ObjectService:GetRule(name)
	return self.Rules[name]
end

function ObjectService:WeldObject(Root)
	if Instinct.Action.Tool then
		Instinct.Action.Tool:CreateWelds(Root, nil, nil, true)
	end
end

-- There are two ways to get an Object's main part
-- The way it SHOULD be used (because it isn't ugly)
--> Create a model named "InstinctObject"
--> set primarypart
--> this function will return the primarypart
-- there must be NO bricks inside other bricks.
-- other, deprecated way:
-- chParent parts, which tell instinct to look at the parent for the mainpart


function ObjectService:GetMainPart(Inst)
	if Inst.Parent:IsA("Model") and Inst.Parent.PrimaryPart then
		return Inst.Parent.PrimaryPart
	else
		if Inst.Name == "chParent" then
			return Inst.Parent
		end
	end
	return Inst -- just return self as mainpart then.
end

function ObjectService:GetMainPartRoot(Inst)
	if Inst.Parent:IsA("Model") and Inst.Parent.PrimaryPart then
		return Inst.Parent
	else
		if Inst.Name == "chParent" then
			return Inst.Parent
		end
	end
	return Inst -- just return self as mainpart then.
end

function ObjectService:CopyStyle(StyleBrick, Target, PropList)
	function r(w)
		for i,v in pairs(w:GetChildren()) do
			if v:IsA("BasePart") then
				for ind, val in pairs(PropList) do
					print(val)
					v[val] = StyleBrick[val]
					v.Anchored=false
					v.CanCollide=true
				end
			end
		end
	end
	r(Target)
	for ind, val in pairs(PropList) do
		Target[val] = StyleBrick[val]
		Target.Anchored=false
		Target.CanCollide=true
	end
end

function ObjectService:CreateObjectFromSaveData(data)
	local ident = data.Name
	if not ident or not self:GetObject(data.Name) then
		warn('cannot identify saved data, returnning nil')
		return nil;
	end
	local baseobj = self:GetObjectRoot(ident)
	if not baseobj then
		warn('baseobj for ' .. ident .. ' is not available, cannot create')
		return nil;
	end
	local use = baseobj:Clone()
	local obj_data = self:GetObject(ident)
	for _, rulename in pairs(obj_data:GetSaveDataList()) do
		if rulename ~= "Name" and rulename ~= "Context" then -- skip 
			local rule = self:GetRule(rulename)
			warn('rule: ' .. rulename .. ' item: ' .. ident, data[rulename], data)

			if rule then
				rule.From(data[rulename],  use)
			end
		end
	end
	if data.Context then
		warn("has context")
		for ContextName, ContextData in pairs(data.Context) do
			print("cname", ContextName, ContextData)
			for PropName, PropValue in pairs(ContextData) do
				print("pname", PropName, PropValue)
				obj_data:SetContext(use, PropName, PropValue)
				local rule = self:GetRule("Context"..PropName)
				print(rule, "rule")
				if rule then
					rule.From(PropValue, use)
				end
			end
		end
	end
	return use
end
	
function ObjectService:GetObjectRoot(name)
	local root = game:GetService("ServerStorage")
	local locs = {root:FindFirstChild("Mining"), root:FindFirstChild("Ores"), root:FindFirstChild("Resources"), game:GetService("ReplicatedStorage").NewTools}
	for i,v in pairs(locs) do
		if v:FindFirstChild(name) then
			return v:FindFirstChild(name)
		end
	end
end

function ObjectService:DropItem(res, pos)
	if not res then return end
	res.Parent = game.Workspace.Resources 
	if res:IsA("Part") then
		-- check for parts inside
		res.CFrame = CFrame.new(pos)
	else -- qq
		
	end
end

function ObjectService:SetResourceCFrame(res, CF)
	if res:IsA("Model") then
		local function moveModel(model,targetCFrame)
			for i,v in pairs(model:GetChildren()) do
				if v:IsA("BasePart") then
					v.CFrame=targetCFrame:toWorldSpace(model:GetModelCFrame():toObjectSpace(v.CFrame))
				end
				moveModel(v, targetCFrame)
			end
		end

		moveModel(res, CF)
	else
		if res:FindFirstChild("chParent") then
			for i,v in pairs(res:GetChildren()) do
				if v:IsA("BasePart") and v.Name == "chParent" then
					local weld = v:FindFirstChild("Weld")
					if weld then
						local c0 = weld.C0
						v.CFrame = CF * c0
					end
				end
			end
			res.CFrame = CF
		else
			res.CFrame = CF
		end
	end
end

-- oldparent can be used to put leftovers in.
function ObjectService:ResizeResource(res, size, oldparent)
	if res:IsA("Model") then
		-- ... wat ... 
		warn("cannot resize models")
		return
	elseif res:FindFirstChild("chParent") then
		-- no.
		return
	end
	res.Size = size 
	warn("ADD HOOKS TO RESIZE THE ROOT!")
end

return ObjectService]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX4f1a915de9d140c284354229308d1439">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">KeyService</string>
					<ProtectedString name="Source"><![CDATA[local KeyService = {}

KeyService.Keys = {}

KeyService.DoubleClickTime = 0.25

-- enums plz

KeyService.State = "Default" -- block keys later (via keydown event)

local fix = {}
fix.__index = function(tab, index)
	rawset(tab, index, {true, tick()})
	return rawget(tab, index)
end

setmetatable(KeyService.Keys, fix) -- Fixes a "nil-call" when key was not down / up yet

function KeyService:Constructor()
	self.KeyDown = Instinct.Create "Event"
	self.DoubleClick = Instinct.Create "Event"
	self.KeyUp = Instinct.Create "Event"
end

function KeyService:GetKey(input)
	return (type(input) == "number" and input) or (type(input) == "string" and input:byte()) or 1
end

function KeyService:KeyIsUp(key)
	return self.Keys[self:GetKey(key)][1] and true 
end

function KeyService:KeyIsDown(key)
	return not self:KeyIsUp(key)
end

function KeyService:GetTime(key)
	return tick() - self.Keys[key][2]
end

function KeyService:KeyIsDownFor(key, time)
	return self:KeyIsDown(key) and self:GetTime(key) > time
end

function KeyService:KeyIsUpFor(key, time)
	return self:KeyIsUp(key) and self:GetTime(key) > time
end

function KeyService:Initiate() 
local uis = game:GetService("UserInputService")
uis.InputBegan:connect(function(obj)
	local _,kc = pcall(function() return obj.KeyCode end)
	if kc then
		self.Keys[kc] = {true, tick()}
		self.KeyDown:fire(kc, self.State)
	end
end)
uis.InputEnded:connect(function(obj)
	local _,kc = pcall(function() return obj.KeyCode end)
	if kc then
		self.Keys[kc] = {false,tick()}
		self.KeyUp:fire(kc, self.State)
	--	self.KeyUp:fire(kc, self.State)
	end
end)
local mouse = game.Players.LocalPlayer:GetMouse() 
--[[mouse.KeyUp:connect(function(key) 
	self.Keys[key:byte()] = {true, tick()}
end)
mouse.KeyDown:connect(function(key)
	self.Keys[key:byte()] = {false, tick()}
	OLDPRINT("Key down: "..key)
	self.KeyDown:fire(key, self.State)
end)--]]
local lastm1down = 0
local lastm2down = 0
mouse.Button1Down:connect(function()
	self.KeyDown:fire("m1", self.State)
	if os.time() - lastm1down < self.DoubleClickTime then
		self.DoubleClick:fire("m1", self.State)
	end
	lastm1down = os.time()
end)
mouse.Button2Down:connect(function()
	self.KeyDown:fire("m2", self.State)
	if os.time() - lastm2down < self.DoubleClickTime then 
		self.DoubleClick:fire("m2", self.State)
	end
	lastm2down = os.time()
end)
mouse.Button1Up:connect(function()
	self.KeyUp:fire("m1", self.State)

end)
mouse.Button2Up:connect(function()
	self.KeyUp:fire("m2", self.State)

end)
end

return KeyService

]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX77daf9c617c345dfaa6e4eaf830f8959">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ToolService</string>
					<ProtectedString name="Source"><![CDATA[-- manages tool equipping / unequipping, etc

local ToolService = {}

local DataManager = Instinct.Include "DataManager"
local KeyService = Instinct.Include "Services/KeyService"
local ObjectService = Instinct.Include "Services/ObjectService"
local Object = Instinct.Include "Action/Object"
local ToolGui

local IsLocal = (game.Players.LocalPlayer ~= nil)
if IsLocal then
	ToolGui = Instinct.Include "Gui/ToolGui"
end

ToolService.EquippedLeft = nil
ToolService.EquippedRight = nil
ToolService.EquippedNP = nil -- nonphysical equipped

ToolService.MaxTools = 10

ToolService.PossibleHotkeys = {
	
	Enum.KeyCode.One,
	Enum.KeyCode.Two,
	Enum.KeyCode.Three,
	Enum.KeyCode.Four,
	Enum.KeyCode.Five,
	Enum.KeyCode.Six,
	Enum.KeyCode.Seven,
	Enum.KeyCode.Eight,
	Enum.KeyCode.Nine,
	Enum.KeyCode.Zero,
	Enum.KeyCode.M,
	Enum.KeyCode.B,
	Enum.KeyCode.E, -- very hackihs.
}

ToolService.HotkeyNames = {
	 "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "M", "B", "E"
}

for i,v in ipairs(ToolService.HotkeyNames) do
	local enum = ToolService.PossibleHotkeys[i]
	print(i)
	ToolService.HotkeyNames[enum] = v
end

function ToolService:Constructor()
	self.Tools = {}
	self.RegisteredTools = {}
	-- self.DefaultTool is IMPORANT!!	
	setmetatable(self.RegisteredTools,{__index = function() return self.DefaultTool end})
end

function ToolService:RegisterTool(Name, Tool)
	if not Tool.Type then
		error("didnt register tool because no type.")
	elseif Tool.Type == "Normal" then
		if Tool.Create and Tool.DoAction then
			self.RegisteredTools[Name] = Tool
		else
			error("didnt register because tool doesnt have a create and action funciton")
		end
	elseif Tool.Type == "NonPhysical" then
		if Tool.DoAction then
			self.RegisteredTools[Name] = Tool
		else
			error("tool doenst have create func")
		end
	else
		error("tool doesnt have type")
	end
end


function ToolService:ChangeHand(tool)
	if tool.Type == "Normal" then
		local waseq = tool.IsEquipped
		print(waseq, 'chke', tool.Hand)
		if tool.Hand == "Left" then

			if self.EquippedRight then
			
				self:GeneralUnequip(self.EquippedRight)
			end
			tool.Hand = "Right"
		else

			if self.EquippedLeft then
				
				self:GeneralUnequip(self.EquippedLeft)
			end
			tool.Hand = "Left"
		end
		if waseq then
		
			self:GeneralUnequip(tool)
			self:GeneralEquip(tool)
		
		end
	end 
end

-- setups st00f
function ToolService:GeneralEquip(tool)
	
	if tool.IsEquipped then
		self:GeneralUnequip(tool)
		return
	end
	print("equipping a tool")
	if tool.Type == "Normal" then
		if tool.Hand == "Left" then
			if self.EquippedLeft then 
				self:GeneralUnequip(self.EquippedLeft)
			end			
			self.EquippedLeft = tool
			tool.Other = self.EquippedRight
			tool.OtherNP = self.EquippedNP
			if self.EquippedNP then
				self.EquippedNP.OtherLeft = tool
			end
			if self.EquippedRight then
				self.EquippedRight.Other = tool
			end
			tool:Equip()
		elseif tool.Hand == "Right" then
			if self.EquippedRight then
				self:GeneralUnequip(self.EquippedRight)
			end
			self.EquippedRight = tool
			tool.Other = self.EquippedLeft
			tool.OtherNP = self.EquippedNP
			if self.EquippedNP then
				self.EquippedNP.OtherRight = tool
			end
			if self.EquippedLeft then
				self.EquippedLeft.Other = tool
			end
			tool:Equip()
		end
	elseif tool.Type == "NonPhysical" then
		if self.EquippedNP then
			self:GeneralUnequip(self.EquippedNP)
		end
		self.EquippedNP = tool
		tool.OtherLeft = self.EquippedLeft
		tool.OtherRight = self.EquippedRight
		if self.EquippedLeft then
			self.EquippedLeft.OtherNP = tool
		end
		if self.EquippedRight then
			self.EquippedRight.OtherNP = tool
		end
		tool:Equip()
	end
	tool.IsEquipped = true
	ToolGui:UpdatePositions()	
end

function ToolService:GeneralUnequip(tool)
	print("unequipping a tool")
	tool.IsEquipped = false
	tool:Unequip()
	if tool.Type == "Normal" then
		if tool.Hand == "Left" then
			if self.EquippedRight then
				self.EquippedRight.Other = nil
			end
			self.EquippedLeft = nil
		elseif tool.Hand == "Right" then
			if self.EquippedLeft then
				self.EquippedLeft.Other = nil
			end
			self.EquippedRight = nil
		end
	elseif tool.Type == "NonPhysical" then
		if self.EquippedRight then
			self.EquippedRight.OtherNP = nil
		end
		if self.EquippedLeft then
			self.EquippedLeft.OtherNP = nil
		end
		self.EquippedNP = nil
	end
	ToolGui:UpdatePositions()
end

function ToolService:Enable()

	KeyService.KeyDown:connect(function(key, state)
		if key then 
			if key == "m1" or key == "m2" then
				if not self.EquippedNP then
					if key == "m1" and self.EquippedLeft then
						self.EquippedLeft:DoAction(key)
					elseif key == "m2" and self.EquippedRight then
						self.EquippedRight:DoAction(key)
					end
				else
					self.EquippedNP:DoAction(key)
				end
			else 
				for _, tool in pairs(self.Tools) do

						if tool.Hotkey == key then
							self:GeneralEquip(tool)
						end

				end
			end
		end
	end)
	
	KeyService.DoubleClick:connect(function(key, state)
		if key then 
			if key == "m1" or key == "m2" then
				if not self.EquippedNP then
					if key == "m1" and self.EquippedLeft and self.EquippedLeft.DoDBCAction then
						self.EquippedLeft:DoDBCAction(key)
					elseif key == "m2" and self.EquippedRight and self.EquippedRight.DoDBCAction then
						self.EquippedRight:DoDBCAction(key)
					end
				elseif self.EquippedNP.DoDBCAction then
					self.EquippedNP:DoDBCAction(key)
				end
			end
		end
	end)
	
	
	self.ToolRoot = DataManager:GetContainer(game.Players.LocalPlayer, "Tools")
	if not self.ToolRoot then
		repeat
			self.ToolRoot = DataManager:GetContainer(game.Players.LocalPlayer, "Tools")
			wait()
		until self.ToolRoot
	end
	self.ToolRoot.ChildAdded:connect(function(toolroot)
		print('added tool kewl', toolroot.Name)
		self:AddTool(toolroot)
	end)
	self.ToolRoot.ChildRemoved:connect(function(toolroot)
		print('removing tool nu', toolroot.Name)
		self:RemoveTool(toolroot)
	end)
	for i,v in pairs(self.ToolRoot:GetChildren()) do
		self:AddTool(v)
	end
end

function ToolService:AddTool(root)
	wait()
	print("ADDED TOOL")
	local tname = root.Name
 	local tool = self.RegisteredTools[tname]
	print(tool)
	if tool then
		local new = tool:GetDelegate()
		self:SetHotkey(new, self:GetNewHotkey(new))
		if new.Type ~= "NonPhysical" then
			new.Tool = root:FindFirstChild("Tool"):GetChildren()[1]
			new.ToolRoot = root
		end
		table.insert(self.Tools, new)
		-- add a hotkey
		--print('call getnewhotkey', new)
	--	self:GetNewHotkey(new)
		-- call gui update
		if new.Type ~= "NonPhysical" then
			self:GeneralEquip(new)
		end
		ToolGui:AddTool(new)
		
		print("DONE")
	end
end

function ToolService:RemoveTool(root)
	-- remove from self.Tools
	local tool
	for i,v in pairs(self.Tools) do
		if v.ToolRoot == root then
			tool = v
			table.remove(self.Tools, i)
			break
		end
	end
	function scanl(tab, which)
		if tab and tab[which] and tab[which] == tool then
			tab[which] = nil
		end
	end
	scanl(self, "EquippedLeft")
	scanl(self, "EquippedRight")
	scanl(self.EquippedLeft, "Other")
	scanl(self.EquippedRight, "Other")
	-- cannot drop nonphysical tools so, thats not a porblem
	ToolGui:RemoveTool(tool)
end

-- serversided!
function ToolService:DropTool(tool)
	
end

function ToolService:RequestToolCreation(Name, ObjectList, IsDefault)
	if Instinct.Communicator then
		Instinct.Communicator:Send("RequestToolCreation", Name, ObjectList, IsDefault)
	end
end

function ToolService:GetHotkey(tool)
	return tool.Hotkey
end

function ToolService:SetHotkey(tool, hotkey)
	print("SET HOTKEY", hotkey)
	if tool and hotkey then 
		tool.Hotkey = hotkey
		-- and a setcontext
	end
end

-- sets the first available hotkey to the tool
function ToolService:GetNewHotkey(tool)
	print("tool type: " .. tool.Type)
	if tool.Type == "NonPhysical" then
		
		if tool.Name == "Build" then
			return Enum.KeyCode.B
		elseif tool.Name == "Move" then
			return Enum.KeyCode.M 
		elseif tool.Name == "Eat" then
			return Enum.KeyCode.E 
		else 
			-- custom building tool.
		end
	end
	print("in gnh, ", tool)
	local cp = {}
	for i,v in pairs(self.PossibleHotkeys) do
		
		cp[v] = true
	end
	for i, tool in pairs(self.Tools) do

		cp[tool.Hotkey] = false
	end
	for i,v in pairs(self.PossibleHotkeys) do
		if cp[v] == true then
			return v
		end
	end
end

-- {objname = {objectlist}}
function ToolService:CreateNormalTool(Player, ToolName, ObjectList)
	
	-- lets first create a root container
	if not IsLocal then
		local troot = DataManager:GetContainer(Player, "Tools")
		warn(tostring(troot))
		if troot then
			if #(troot:GetChildren()) >= self.MaxTools then
				if Instinct.Chat then
					Instinct.Chat:Send("You cannot create the tool: " .. ToolName .. " because you already have " .. self.MaxTools .. " tools!", Player)
				end
				return
			end
			warn(tostring(self.RegisteredTools[ToolName]))
			if self.RegisteredTools[ToolName] then
				local new = Instance.new("Model")
				new.Name = ToolName
				local Items = Instance.new("Model", new)
				Items.Name = "Items" -- where tool is built from
				local ToolModel = Instance.new("Model", new)
				ToolModel.Name = "Tool" -- where tool is put in later hue?
				for objname, objects in pairs(ObjectList) do
					local mod = Instance.new("Model", Items)
					mod.Name = objname
					for i, object in pairs(objects) do
						object.Parent = mod
					end
				end
				self.RegisteredTools[ToolName]:Create(ToolModel, ObjectList)				
				
				new.Parent = troot -- call ChildAdded on client ^_^
			end
		end
	end
end

function ToolService:ToSaveData(ToolRoot)
	local out = {} -- q data
	out.Name = ToolRoot.Name
	-- gewd
	out.Items = {}
	local items = ToolRoot:FindFirstChild("Items")
	if items then
		for i, container in pairs(items:GetChildren()) do
			out.Items[container.Name] = {}
			for id, item in pairs(container:GetChildren()) do 
				table.insert(out.Items[container.Name], ObjectService:GetSaveData(item))
			end
		end
	end
	return out
end

function ToolService:FromSaveData(Data)
	local Name = Data.Name
	local root = {}
	for ItemName, ItemList in pairs(Data.Items) do
		root[ItemName] = {}
		print("ItemName: " .. ItemName)
		for i, itemd in pairs(ItemList) do
			local data = ObjectService:CreateObjectFromSaveData(itemd)
			print(data)
			table.insert(root[ItemName], data)
		end
	end
	print(Name, root, "from toolservice")
	return Name, root
end

function ToolService:SetCooldown(Hand, Time)
	-- set cooldown, also in GUI
end


return ToolService]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX8d45cbb9bfd24e46b70ade54cb2f2185">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">GameState</string>
					<ProtectedString name="Source"><![CDATA[local GameState = {}

function GameState:Set(x)
	self.State = x
end


return GameState]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX4ae4178aa659490d8e5b4b3bad1766ec">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">DiscoveryService</string>
					<ProtectedString name="Source"><![CDATA[local DiscoveryService = {}

function DiscoveryService:Constructor()
	self.Cache = {}
	self.LastChecks = {}
	self.LocalDiscoveries = {}
	self.DataStoreService = game:GetService("DataStoreService")
end

function DiscoveryService:GetStore(Name)
	return self.DataStoreService:GetDataStore(Name, "DiscoveryData")
end

function DiscoveryService:GetDiscoveries(Name)
	local store = self:GetStore(Name)
	if store then 
		local this
		if not self.LastChecks[Name] then
			self.LastChecks[Name] = os.time()
			self.LocalDiscoveries[Name] = {}
			this = store:GetAsync("Data") or {}
			self.Cache[Name] = this
			self:CreateFromData(Name, this)
		elseif (os.time() - self.LastChecks[Name]) >= 50 then
			-- sure
			self.LastChecks[Name] = os.time()
			this = store:GetAsync("Data") or {}
			for objname, discoverer in pairs(this) do
				if self.Cache[Name] and self.Cache[Name][objname] == nil then
					self:CreateFromData(Name, this)
					if Instinct.Chat then
						if not self.LocalDiscoveries[Name][objname] then
							print("discovery", discoverer, Name, objname)
							Instinct.Chat:SendGlobal(discoverer .. " discovered a " .. Name .. ": " .. objname)
						end
					end
				end
			end			
			self.Cache[Name] = this
		else
			this = self.Cache[Name]
		end
		return this
	end
end

function DiscoveryService:CreateFromData(Name, Data)
	local mod = game:GetService("ReplicatedStorage").Discoveries
	if mod:FindFirstChild(Name) == nil then
		Instance.new("Model", mod).Name = Name
	end
	for objname, discoverer in pairs(Data) do
		print("check", objname, discoverer)
		if mod[Name]:FindFirstChild(objname) == nil then 
			local this = Instance.new("StringValue")
			this.Name = objname
			this.Value = discoverer
			this.Parent = mod[Name]
		end
	end
end


-- name = recipe/tool/resource
-- who is player name
-- what is the objname
function DiscoveryService:SetDiscovery(Name, Player, What)
	local Who	
	if Player.userId <= 0 then
		return 
	elseif Player.Name == "jobro13" then
		return
	end
	Who = Player.Name
	if not Name or not Who or not What then
		return
	end
	if type(Name) ~= "string" or type(What) ~= "string" or type(Who) ~= "string" then
		return 
	end
	if self.Cache[Name] and self.Cache[Name][What] == nil then
		local store = self:GetStore(Name)
		if store then
			pcall(function()
			store:UpdateAsync("Data", function(oldValue)
				if oldValue == nil then
					return {What=Who}
				elseif oldValue and not oldValue[What] then
					oldValue[What] = Who
					if Instinct.Chat then
						print("discovery", Who, Name, What)
						if self.LocalDiscoveries[Name] then
							self.LocalDiscoveries[Name][What] = true
						end
						Instinct.Chat:SendGlobal(Who .. " discovered a " .. Name .. ": " .. What)
					end
					return oldValue
				end
			end)
			end)
		end
	end
end

return DiscoveryService]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBXea7f8c7385024049809d5629e681b035">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">IntentionService</string>
					<ProtectedString name="Source"><![CDATA[local IntentionService = {}

local ToolService = Instinct.Include "Services/ToolService"
local ObjectService = Instinct.Include "Services/ObjectService"
local DamageService = Instinct.Include "Services/DamageService"

function IntentionService:Constructor()
	self.Actions = {}
end

function IntentionService:AddAction(Action)
	if Action.Name and Action.Run then
		self.Actions[Action.Name]=Action
	end
end

function IntentionService:DoAction(AName, Arg, Hand)
--	print(AName, self.Actions[AName])
	if self.Actions[AName] then
		table.insert(Arg, Hand)
		self.Actions[AName]:Run(unpack(Arg))
	end
end

function IntentionService:IsTool(Inst)
	-- returns if Inst is a tool, very naive checking 
	return Inst:IsDescendantOf(game.Workspace.Tools)
end 



-- left/right action are strings of cached left/right actions for given inst

function IntentionService:CanGather(Inst, LeftAction, RightAction)
	local LeftTool = ToolService.EquippedLeft
	local RightTool = ToolService.EquippedRight
	local obj = ObjectService:GetObject(Inst.Name)
	local bool, rlist, oaction
	local oaction = oaction or {}
	local UseName
	if obj  and obj:GetConstant("CheckGather")[1] then
		local func = obj.CheckGather or obj:GetConstant("CheckGather")[1] 
		if type(func) == "boolean" then
			if func and ObjectService:GetVolume(Inst) > ObjectService.MaximumGatherVolume then
				bool, rlist = false, {"This resource is too large to gather. Move it with the move tool."}
			else 
				bool, rlist = func, {}
			end
		else
			-- Call the function. This will be called with
			-- one arg: Inst.
			-- The function should return:
			--> can gather (bool)
			--> if not can gather ->
			--> provide the ReasonList
			--> provide which action would be necessary.
			local CanGather, Reasons, ActionNeeded -- oaction not local pls.
			CanGather, Reasons, ActionNeeded, oaction = func(obj, Inst)
			oaction = oaction or {}
			if CanGather then
				if ObjectService:GetVolume(Inst) > ObjectService.MaximumGatherVolume then
					bool,rlist =  false, {"This resource is too large to gather. Move it with the move tool."}
				else
					bool, rlist = true, {}
				end
			end
			if type(ActionNeeded) == "table" then 
				local has_equipped=false
				for _, Action in pairs(ActionNeeded) do 
					if Action == LeftAction then 
						has_equipped = "left"
						break
					elseif Action == RightAction then 
						has_equipped = "right"
						break
					end
				end
				if has_equipped then 
					bool, rlist = false, Reasons 
				else
					bool, rlist = false, {"Use your "..has_equipped.."-handed tool to do the required action"}
				end
			elseif type(ActionNeeded) == "string" then
				if ActionNeeded == LeftAction then 
					bool, rlist = false, {"Use your left-handed tool to do the required action"}
				elseif ActionNeeded == RightAction then 
					bool, rlist = false, {"Use your right-handed tool to do the required action"}
				else 
					bool, rlist = false, Reasons 
				end
			elseif not CanGather then
				warn("got strange exception from INTSERV: "..(tostring(ActionNeeded)))
				if type(ActionNeeded) == "table" then
					for i,v in pairs(ActionNeeded) do
					--	print(tostring(i), tostring(v))
					end
				end
				bool, rlist = false, {"cannot gather; unknown reason;"}
			end
		end
	end
	
	-- here, check for actions lft/right hand and for cooldown, change
	-- info accordingly
	
	if not oaction.Left and not oaction.Right then
		local function hashumanoid(t)
			local c = t
			repeat
				c = c.Parent
			until (c and c:FindFirstChild("Humanoid")) or not c
			if c and c:FindFirstChild("Humanoid") then
				return true, c.Name
			end
		end
		-- start general procedure to check if we want anything else!
		local has, name = hashumanoid(Inst)
		if Inst:IsDescendantOf(game.Workspace.Corpses) then
			-- uhoh.
			rlist = {}
			local n = Inst 
			while n.Parent ~= game.Workspace.Corpses do
				n = n.Parent
			end
			-- we found root which is n.
			local cName = n.Name 
			bool = false 
			if n:FindFirstChild("Clothing") and Inst:IsDescendantOf(n.Clothing) then
				if n.Clothing:FindFirstChild("Backpack") then
					if Inst == n.Clothing.Backpack or Inst:IsDescendantOf(n.Clothing.Backpack) then
						-- it backpack!
						UseName = "Backpack of "..cName
						oaction = {Left = "Inspect Backpack"}
					end
				end
			end
			if not oaction.Left then
				UseName = "Corpse of " .. cName
				table.insert(rlist, "I wonder what happened...")
			end
		elseif has then
			UseName = name -- show player name on hover;
			local temp = oaction or {}
			local changed = false
			if LeftTool then
				local Info = DamageService:GetDamageInfo(LeftTool, Inst)
				if Info then
					temp.Left = "Attack"
					changed = true
				end
			end
			if RightTool then
				local Info = DamageService:GetDamageInfo(RightTool, Inst)
				if Info then
					temp.Right = "Attack"
					changed = true
				end
			end
			if changed then
				oaction = temp
			end
		end
		
	end
	
	if bool == nil then 
		bool= false
	end
	
	if rlist == nil then
		rlist = {}
	end
	
	if bool and Inst:IsDescendantOf(game.Workspace.Buildings) or Inst:IsDescendantOf(game.Workspace.Tools) or Inst:IsDescendantOf(game.Workspace.Garbage) then	
		bool=false
	end
	return bool, (rlist or {}), (oaction or {}), UseName
end

return IntentionService]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX9ca7e4911da94f0e9842e302faa931e5">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">NutritionService</string>
					<ProtectedString name="Source"><![CDATA[local NutritionService = {}

local ObjectService = Instinct.Include "Services/ObjectService"
local Communicator = Instinct.Include "Communicator"

-- target: rbxinstance

function NutritionService:IsEdible(target)
	local name = target.Name 
	local o = ObjectService:GetObject(name)
	if o then
		return not (not o.Edible), o.Edible
	end
end

function NutritionService:GetNutritionInfo(target)
	local is_edible, data = self:IsEdible(target)
	if is_edible then
		local vol = ObjectService:GetVolume(target)
		if vol then
			local cp = {}
			for i,v in pairs(data) do
				cp[i] = v * vol;
			end
			return cp
		end
	end
	return {}
end

function NutritionService:Eat(target, edb_data)
	--> Eat Hunger=num Thirt = nu
	print("Eat!!")
	
	Communicator:Send("Eat", target, edb_data)
end

return NutritionService]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX733441d71004441795f12436b53bac70">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ClothingService</string>
					<ProtectedString name="Source"><![CDATA[local ClothingService = {}

-- general interface to clothing. should be expanded later.
-- clothing are just resources. v1=current
-- v1: do not add to resources, as we need additional rules for gathering then. not something we want, rite?
-- v2: add to objects
-- v3: make unwear/wear
-- v4: add chcreator

function ClothingService:Constructor()
	self.Clothing = {}
end

function ClothingService:AddCloth(ClothData)
	-- what is necessary?
	local function check(prop)
		if ClothData[prop] == nil then
			error(prop .. " is notprovided with clothdata")
		end
	end
	check "Name"
	check "BodyPart"
	check "Grip" -- grip is derived from bodypart CF
	check "Root"
	self.Clothing[ClothData.Name] = ClothData
end

-- shamelessly copied from tools

function ClothingService:UpdateWeld(part1, part2, c1, c2)
	if part1:FindFirstChild("Weld") then
		part1.Weld:Destroy()
	end
	local Weld = Instance.new("Weld", part1)
	Weld.Name = "Weld"
	Weld.Part0 = part2
	Weld.Part1 = part1
	Weld.C0 = c2:toObjectSpace(c1)
end

function ClothingService:Transform(part)
	print('transform', part.Name)
	part.CanCollide = false
	part.Anchored = false
end

function ClothingService:CreateWelds(root, weld_to, grip, dontweldtoroot)
	local hand = hand
	local handle = root
--	handle.Parent = game.Workspace
	if not root then return end
	local mainpart = root


	for i,v in pairs(mainpart:GetChildren()) do
		if v:IsA("BasePart") and v ~= mainpart then
			self:UpdateWeld(v, mainpart, v.CFrame, mainpart.CFrame)
			if not dontweldtoroot then
				self:Transform(v)
			end
		end
	end
	if not dontweldtoroot and mainpart:IsA("BasePart") then
		self:Transform(mainpart)
	end
	local Weld
	if not dontweldtoroot then
		Weld = Instance.new("Weld", weld_to)
		Weld.Name = "Weld"
		Weld.Part1 = weld_to
		Weld.Part0 = mainpart
		Weld.C1 = grip or CFrame.new()
		Weld.C0 = CFrame.new()
	end
	return 
end

function ClothingService:GetCloth(name)
	return self.Clothing[name]
end


-- v1: no check for clothes which are being worn.
-- v2: check for clothes.. etc..
-- clothinst is a copy of the cloth; can be changed if necessary; only change style, sizes will be problematic
-- no hard checks for hta.t
function ClothingService:WearCloth(ClothName, ClothInst, Player)
	-- clothinst should be a clone.
	if self.Clothing[ClothName] == nil then
		-- clothing doesnt exist, baibai
		warn(ClothName.. " does not exist, cannot wear.")
		return
	end
	local ClothData = self.Clothing[ClothName]
	local char = Player.Character
	if char:FindFirstChild("Clothing") == nil then
		local mod = Instance.new("Model", char)
		mod.Name = "Clothing"
	end
	local this = char.Clothing 
	local BodyPart = ClothData.BodyPart
	if char:FindFirstChild(BodyPart) then
		local weldto = char[BodyPart]
		local root = ClothInst
		-- assuming the chParent structure;
		self:CreateWelds(root, weldto, ClothData.Grip, nil)
		root.Parent=this
	else 
		-- body part doesnt exist, cannot wear this cloth. baibai.
	end
end

function ClothingService:UnwearCloth(root)
	-- unwear cloth by destroying it or something. or dropping it. not supported as of v1
end

return ClothingService

]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBXe7bffd6b2b864f4ebb62f6f9af522060">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">SpawnService</string>
					<ProtectedString name="Source"><![CDATA[local SpawnService = {}
-- spawnservice handles chcreate

local ClothingService = Instinct.Include "Services/ClothingService"
local init_cloth = Instinct.Include "Clothing" -- load cloth.
local Communicator = Instinct.Include "Communicator"
init_cloth() --wow.

function SpawnService:ConvertPlayer(Player, Data)
	warn("IN CV")
		-- first undo player of all nonsense.
	local char = Player.Character
	local rem = {
		CharacterAppearance = true; Hat = true; BodyColors = true;
	}
	local function Recurse(r)
		for _,child in pairs(r:GetChildren()) do
			for class in pairs(rem) do
				if child:IsA(class) then
					child:Destroy()
				end
			end
			Recurse(child)
		end
	end
	Recurse(char)
	-- strapped of.

	local function SetSkinColor(color)	
		for _,part in pairs(char:GetChildren()) do
			if part:IsA("BasePart") then
				part.BrickColor = color
			end
		end
	end
	SetSkinColor(BrickColor.new "Pastel brown" )
	Communicator:Send(Player, "SetSkinColor", "Pastel brown")	
	
	local Backpack = ClothingService:GetCloth "Backpack"
	local RPants = ClothingService:GetCloth "RightPants"
	local LPants = ClothingService:GetCloth "LeftPants"
	local Shirt = ClothingService:GetCloth "Shirt"
	warn ( " --- " )
	print(Backpack, RPants, LPants, Shirt)
	
	for _, cloth in pairs {Backpack, RPants, LPants, Shirt} do
		local cl = cloth.Root:Clone()
		warn(cloth.Name)
		ClothingService:WearCloth(cloth.Name, cl, Player)
	end
end

function SpawnService:SpawnPlayer(Player)
	local SpawnLocations = {CFrame.new(103.624123, 16.1699066, -382.141144), CFrame.new(-216.283875, 16.1974716, -980.819397)}
	local loc = SpawnLocations[math.random(1, #SpawnLocations)]
	delay(0, function()
		for i = 1, 10 do 
			Player.Character.Torso.CFrame = loc
			wait()
		end
	end)
end



function SpawnService:CreateCorpse(Player)
	local Character = Player.Character 
	local clone = Instance.new("Model")
	clone.Name = Player.Name
	for i,v in pairs(Character:GetChildren()) do
		if v:IsA("BasePart") and v.Name ~= "HumanoidRootPart" then
			for ind, val in pairs(v:GetChildren()) do
				if val:IsA("JointInstance") then
					val:Destroy()
				end
			end
			local a = v:Clone()
			a.Parent = clone
			a.CanCollide = true
			a.Velocity = Vector3.new(0,0,0)
		end
	end
	local welds = {
		["Left Hip"] = {
			Part0 = "Torso",
			Part1 = "Left Leg"
		},
		["Left Shoulder"] = {
			Part0 = "Torso",
			Part1 = "Left Arm"
		},
		["Right Shoulder"] = {
			Part0 = "Torso",
			Part1 = "Right Arm"
		},
		["Right Hip"] = {
			Part0 = "Torso",
			Part1 = "Right Leg"
		},
		["Neck"] = {
			Part0 = "Torso",
			Part1 = "Head"
		}
	}	
	
	for i,v in pairs(welds) do
		local cpy = game:GetService("ServerStorage").WeldCache[i]
		local new = Instance.new("Rotate", clone.Torso)
		new.Part0 = clone[v.Part0]
		new.Part1 = clone[v.Part1]
		new.C0 = cpy.C0
		new.C1 = cpy.C1
	end
	-- hax start
	if Character:FindFirstChild("Clothing") then 
		for i,v in pairs(Character:FindFirstChild("Clothing"):GetChildren()	) do
			local cloth = ClothingService:GetCloth(v.Name)
			if cloth then
				ClothingService:WearCloth(cloth.Name, cloth.Root:Clone(), {Character = clone})
			end
		end
	end
	-- hax end
	Character:Destroy()
	wait(0.25)
	clone.Parent = game.Workspace.Corpses
	return clone
end

return SpawnService]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX4861b226ed3e4f7cb6b90b80ba486b71">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">DamageService</string>
					<ProtectedString name="Source"><![CDATA[local DamageService = {}

local ObjectService = Instinct.Include "Services/ObjectService"
local ToolService = Instinct.Include "Services/ToolService"
local Communicator = Instinct.Include "Communicator"

DamageService.CooldownScaler = 1;
DamageService.CriticalHitChance = 0.1

function DamageService:Constructor()
	self.Cooldowns = {}
end


DamageService.DamageTypes = {
	Cut = {
		BuildingDamage = 0.5;
		PlayerDamage = 1.5;
	},
	Crush = {
		BuildingDamage = 2;
		PlayerDamage = 1;
	},
	Hack = {
		BuildingDamage = 1.5;
		PlayerDamage = 1.25;
	}
}

DamageService.NoToolDamage = {
	Hardness = 2;
	DamageType = "Crush"
}

DamageService.DamageMultiplier = {
	Head = 2;
	Torso = 1.5;
	["Left leg"] = 1;
	["Right leg"] = 1;
	["Left arm"] = 1;
	["Right arm"] = 1;
	Backpack = 1.25;
}

function DamageService:Constructor()
	if game.Players.LocalPlayer then 	
		local Gui = Instance.new("ScreenGui", game.Players.LocalPlayer.PlayerGui)
		Gui.Name = "DamageGui"
		self.Gui=Gui
		self.Cooldowns = {}
	end
end

function DamageService:IsPlayer(Target)
	local c = Target
	repeat
		c = c.Parent
	until (c and c:FindFirstChild("Humanoid")) or (not c)
	if c and c:FindFirstChild("Humanoid") then
		return c
	end
end

function DamageService:GetDamageInfo(Tool, TargetInstance)
	if not TargetInstance then return end
	if os.time() - (self.Cooldowns[Tool.Hand] or 0) < 0 then
		return -- cooldown thing
	end
	local Mouse = game.Players.LocalPlayer:GetMouse()
	local Char = game.Players.LocalPlayer.Character
	if Char:FindFirstChild("Torso") and (Mouse.Hit.p - Char.Torso.Position).magnitude < 5 then
		local IsPlayer = self:IsPlayer(TargetInstance)
		if IsPlayer then
			local Name = TargetInstance.Name
			-- check for backpack
			local DamageMultiplier = self.DamageMultiplier[Name] or self.DamageMultiplier.Backpack
			
			local ToolName = Tool.Tool.Name 
			local Object = ObjectService:GetObject(ToolName)
			if Object then
				-- all tools get damage calculation
				if true then -- (Object:GetConstant("Hardness")[1] and Object:GetConstant("DamageType")[1] and Object:GetConstant("Density")[1]) or  Object:GetConstant("GetBaseDamage")[1] then
					local glob = {}					
					if Object:GetConstant("GetBaseDamage")[1] then
						glob = Object:GetConstant("GetBaseDamage")[1](Object,Tool) or {}
					end
					local Mass = glob.Mass or (ObjectService:GetVolume(Object) or 1) * (glob.Density or Object:GetConstant("Density")[1] or 1)
					local Cooldown = Mass * self.CooldownScaler
					local DamageTypeMultiplier = self.DamageTypes[glob.DamageType or Object:GetConstant("DamageType")[1] or ""]  or 1
					if type(DamageTypeMultiplier) ~= "number" then
						DamageTypeMultiplier = 1
					end
					local Multiplier = DamageTypeMultiplier * DamageMultiplier
				--	local Critical = false

										
					-- Ok so we calculated Cooldown and Multiplier
					-- Let's calculate energy loss due to this dmaage [later]
					
					
					-- Base damage: .GetBaseDamage
					local func =  Object:GetConstant("GetBaseDamage")[1]
					
					local BaseDamage = glob.BaseDamage or Object:GetConstant("BaseDamage")[1] or 1
				
					local Damage = math.sqrt(BaseDamage * Mass * (glob.Hardness or Object.Hardness or 1)) * Multiplier
					
					return {Damage = Damage,  Cooldown = Cooldown, TargetType = "Player", Target = IsPlayer}
				end
			end
		end
	end
end

function DamageService:Attack(Tool, TargetInstance)
	local Info = self:GetDamageInfo(Tool, TargetInstance)
	if Info then
		ToolService:SetCooldown(Tool.Hand, Info.Cooldowns)
		self.Cooldowns[Tool.Hand] = os.time() + (Info.Cooldown or 1)
		if math.random() <= self.CriticalHitChance then
			Info.Damage = Info.Damage * 2
			Info.IsCritical = true
		end
		if Info.TargetType == "Player" then
			Communicator:Send("DoPlayerDamage", Info.Target, Info.Damage, Info.IsCritical)
			print("DID DAMAGE: "..Info.Damage)
			-- > push to GUI
		end
	end
end

return DamageService]]></ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="Script" referent="RBX3b468a4c9ed54ec08493379983900748">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Create</string>
				<ProtectedString name="Source"><![CDATA[--[[
	Create
	Purpose: 
		Return utilites	
	
	
--]]

local Create = {}

Create.__index = function(tab, index, value)
	return tab
end

Create.__call = function(tab, ...)
	if tab.Call then
		return tab.Call(...)
	end
end

Create.__newindex = function(tab, index, value)
	if index == "Parent" and type(value) == "table" then
		if tab.Parent then
			local id = tab.__childid
			value.__children[id] = nil
		end
		if not value.__children then 
			value.__children = {}
		end
		table.insert(value.__children, tab)
		rawset(tab, "Parent", value)
		rawset(tab, "__childid", #value.__children - 1)
	else
		rawset(tab,index,value)
	end
end

Create.__index = function(tab, index, value)
	local root = rawget(tab, "__root")
	if root then 
		local ri = root[index]
		if ri then
			return ri
		end
		local ext = root.__extend
		if ext then 
			return ext[value] -- Recursive
		end
	end
end

Create.Classes = {}

function Create.RegisterClassName(ClassName, data)
	if not Create.Classes[ClassName] then
		Create.Classes[ClassName] = data
	else
		print("[Instinct Error] Conflicting ClassNames: "..ClassName .. " (ClassName already registered)")
	end
end

function Create.Class() -- returns an empty class handler
	local new = {}
	return setmetatable(new, RegisterMeta)
end

function Create.Call(object)
	local new = {}
	local obj
	if type(object) == "string" then
		local cdata = Create.Classes[object]
		if cdata then
			obj = cdata
		end
	elseif type(object) == "table" then
		obj = object
	end
	if not obj then
		print("[Instinct Error] Could not load object: "..tostring(object))
		return nil
	end
	new.__root = obj
	setmetatable(new, Create)
	if new.Constructor then 
		new:Constructor()
	end
	return new
end

-- Instinct.Create.Extend(Fruit, Banana)
function Create.Extend(with, class)
	class.__extend = with
end

local RegisterMeta = {}

function RegisterMeta.__index(tab, index)
	local ext = rawget(tab, "__extend") 
	if ext then 
		return ext[index]
	end
end

function Create.Register(class) -- Needed to assign the metatables
	return setmetatable(class, RegisterMeta)
end

setmetatable(Create,Create)


return Create]]></ProtectedString>
			</Properties>
		</Item>
		<Item class="Model" referent="RBXdb16745a197f4b97ac5a19d0a2e6a055">
			<Properties>
				<CoordinateFrame name="ModelInPrimary">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<string name="Name">Utilities</string>
				<Ref name="PrimaryPart">null</Ref>
			</Properties>
			<Item class="Script" referent="RBXe73273b672c74996afeeb87d69e72030">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Palette</string>
					<ProtectedString name="Source"><![CDATA[local Palette = {}



local ct = Instinct.Include("Utilities/ColorTools")

local rgb = ct.RGBToColor3


Palette.Data = {
	Default = {
		Default = rgb( 43,125, 43),
		Shade0 = rgb(180,255, 180),
		Shade1 = rgb(120,186,120),
		Shade2 = rgb( 73,151, 73),
		Shade3 = rgb( 20, 95, 20),
		Shade4 = rgb(  2, 63,  2),
	},
	Stats = {
		Hunger = rgb(186,186,120),
		Thirst = rgb(120,120,186),
		Health = rgb(120,186,120),
		Energy = rgb(186, 120,120)
	},
	Shade1 ={
		Default = rgb( 32, 94, 94),
		Shade1 = rgb( 90,140,140),
		Shade2 = rgb( 54,113,113),
		Shade3 = rgb( 15, 72, 72),
		Shade4 = rgb(  2, 47, 47),
	},
	Shade2 = {
		Default = rgb(114,146, 51),
		Shade1 = rgb(191,217,140),
		Shade2 = rgb(146,177, 85),
		Shade3 = rgb( 82,111, 23),
		Shade4 = rgb( 50, 73,  3),
	},
	Complement = {
		Default = rgb(156, 54, 54),
		Shade1 = rgb(233,150,150),
		Shade2 = rgb(189, 91, 91),
		Shade3 = rgb(119, 25, 25),
		Shade4 = rgb( 78,  3,  3),
	},
	Console = {
		Default = rgb(0,0,0),
		Text = rgb(255,255,255),
	},
	Text = {
		Default = rgb(0,0,0),
		White = rgb(255,255,255)
	},
	Background = {
		Default = rgb(0,0,0),
		Shade1 = rgb(20,20,20),
		Shade2 = rgb(40,40,40),
		Shade3 = rgb(60,60,60),
		Shade4 = rgb(80,80,80),
	},
	SFX = {
		Default = rgb(0,0,0), -- shade color
	},
	ColorLabel = { -- colorlabel tags!
		black = rgb(0,0,0),
		red = rgb(128,0,0),
		green = rgb(0,128,0),
		yellow = rgb(128,128,0),
		blue = rgb(0,0,128),
		purple = rgb(128,0,128),
		cyan = rgb(0,128,128),
		white = rgb(192,192,192)
		
		
	},
	ColorLabelLight = {
		black = rgb(128,128,128),
		red = rgb(255,0,0),
		green = rgb(0,255,0),
		yellow = rgb(255,255,0),
		blue = rgb(0,0,255),
		purple = rgb(255,0,255),
		cyan = rgb(0,255,255),
		white = rgb(255,255,255)		
		
	}
	
	
	--[[ 0 #000000  1 #800000  2 #008000  3 #808000  4 #000080  5 #800080  6 #008080  7 #c0c0c0
 8 #808080  9 #ff0000 10 #00ff00 11 #ffff00 12 #0000ff 13 #ff00ff 14 #00ffff 15 #ffffff--]]
}

function Palette:Get(Type, Which)
	local Type = Type or "Default"
	local Which = Which or "Default"
	if self.Data and self.Data[Type] then 
		return self.Data[Type][Which] or self.Data[Type].Default 
	else 
		return self.Data.Default[Which] or self.Data.Default.Default
	end
end

function Palette:GetRaw(Type, Which) -- can return nil! raw checks
	return self.Data[Type] and self.Data[Type][Which]
end

return Palette]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX06b30ce608ce40a6a2a0afb001a62e41">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ColorTools</string>
					<ProtectedString name="Source"><![CDATA[local ColorTools = {}

function ColorTools.RGBToColor3(r,g,b)
	return Color3.new(r/255,g/255,b/255)
end

return ColorTools]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBXd2df0b910d844ce88f53feab716ef011">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Date</string>
					<ProtectedString name="Source"><![CDATA[local Date = {}

Date.Constants = {
	millisecond = 0.001,
	second = 1,
	minute = second * 60,
	hour = minute * 60,
	day = hour * 24,
	week = day * 7,
	year = day * 365,
	lyear = day * 366,
	lsyear = day * 366 + second,
	syear = day * 365,
}

Date.Months = {
	{"Jan", 31}, {"Feb", 28},
	{"Mar", 31}, {"Apr", 30},
	{"May", 31}, {"Jun", 31},
	{"Jul", 31}, {"Aug", 30},
	{"Sep", 31}, {"Oct", 30},
	{"Nov", 31}, {"Dec", 30}	
}

Date.Start = 30 * Date.Constants.year + 7 * Date.Constants.day -- 2000 start

function Date.YearIsLeap(year) -- a full year
	return (year % 4) == 0
end

function Date.UnixToDate(time)
	local time = math.floor( ( time or os.time() ) + 0.5)
	-- 1 january 1970 00:00:00 -> 0
	local from2000 = time - Date.Start
	
	local yearsleft = from2000 % ( Date.Constants.year	)
	from2000 = from2000 - yearsleft * Date.Constants.year
	
	
end

return Date]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBXb1b3d7f1139643c9a8169069c297e20c">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Random</string>
					<ProtectedString name="Source"><![CDATA[local Random = {}

function Random:FromWeightsTable(tab)
	local tweight = 0
	for i,v in pairs(tab) do
		tweight = tweight + v
	end
	local portion = math.random() * tweight
	local start = 0
	for i,v in pairs(tab) do 
		start = start + v
		if start > portion then
			return i
		end
	end
end

return Random]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX868c011e344449828c6e489ca56612e5">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">CFrameTools</string>
					<ProtectedString name="Source"><![CDATA[local CFrameTools = {}

local acos=math.acos
local v3=Vector3.new
local components=CFrame.new().components
local inverse=CFrame.new().inverse
local fromAxisAngle=CFrame.fromAxisAngle

function CFrameTools:AxisAngleInterpolate(c0,c1,t)--CFrame0,CFrame1,Tween
	local _,_,_,xx,yx,zx,xy,yy,zy,xz,yz,zz=components(inverse(c0)*c1)
	local c=(xx+yy+zz-1)/2
	return c0*fromAxisAngle(v3(yz-zy,zx-xz,xy-yx),acos(c>1 and 1 or c<-1 and -1 or c)*t)+(c1.p-c0.p)*t
end


return CFrameTools]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBXa36dcbc0d8df4c3dab89e8893c801c70">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">BrickColorUtils</string>
					<ProtectedString name="Source"><![CDATA[local BrickColorUtils = {}

BrickColorUtils.Data = {

["Deep pink"] = {
1032,
1015,
1016,
},
Purple = {
104,
1026,
1006,
1031,
1023,
},
["Deep yellow"] = {
226,
24,
1008,
1017,
1009,
},
Green = {
37,
1020,
141,
1021,
151,
29,
28,
1028,
119,
1022,
},
["Light pink"] = {
1025,
9,
},
White = {
1029,
1001,
1,
1002,
194,
208,
},
Brown = {
105,
106,
217,
192,
18,
1014,
38,
133,
},
["Deep blue"] = {
1011,
1012,
107,
23,
1013,
1010,
},
["Light yellow"] = {
5,
125,
1030,
},
Black = {
199,
26,
1003,
},
["Light blue"] = {
1019,
102,
1018,
11,
135,
45,
1024,
1027,
},
Red = {
1007,
21,
101,
1004,
153,
},
}

return BrickColorUtils]]></ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="Script" referent="RBX363bce822fe8421fa1fb00e5e3540839">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Version</string>
				<ProtectedString name="Source">return &quot;0.0.1410&quot;</ProtectedString>
			</Properties>
		</Item>
		<Item class="Model" referent="RBXfc8675e3a62849c287dd8d71ec66ac6d">
			<Properties>
				<CoordinateFrame name="ModelInPrimary">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<string name="Name">Gui</string>
				<Ref name="PrimaryPart">null</Ref>
			</Properties>
			<Item class="Script" referent="RBX06c1828c419c4c588eacd39a16c113da">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ButtonBar</string>
					<ProtectedString name="Source"><![CDATA[local ButtonBar = {}

local Dim = Instinct.Include "Gui/DimTools"
local Presets = Instinct.Include "Gui/GuiPresets"

ButtonBar.Font = "ArialBold"
ButtonBar.FontSize = "Size12"
ButtonBar.WhiteSpace = 5
ButtonBar.Shade = 2
ButtonBar.TextWhiteSpace = 10 -- total whitespace


-- zomg u wanna msutfit? kthen
-- we will fit ur bar yes
-- we like that we like to fit the bar
-- pls


-- does not respect text size yes only y size
ButtonBar.MustFit = false
-- omg how much left; between buttons; etc
ButtonBar.FitGap = 10




function ButtonBar:Init(where, pos, size, parent)
	local frame = parent or Instance.new("Frame", where)
	frame.ClipsDescendants = true
	frame.BackgroundTransparency = 1
	local x_size, y_size = Dim.TextSize("test", self.Font, self.FontSize)
	frame.Size = size or UDim2.new(1,0, 0, y_size + self.Shade)
	frame.Position = pos or UDim2.new(0,0,0,0)
	self.Root = frame
end


function ButtonBar:AddButton(name)
	local button = Presets.Button(self.Shade)
	button.Parent = self.Root
	local max_x = -math.huge
	for i,v in pairs(self.Root:GetChildren()) do
		if v.Position.X.Offset + v.AbsoluteSize.X > max_x then
			max_x = v.Position.X.Offset + v.AbsoluteSize.X
		end
	end
	
	local new = max_x + self.WhiteSpace
	local size, ysize = Dim.TextSize(name, self.Font, self.FontSize)
	button.Size = UDim2.new(0, size + self.TextWhiteSpace, 0, ysize)
	button.Position = UDim2.new(0,new,0,0)
	button.Text = name 
	
	if self.MustFit then
		self:FixFit()
	end
	
	return button
end

return ButtonBar]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX88e16c549b51487e9fc41afcac47de0d">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">DimTools</string>
					<ProtectedString name="Source"><![CDATA[-- DimTools define functions for moving and reszing GUIs around
-- They dont respect the parent GUIs

local DimTools = {}

function DimTools.GetScreenSize()
	if not game.Players.LocalPlayer.PlayerGui:FindFirstChild("FontCHK") then 
		local new = Instance.new("ScreenGui", game.Players.LocalPlayer.PlayerGui)
		new.Name = "FontCHK"
		local x = Instance.new("TextButton", new)
		x.Visible = false
	end
	local gui = game.Players.LocalPlayer.PlayerGui:FindFirstChild("FontCHK")
	while not (gui.AbsoluteSize.X > 0 and gui.AbsoluteSize.Y > 0) do
		wait()
	end
	return gui.AbsoluteSize
end

function DimTools.Center(Gui)
	Gui.Position = UDim2.new(0.5 - (Gui.Size.X.Scale/2), -Gui.Size.X.Offset * 0.5, 0.5 - (Gui.Size.Y.Scale/2), -Gui.Size.Y.Offset * 0.5)
end

function DimTools.TextSize(text, font, fontsize)
	if not game.Players.LocalPlayer.PlayerGui:FindFirstChild("FontCHK") then 
		local new = Instance.new("ScreenGui", game.Players.LocalPlayer.PlayerGui)
		new.Name = "FontCHK"
		local x = Instance.new("TextButton", new)
		x.Visible = false
	end
	local my = game.Players.LocalPlayer.PlayerGui.FontCHK.TextButton

	my.FontSize = fontsize
	my.Text = text
	my.Font = font
	if my.TextBounds.X <= 0.99 or my.TextBounds.Y <= 0.99 then
		repeat wait(1/60) 
		until my.TextBounds.X >0.99 and my.TextBounds.Y >0.99
	end
	local x = my.TextBounds.X
	local y = my.TextBounds.Y
	return x, y
end

return DimTools]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX6bfc7eda06a247f7a22c0c0c8562ddf2">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">WindowServer</string>
					<ProtectedString name="Source"><![CDATA[local WindowServer = {}

WindowServer.Windows = {}

function WindowServer.Notify(Window, StateChange)
	
end

function WindowServer.RequestOpen(WindowName, Button)
	local new
	if WindowServer.Windows[WindowName] then
		WindowServer.Windows[WindowName]:Toggle()

		
	else
		new = _G.Instinct.Create(_G.Instinct.Gui.Window)
		new:Create(nil, WindowName)
		if Button then
			new:SetButton(Button)
		end
		new:SetTitle(WindowName)
		new:Open()
		WindowServer.Windows[WindowName] = new

	end
	for i,v in pairs(WindowServer.Windows) do
		if i ~= WindowName then
			v:Close()
		end
	end
	return new
end

return WindowServer]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX9ac437a5ca53455db8b7bc18e0d69964">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Window</string>
					<ProtectedString name="Source"><![CDATA[local Window = {}

local Palette = Instinct.Include("Utilities/Palette")
local Dim = Instinct.Include("Gui/DimTools")
warn(tostring(Instinct).. " < -------------------------------")
local WindowServer = Instinct.Include("Gui/WindowServer")
local SFX = Instinct.Include("Gui/SFX")

Window.Canvas = nil
Window.Root = nil
Window.DestroyOnClose = false
Window.TitleFont = "ArialBold"
Window.TitleFontSize = "Size18"

local Player = game.Players.LocalPlayer

function Window:Create(Size, Title)
	if Player.PlayerGui:FindFirstChild("Windows") == nil then 
		Instance.new("ScreenGui", Player.PlayerGui).Name = "Windows"
	end
	print(Title)
	self.TheTitle = Title
	local Root = Player.PlayerGui.Windows
	local new = Instance.new("Frame", Root)
	new.BackgroundColor3 = Palette:Get("Background", "Shade4") 
	new.BackgroundTransparency = 0.5
	new.Size = Size or UDim2.new(0.5,0,0.5,0)
	new.BorderSizePixel = 0
	Dim.Center(new)
	-- Create header
	local header = Instance.new("Frame", new)
	header.Position = UDim2.new(0,0,0,-20)
	header.Size = UDim2.new(1,0,0,20)
	header.BorderSizePixel = 0
	header.BackgroundColor3 = Palette:Get("Default", "Shade4")
	-- Create title
	local title = Instance.new("TextLabel", header)
	title.Position = UDim2.new(0.25, 0, 0, -6)
	title.Size = UDim2.new(0.5, 0, 0, 20)
	title.Text = Title or ""
	title.Font = "ArialBold"
	title.FontSize = "Size18"
	title.TextColor3 = Palette:Get("Text")
	title.BorderSizePixel = 0
	title.BackgroundColor3 = Palette:Get("Default", "Shade2")
	self.Title = title
	SFX.Shade(title, 3)
	-- Create buttons
	local close = Instance.new("TextButton", header)
	close.Size = UDim2.new(0,30, 0,12)
	close.Position = UDim2.new(1, -40, 0, 4)
	close.Text = "X"
	close.BorderSizePixel = 0
	close.TextColor3 = Palette:Get("Text", "Default")
	close.BackgroundColor3 = Palette:Get("Complement", "Default")
	close.MouseButton1Click:connect(function()
		WindowServer:Notify(new, "Close")
		self:Close()
	end)
	SFX.Shade(close, 2)
	self.Canvas = new
end

function Window:Close()
	self.Canvas.Visible = false
	self.State = "Closed"
	if self.Button then
		self.Button.BackgroundColor3 = Palette:Get("Complement")
	end
	if self.CloseCallback then
		self.CloseCallback()
	end
	if self.DestroyOnClose then
		self.Canvas:Destroy()
	end
	local new = Instinct.Include ("Windows/" .. self.TheTitle )
	
	if Instinct.Windows[self.TheTitle] then
		Instinct.Windows[self.TheTitle]:Close(self)
	end
end

function Window:Open()
	self.Canvas.Visible = true
	self.State = "Open"
	if self.Button then
		self.Button.BackgroundColor3 = Palette:Get("Shade1")
	end
	if self.OpenCallback then 
		self.OpenCallback()
	end
	print(self.TheTitle)
	local new = Instinct.Include ("Windows/" .. self.TheTitle )
	
	if Instinct.Windows[self.TheTitle] then
		Instinct.Windows[self.TheTitle]:Open(self)
	end
end

function Window:SetButton(Button)
	self.Button = Button
end

function Window:Toggle()
	if self.State == "Open" then
		self:Close()
	else
		self:Open()
	end
end

function Window:SetTitle(title)
	self.Title.Text = title
end

return Window]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBXe4a69328e1c246ec95bc7ba5c3e81025">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">SFX</string>
					<ProtectedString name="Source"><![CDATA[local SFX = {}

local Palette = Instinct.Include("Utilities/Palette")

function SFX.Shade(which, size)
	local size = size or 3
	local shadeunder = Instance.new("Frame", which)
	shadeunder.BorderSizePixel = 0
	shadeunder.BackgroundColor3 = Palette:Get("SFX", "Default")
	shadeunder.Name = "Shade"
	local shaderight = shadeunder:Clone()
	shaderight.Parent = which
	shaderight.Size = UDim2.new(0,size,1,0)
	shadeunder.Size = UDim2.new(1,0,0,size)
	shaderight.Position = UDim2.new(1,0,0,size)
	shadeunder.Position = UDim2.new(0,size,1,0)
	
end

function SFX.RemoveShade(which)
	for i,v in pairs(which:GetChildren()) do
		if v:IsA("Frame") and v.Name == "Shade" then
			v:Destroy()
		end
	end
end

function SFX.MakeBorder(which, left, right, up, down, color, bordersize)
	function get()
		local new = Instance.new("Frame", which)
		new.BackgroundColor3 = color
		new.BorderSizePixel = 0
		new.Name = "Border"
		return new
	end
	-- left
	if left then 
	local x = get()
	local yoffset = -((up and bordersize) or 0)
	x.Position = UDim2.new(0, -bordersize, 0, yoffset)
	x.Size = UDim2.new(0, bordersize, 1, -yoffset + ((down and bordersize) or 0))
	end
	-- right
	if right then
	local x = get()
	local yoffset = -((up and bordersize) or 0)
	x.Position = UDim2.new(1,0,0, yoffset)
	x.Size = UDim2.new(0, bordersize, 1, -yoffset + ((down and bordersize) or 0))
	end
	-- down
	if down then 
	local y = get()
	local xoffset = -((left and bordersize) or 0)
	y.Position = UDim2.new(0,xoffset,1, 0)
	y.Size = UDim2.new(1, xoffset + ((right and bordersize) or 0), 0, bordersize)
	end
	-- up
	if up then 
	local y = get()
	local xoffset = -((left and bordersize) or 0)
	y.Position = UDim2.new(0,xoffset,0, -bordersize)
	y.Size = UDim2.new(0, xoffset + ((right and bordersize) or 0), 0, bordersize)
	end	
end

return SFX]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBXf2edb114ed3542b2a1f2add7dd910518">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">DropDown</string>
					<ProtectedString name="Source"><![CDATA[local DropDown = {}

DropDown.XOffset = 10
DropDown.YOffset = 5
DropDown.TextOffset = 5
DropDown.Shade = 2

local SFX = Instinct.Include("Gui/SFX")
local Presets = Instinct.Include("Gui/GuiPresets")
local Dim = Instinct.Include("Gui/DimTools")

function DropDown:Create(Parent, Position, BackgroundC3, BorderC3, BorderSize)
	local new = Presets.Canvas(BackgroundC3)
	new.Position = Position or UDim2.new(0,0,0,0)
	new.Parent = Parent
	if type(BorderSize) == "table" then
		local need = { "left", "right", "down", "up", "bordersize"}
		local wrong = false
		for i,v in pairs(need) do 
			if BorderSize[v] == nil then 
				wrong = true
				break
			end
		end
		if not wrong then
			SFX.MakeBorder(new, BorderSize.left, BorderSize.right, BorderSize.up, BorderSize.down, BorderC3, BorderSize.bordersize)
		end
	else
		new.BorderSizePixel = BorderSize or 0
		new.BorderColor3 = BorderC3 or Palette:Get()
	end
		
	self.Root = new
end

function DropDown:AddButton(text)
	local new = Presets.Button(self.Shade)
	local numbuttons = 0
	for i,v in pairs(self.Root:GetChildren()) do
		if v.Name ~= "Border" then
			numbuttons = numbuttons + 1
		end
	end
	local ypos = (self.YOffset + self.Shade + new.Size.Y.Offset) * numbuttons + self.YOffset
	new.Text = text
	new.FontSize = "Size12"
	local xt, yt = Dim.TextSize(text, "ArialBold", "Size12")
	new.Size = UDim2.new(0, xt + self.TextOffset * 2, 0, new.Size.Y.Offset)
	new.Position = UDim2.new(0, self.XOffset, 0, ypos)
	new.Parent = self.Root
	local max_x = 0
	for i,v in pairs(self.Root:GetChildren()) do
		if v.Name ~= "Border" then 
			local new_x = self.XOffset * 2 + v.Size.X.Offset
			if new_x > max_x then
				max_x = new_x
			end
		end
	end
	for i,v in pairs(self.Root:GetChildren()) do
		if v.Name ~= "Border" then 
			v.Size = UDim2.new(0, max_x - self.XOffset * 2, 0, new.Size.Y.Offset)
		end
	end
	local ysize = ypos + new.Size.Y.Offset + self.Shade + self.YOffset
	self.Root.Size = UDim2.new(0,max_x, 0, ysize)
	
	return new
	
end


function DropDown:Destroy()
	self.Root:Destroy()
end

return DropDown]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX2fcbca66bf32431fb5e9c41eba2eff07">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">GuiPresets</string>
					<ProtectedString name="Source"><![CDATA[local GuiPresets = {}

local Palette = Instinct.Include("Utilities/Palette")
local SFX = Instinct.Include("Gui/SFX")
local Dim = Instinct.Include "Gui/DimTools"

function GuiPresets.Button(shade)
	local DropDown = Instance.new("TextButton")
	DropDown.BackgroundColor3 = Palette:Get("Complement")
	DropDown.TextColor3 = Palette:Get("Text")
	DropDown.Font = "ArialBold"
	DropDown.Text = ""
	DropDown.BorderSizePixel = 0
	DropDown.Size = UDim2.new(0,10,0,20)
	DropDown.FontSize = "Size12"
	if shade then 
		SFX.Shade(DropDown,shade)
	end
	return DropDown
end

-- for easy creationz
-- returns button, xsize, ysize
-- omg it so awesome
function GuiPresets.CustomButton(ButtonText, ButtonShade, ButtonFont, ButtonFontSize, TextColor, BackgroundColor, WhiteSpace)
	local ButtonText = ButtonText or ""
	local ButtonShade = ButtonShade or 0
	local ButtonFont = ButtonFont or "ArialBold"
	local ButtonFontSize = ButtonFontSize or "Size12"
	local TextColor = TextColor or Palette:Get("Text")
	local BackgroundColor = BackgroundColor or Palette:Get("Complement")
	local WhiteSpace = WhiteSpace or 10	
	local new = Instance.new("TextButton")
	new.Text = ButtonText
	new.Font = ButtonFont
	new.FontSize = ButtonFontSize
	new.TextColor3 = TextColor
	new.BackgroundColor3 = BackgroundColor
	new.BorderSizePixel = 0
	if ButtonShade > 0 then
		SFX.Shade(new, ButtonShade)
	end
	local size_x , size_y = Dim.TextSize(ButtonText, ButtonFont, ButtonFontSize)
	local rs = size_x + WhiteSpace
	new.Size = UDim2.new(0, rs, 0, size_y)
	return new, rs, size_y 
	
end

function GuiPresets.Canvas(color)
	local canvas = Instance.new("Frame")
	canvas.BackgroundColor3 = color or Palette:Get()
	canvas.BorderSizePixel = 0
	return canvas
end

function GuiPresets.Backdrop(bsize)
	local bar = Instance.new("Frame")
	bar.Size=UDim2.new(0,0,0,0)
	bar.BorderSizePixel = bsize
	bar.BorderColor3 = Palette:Get("Default", "Shade4")
	bar.BackgroundColor3 = Palette:Get("Default", "Shade1")	
	return bar
end


return GuiPresets]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX79a78ed5c9814183aea14fdfbd590643">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">SelectionMenu</string>
					<ProtectedString name="Source"><![CDATA[local Window = Instinct.Include("Gui/Window")
local Palette = Instinct.Include("Utilities/Palette")
local SFX = Instinct.Include("Gui/SFX")
local DimTools = Instinct.Include "Gui/DimTools"
local GuiPresets = Instinct.Include "Gui/GuiPresets"


-- Selecitonmenu builds a GUI with a list of items
-- The user selects and item (highlights)
-- Once OK is clicked the SelectionMenu.Selected will fire:
--> button text AND button instnace as argument
--> NIL if the user did NOT SELECT ANYTHING
--> A close button will also be generated; this will do the same

local SelectionMenu = {}


-- Style

-- Size offset per text item
SelectionMenu.SelectionOffset = 6

-- Color map -> index % 2 + 1 -> color index in color table
--> used as background color
SelectionMenu.Colors = {
	Palette:Get("Shade2", "Shade1"),
	Palette:Get("Shade2", "Shade2"),
}

SelectionMenu.SelectionColor = Palette:Get("Shade1", "Shade1")

-- Shades the selection 
-- >= selectionoffset to prevent overflows
SelectionMenu.Shade = 0


-- Horizontal total whitespace per selection
-- On the left side (and right size) this / 2


SelectionMenu.HorizontalWS = 10

-- Vertical space; how much offset between window title, the items, the OK button and the end

SelectionMenu.VerticalSpace = 5

SelectionMenu.OKColor = Palette:Get("Complement")
SelectionMenu.CreateOK = true


SelectionMenu.TextWS = 10

function SelectionMenu:Constructor()
	print("constr")
	self.SelectionDone = Instinct.Create(Instinct.Event)
end



-- No tooltip supported yet
function SelectionMenu:CreateWindow(ItemList, Title, DefaultSelection, Description) 
	assert(ItemList, "No itemlist provided")
	local Window = Instinct.Create(Instinct.Gui.Window)	
	Window.DestroyOnClose = true
	
	
	-- Create a list of text bound items
	
	local TextBounds = {} -- only horizontal
	
	local button = GuiPresets.Button()
	local max = 0
	local tmax = 0	
	
	function chk(txt)
		local s =  DimTools.TextSize(txt, button.Font, button.FontSize)
		TextBounds[txt] = s
		if s > max then
			max = s
		end
	end
	
	for i,v in pairs(ItemList) do
		chk(v)
	end
	
	chk "OK"	
	
	local TitleSizeMinimum = DimTools.TextSize(Title or "Select an item...", Window.TitleFont, Window.TitleFontSize)

	if (TitleSizeMinimum) * 0.5 > max then
		max = TitleSizeMinimum * 2
	end
	
	local ysize_needed = 4 * self.VerticalSpace + (#ItemList * (button.Size.Y.Offset + self.SelectionOffset))	
	
	Window:Create(UDim2.new(0, max + self.HorizontalWS + self.TextWS , 0,  ysize_needed), Title or "Select an item...")
	
	local curry = self.VerticalSpace -- yum
	
	
	
	for i,v in pairs(ItemList) do
			-- Selection Item
			local color_index = ( i % 2 ) + 1
			local color = self.Colors[color_index]
			local cl = button:Clone()
			cl.Parent = Window.Canvas
			cl.Position = UDim2.new(0, self.HorizontalWS/2, 0, curry)
			cl.Size = UDim2.new(0, max + self.TextWS, 0, cl.Size.Y.Offset)
			cl.BackgroundColor3 = color
			cl.Text = v
			if v == DefaultSelection and not self.SelectedButton then 
				self:ChangeSelection(cl)
			end
			cl.MouseButton1Click:connect(function() self:ChangeSelection(cl) end)
			curry = curry + cl.Size.Y.Offset + self.SelectionOffset
	end
	if self.CreateOK then 
				-- OK button
			curry = curry - self.SelectionOffset + self.VerticalSpace
			local cl = button:Clone()
			cl.Parent = Window.Canvas
			cl.Position = UDim2.new(0.5, -TextBounds["OK"]/2,0,curry)
			cl.BackgroundColor3 = self.OKColor
			cl.Text = "OK"
			cl.Size = UDim2.new(0, TextBounds["OK"] + self.TextWS, 0, cl.Size.Y.Offset)
			SFX.Shade(cl, self.Shade)
			cl.MouseButton1Click:connect(function()
				self:Done(true) -- and close window
			end)
	end
	self.Window = Window
	Window.CloseCallback = function()
		self:Done(true)
	end
end

function SelectionMenu:ChangeSelection(newbutton)
	SFX.Shade(newbutton, self.Shade)
	if self.SelectedButton then 
		SFX.RemoveShade(self.SelectedButton)
		self.SelectedButton.BackgroundColor3 = self.OldColor
	end
	self.OldColor = newbutton.BackgroundColor3 
	self.SelectedButton = newbutton
	self.SelectedText = newbutton.Text
	newbutton.BackgroundColor3 = self.SelectionColor
end


function SelectionMenu:Done(do_window_close)
	if not self.CycleDone then 
		self.CycleDone = true
		self.SelectionDone:fire(self.SelectedText)
		if do_window_close then
			self.Window:Close()
		end
	end
end

return SelectionMenu ]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX7bbb1b5d475d4173a0e416f532b488b1">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ScrollText</string>
					<ProtectedString name="Source"><![CDATA[local ScrollText = {}

local Window = Instinct.Include "Gui/Window"
local Palette = Instinct.Include "Utilities/Palette"
local Dim = Instinct.Include "Gui/DimTools"
local ColorLabel = Instinct.Include "Gui/ColorLabel"


ScrollText.Font = "ArialBold"
ScrollText.FontSize = "Size12"

ScrollText.TextColor = Palette:Get("TextColor", "Black")

function ScrollText:Create(where, size, pos)
	local new = Instance.new("Frame", where)
	new.Size = size or UDim2.new(1,0,1,0)
	new.Position = pos or UDim2.new(0,0,0,0)
	new.ClipsDescendants = true
	new.BackgroundTransparency = 1
	self.Root = new
end

function ScrollText:CreateWindow(size)
	
end

function ScrollText:Push(txt, tcolor)
	local new = Instinct.Create(ColorLabel)
	new.FontSize = self.FontSize
	new.DefaultColor = tcolor or Palette:Get "Text"
	new = new:GetLabel(txt, tcolor or Palette:Get("Text"))
	new.Position = UDim2.new(0, 0, 1, 0)
	new.Parent = self.Root
	local size_x, size_y = Dim.TextSize("test", self.Font, self.FontSize)
	for i,v in pairs(self.Root:GetChildren()) do
		v.Position = v.Position - UDim2.new(0,0,0,size_y)
		if v.Position.Y.Offset < -v.Parent.AbsoluteSize.Y then
			v:Destroy()
		end
	end
end

return ScrollText]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX1f98c5be43274814a462eb171f8bf56c">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ColorLabel</string>
					<ProtectedString name="Source"><![CDATA[local ColorLabel = {}

local Palette = Instinct.Include "Utilities/Palette"
local Dim = Instinct.Include "Gui/DimTools"

ColorLabel.FontSize = "Size12"
ColorLabel.Font = "Arial"
ColorLabel.BoldFont = "ArialBold"

ColorLabel.DefaultColor = Palette:Get("Text")

-- Parsing:
-- default escape; %{red light bold}

function ColorLabel:GetElementList(txt)
	-- returns a table with elements to build labels from
	-- ret: {txt, font, fontcolor}
	local out = {}
	local dmode = {self.Font, self.DefaultColor} -- default mode
	local cmode = dmode -- current mode
	local last
	for match, newmode in string.gmatch(txt, "([^%%]*)(%b%})") do
		last = newmode
		table.insert(out, {match, cmode[1], cmode[2]}) --unpack(cmode)
		cmode = {}
		local elements = {} -- elements provided;
		for element in string.gmatch(newmode, "[^{} ]+") do
			elements[element:lower()] = true
		end
		if not elements.reset then 
			if elements.bold then
				cmode[1] = self.BoldFont
				elements.bold = nil
			else
				cmode[1] = self.Font
			end
			local palette = "ColorLabel"
			if elements.light then
				palette = "ColorLabelLight"
				elements.light = nil
			end
			for i,v in pairs(elements) do
				local color = Palette:Get(palette, i) 
				if color then 
					cmode[2] = color
				end
			end
		else 
			cmode = dmode
		end
		if not cmode[2] then
			cmode[2] = self.DefaultColor
		end
	end
	local tail 
	if last then 
		tail = txt:match("%"..last.."(.-)$")
		local test = tail
		local loop = 0
		while test do
			test = tail:match("%"..last.."(.-)$")
			if test then
				tail = test
			end
			loop = loop + 1
			if loop > 50 then 
				break
			end
		end 
	end

	if not tail then
		tail = txt -- no escapes provided, kthen
	end
	table.insert(out, {tail, cmode[1], cmode[2]})
	return out
	
	
end


function ColorLabel:GetLabel(txt,c)
	if c then
		self.DefaultColor = c
	end
	local list = self:GetElementList(txt)
	local root
	local x = 0 -- offsetz
	local function newlabel(text, font, color)
		local new = Instance.new("TextLabel", root)

		local xsize, ysize = Dim.TextSize(text, font, self.FontSize)
		new.Size = UDim2.new(0,xsize,0,ysize)
		new.TextColor3 = color
		new.Text = text
		new.Font = font
		new.FontSize = self.FontSize
		new.BackgroundTransparency = 1
		new.Position = UDim2.new(1,x,0,0)
		if not root then
			root = new
		else 
			x = x + xsize
		end
	end
	for item_id, item_data in pairs(list) do
		local Text = item_data[1]
		local Font = item_data[2]
		local Color = item_data[3]
		newlabel(Text, Font, Color)
	end
	return root
end

return ColorLabel]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX5a95b696c1064a558c01ffd918644329">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Sidebar2</string>
					<ProtectedString name="Source"><![CDATA[local Sidebar = {}

-- Sidebar is a special GUI.
-- It creates a sidebar which opens on the right side of the screen.
-- It also features a menu button bar on top of the bar


local Palette = Instinct.Include "Utilities/Palette"
local SFX = Instinct.Include "Gui/SFX"
local Dim = Instinct.Include "Gui/DimTools"
local ButtonBar = Instinct.Include "Gui/ButtonBar"

-- If mouse is x pixels right of it; open;
Sidebar.OpenXMinimum = 75
Sidebar.XSize = 150
Sidebar.Background = Palette:Get("Default", "Shade2")
Sidebar.Border = Palette:Get("Default", "Shade4")
Sidebar.BorderSize = 3
Sidebar.ButtonBarReserve = 30


function Sidebar:Create(buttonlist)
	local player = game.Players.LocalPlayer
	local root = Instance.new("ScreenGui", player.PlayerGui)
	root.Name = "Sidebar"
	self.Screen = root
	local bar = Instance.new("Frame", root)
	bar.BackgroundColor3 = self.Background
	bar.BorderSizePixel = self.BorderSize
	bar.BorderColor3 = self.Border
	bar.Size = UDim2.new(0, self.XSize, 1,0)
	bar.Position = UDim2.new(1, 0, 0, 0)
	local swbar = Instance.new("Frame", bar)
	swbar.Size = UDim2.new(0, self.XSize, 0, self.BorderSize)
	swbar.Position = UDim2.new(0,0,0,self.ButtonBarReserve)
	swbar.BorderSizePixel = 0
	swbar.BackgroundColor3 = self.Border
	-- reserve regions for menu and content
	local menu = Instance.new("Frame", bar)
	menu.Size = UDim2.new(1,0,0, self.ButtonBarReserve)
	menu.BackgroundTransparency = 1
	self.Menu = menu

	local content = Instance.new("Frame", bar)
	content.Size = UDim2.new(1,0,1, -(self.ButtonBarReserve + self.BorderSize))
	content.Position = UDim2.new(0,0,0, self.ButtonBarReserve + self.BorderSize)
	content.BackgroundTransparency = 1
	
	self.Content = content	
	
	local bb = Instinct.Create(ButtonBar)
	
	bb:Init(self.Menu)
	for i,v in pairs(buttonlist) do
		bb:AddButton(v)		
	end	
	bb.Root.Position = bb.Root.Position + UDim2.new(0,0,0,10)
	
	self.Root = bar
end


-- opens the work task to detect the mouse, etc.
function Sidebar:Work(showhelp)
	local mouse = game.Players.LocalPlayer:GetMouse()
	delay(0, function()
		while wait() do 
		local xs = Dim.GetScreenSize().X
		local mx = mouse.X
	--print(xs, mx)
		if not self.IsOpen then 
			if xs - mx <= self.OpenXMinimum then
				self:Open()
				self.IsOpen = true
			end
		elseif xs - mx >= self.OpenXMinimum + self.XSize then
			-- check if mouse is away; close
			self:Close()
			self.IsOpen = false
		end
		end
	end)
	if showhelp then
		local TextLabel = Instance.new("TextLabel", self.Screen)
		TextLabel.BackgroundColor3 = Palette:Get("Default", "Shade2")
		TextLabel.Size = UDim2.new(0, 200, 0, 50)
		TextLabel.BorderSizePixel = 0
		TextLabel.Text = "Hover your mouse here to show the sidebar!"
		TextLabel.TextColor3 = Palette:Get("Text", "White")
		TextLabel.TextStrokeColor3 = Palette:Get("Text")
		TextLabel.TextStrokeTransparency = 0
		TextLabel.Font = "Arial"
		TextLabel.FontSize = "Size18"
		TextLabel.TextWrapped = true
		TextLabel.Position = UDim2.new(1, - 250, 0.5, -25)
		self.Help = TextLabel
	end
end

function Sidebar:Open()
	if self.Help then
		self.Help:Destroy()
	end
	self.IsOpen = true
	self.Root:TweenPosition(UDim2.new(1,-self.XSize,0,0), "Out", "Quad", 0.125, true)
end

function Sidebar:Close()
	self.IsOpen = false
	self.Root:TweenPosition(UDim2.new(1,0,0,0), "Out", "Quad", 0.125, true)
end



return Sidebar]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBXf636c574d2cc44c7bf8f623e51bca92e">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ToolTip</string>
					<ProtectedString name="Source"><![CDATA[-- omg a tooltip
-- how awesome is dat
-- very awesome
-- such wow

local ToolTip = {} -- lets not be a douchebag

local DT = Instinct.Include "Gui/DimTools"
local PAL = Instinct.Include "Utilities/Palette"
local ObjectService = Instinct.Include "Services/ObjectService"
local RecipeService = Instinct.Include "Services/RecipeService"

ToolTip.Colors = {
	info = PAL:Get("Shade1", "Shade1")
}

ToolTip.BackgroundColor = PAL:Get("Default", "Shade2")
ToolTip.InfoColor = PAL:Get("Default", "Shade1")
ToolTip.ErrorColor = PAL:Get("Complement", "Shade1")
ToolTip.SeperationColor = PAL:Get("Background", "Shade4")
ToolTip.TextColor = PAL:Get("Text", "White")
ToolTip.TextBoundsColor = PAL:Get("Text")
ToolTip.WhiteSpace = 10
ToolTip.YWhiteSpace = 6
ToolTip.SeperationSize = 2

ToolTip.Font = "Arial"
ToolTip.FontSize = "Size14"

ToolTip.TitleFontSize = "Size18"
ToolTip.TitleFont = "ArialBold"

function ToolTip:Constructor()
	self.Mouse = game.Players.LocalPlayer:GetMouse()
	local gui = Instance.new("ScreenGui", game.Players.LocalPlayer.PlayerGui)
	local fr = Instance.new("TextLabel", gui)
	fr.Visible = false 
	fr.BackgroundColor3 = self.BackgroundColor
	fr.TextColor3 = Color3.new(0,0,0)
	fr.Size = UDim2.new(0,10,0,20)
	self.Frame = fr
	fr.Font = self.TitleFont
	fr.FontSize = self.TitleFontSize
	fr.TextColor3 = self.TextColor
	fr.TextStrokeColor3 = self.TextBoundsColor
	fr.TextStrokeTransparency = 0
	fr.BorderSizePixel = 0
end

function ToolTip:Destroy()
	self.Frame.Parent:Destroy()
end

function ToolTip:Hide()
	self.Frame.Visible = false
end

-- SHOW A TOOLTIP!! AWESMEEE!
function ToolTip:Show(RBXInstance, WarnList, InfoCap, Raw, UseName) 
	-- ples
	local Mouse = self.Mouse
	local fr = self.Frame
	self.Frame.Visible=true
	self.Frame:ClearAllChildren()
	local o = ObjectService:GetObject(RBXInstance.Name)
--[[	if not o then 
		warn("Yeah I'm not gonna show a tooltip if it doesnt have an object, hiding")
		self:Hide()
		return
	end--]]
	
	fr.Text = UseName or RBXInstance.Name
	local x,y = DT.TextSize(fr.Text, fr.Font, fr.FontSize)
	fr.Size = UDim2.new(0,x+self.WhiteSpace,0,y + self.YWhiteSpace)
	local props = ObjectService:GetInfo(RBXInstance.Name, RBXInstance)
	local max_x = x + self.WhiteSpace
	local max_y = 0
	local wr = {}
	
	local function add(t,c)
			local new = fr:Clone()
			new:ClearAllChildren()
			new.Parent = fr
			new.BackgroundColor3 = c
			new.Font = self.Font
			new.FontSize = self.FontSize
			new.Text = t -- yeah we need some helper funcitons
			local sep = Instance.new("Frame", new)
			sep.BorderSizePixel = 0
			sep.BackgroundColor3 = self.SeperationColor
			sep.Size = UDim2.new(1,0,0,self.SeperationSize)
			sep.Position = UDim2.new(0,0,1,-self.SeperationSize)
			sep.ZIndex=2
			local x,y = DT.TextSize(t, fr.Font, fr.FontSize)
			local x = x + self.WhiteSpace
			max_x = (x > max_x and x) or max_x
			max_y = (y > max_y and y) or max_y
			table.insert(wr,new)
	end
		
	if not Raw then
	for i,v in pairs(props) do
	--	print(i,v)
		local propinfo = ObjectService:GetProperty(i)
	
		if propinfo and propinfo.Mode.ShowInfo then
			add(i .. " : " .. tostring(v), self.InfoColor)
		end
	end
	end
	-- push warnings here
	for i,v in pairs(WarnList or {}) do
		add(v, self.ErrorColor)
	end
	-- end push warn block
	
	if InfoCap then
		for i,v in pairs(InfoCap) do 
			if type(v) == "table" then -- k
				local iname = v[1]
				local txt = v[2]
				if iname and txt and self.Colors[iname] then
					add(txt,self.Colors[iname])
				end
			end
		end
	end

	fr.Size = UDim2.new(0, max_x, 0, y + self.YWhiteSpace)
	
	for i,v in pairs(wr) do
		v.Size = UDim2.new(0, max_x,0,max_y+self.YWhiteSpace)
		v.Position = UDim2.new(0.5, -v.Size.X.Offset/2, 1, (i-1) * (y+self.YWhiteSpace))
	end
	
	fr.Position = UDim2.new(0, Mouse.X - max_x, 0, Mouse.Y)
end

return ToolTip]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX53dc17eda9f04057a16290595e0e85ec">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ScrollBar</string>
					<ProtectedString name="Source"><![CDATA[-- A scrollbar
-- The :Add function should generate a Gui item which is then aligned

-- Call :Initialize() first after setting options to init the GUI

local ScrollBar = {}

ScrollBar.Type = "Vertical" -- not implemented horizontally yet, placeholder

ScrollBar.Parent = nil
ScrollBar.Size = nil
ScrollBar.BackgroundColor = Color3.new(0,0,0) -- THIS is just a placeholder;
-- > default is transparent
ScrollBar.BackgroundTransparency = 1

ScrollBar.WhiteSpace = 10 -- pixels between LIST items

ScrollBar.Align = "Middle" --> FOR HOOKS LATER ALIGN LEFT, RIGHT, etc
ScrollBar.Speed = 20

function ScrollBar:Constructor()
	self.Items = {}
end

function ScrollBar:Create(size)
	if not self.Parent then
		warn("No parent set, aborting ScrollBar creation")
		return
	end
	local new = Instance.new("Frame", self.Parent)
	new.BackgroundTransparency  = self.BackgroundTransparency
	new.BackgroundColor3 = self.BackgroundColor
	new.ClipsDescendants = true --> hehe
	new.Size = size or self.Size or UDim2.new(1,0,1,0)
	new.MouseWheelBackward:connect(function()
		self:Scroll(-1)
	end)
	new.MouseWheelForward:connect(function()
		self:Scroll(1)
	end)
	self.Root = new
	return new
end

function ScrollBar:PushGUIsAfterPos(pos, amount)
	for i = pos+1, #self.Items do
		local gui = self.Items[i]
		gui.Position = gui.Position + UDim2.new(0,0,0,amount)
		--x = x + itersize + self.WhiteSpace
	end
end

--> INTERNAL GUI insertion 

function ScrollBar:Insert(GUI, pos)
	local pos = pos or (#self.Items + 1)
	table.insert(self.Items, pos, GUI)
	GUI.Parent = self.Root
	local last_item = self.Items[pos-1]
	local x
	if not last_item then
		x = 0
	else
		--> OTHER HOOKS FOR HORIZONTAL!
		x = last_item.Position.Y.Offset + last_item.AbsoluteSize.Y + self.WhiteSpace
	end
	
	local barxsize = self.Root.AbsoluteSize.X	
	
	local alignsize = GUI.AbsoluteSize.X
	local loffset = (barxsize - alignsize)/2
	GUI.Position = UDim2.new(0,loffset,0,x)
	
	local plus = GUI.AbsoluteSize.Y + self.WhiteSpace
	print(plus)	
	self:PushGUIsAfterPos(pos, plus)
end

function ScrollBar:Scroll(dir)
	if not self.Items[1] then 
		return -- no items kthen
	end
	local mysize = self.Root.AbsoluteSize.Y
	local lgui = self.Items[#self.Items]
	local y = lgui.Position.Y.Offset + self.Speed * dir
	if y + lgui.AbsoluteSize.Y < mysize and dir < 0 then
		return -- end of scroll
		
	end
	if self.Items[1].Position.Y.Offset + self.Speed * dir > 0 then
		--print(self.Items[1].Position.Y.Offset + self.Speed * dir)

		return -- start of scroll
	end
	for i,v in pairs(self.Items) do
		v.Position = v.Position + UDim2.new(0,0,0,self.Speed*dir)
	end
end

function ScrollBar:Add(...)
	warn("No Add Function set -> return a GUI item please")
end

-- helper

function ScrollBar:FindGuiIndex(GUI)
	for i,v in pairs(self.Items) do
		if v == GUI then
			return i
		end
	end
end

function ScrollBar:AddBefore(GUI, ...)
	local gpos = self:FindGuiIndex(GUI) or 1
	local GUI_Item = self:Add(...)
	self:Insert(GUI_Item, gpos)
	return GUI_Item
end

function ScrollBar:AddAfter(GUI, ...)
	local gpos = self:FindGuiIndex(GUI)
	--> the insertion position is AFTER the gui so our actual pos is +1
	local gpos = (gpos and gpos+1) or 1
	local GUI_Item = self:Add(...)
	self:Insert(GUI_Item, gpos)
	return GUI_Item
end

function ScrollBar:Place(_,...)
	if #self.Items ~= 0 then 
		warn("sb is not emtpy use addafter or addbefore")
		return
	end
	ScrollBar:AddAfter(nil,...)
end

function ScrollBar:AddToEnd(...)
	local gpos = #self.Items+1
	local GUI_Item = self:Add(...)
	self:Insert(GUI_Item, gpos)
	return GUI_Item
end

-- DO NOT CHANGE GUI SIZE BEFORE CALLING THIS
-- WILL CHANGE GUI SIZE
function ScrollBar:ChangeGUISize(Gui, NewSize)
	local pos = self:FindGuiIndex(Gui)
	local osize = Gui.Size.Y.Offset
	local nsize = NewSize.Y.Offset
	local delta = nsize - osize
	self:PushGUIsAfterPos(pos, delta)
	Gui.Size = NewSize
end

function ScrollBar:AddToStart(...)
	local gpos = 1
	local GUI_Item = self:Add(...)
	self:Insert(GUI_Item, gpos)
	return GUI_Item
end

function ScrollBar:Remove(GUI)
	local lepos = self:FindGuiIndex(GUI)
	if not lepos or not self.Items[lepos] then
		warn("cannot find item!?")
		return -- wat dafaq
	end
	local ledelta = self.Items[lepos].AbsoluteSize.Y + self.WhiteSpace	
	table.remove(self.Items, lepos)
	for i = lepos, #self.Items do
		local gui = self.Items[i]
		gui.Position = gui.Position - UDim2.new(0,0,0,ledelta)
	end
	GUI:Destroy() -- .. !? why wasnt this there...
end

return ScrollBar]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX43eb4a2e8fdc4cb4a1284e03e978ba1f">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Chat</string>
					<ProtectedString name="Source"><![CDATA[local Chat = {}

local ScrollBar = Instinct.Include "Gui/ScrollBar"
local Palette = Instinct.Include "Utilities/Palette"
local ChatData = Instinct.Include "Chat"
local SFX = Instinct.Include "Gui/SFX"
local DimTools = Instinct.Include "Gui/DimTools"

Chat.IsFocussed = false

function Chat:SelectMode(char)
	local kw = ChatData.Keywords[char.."/"]
	if kw and self.SelectedText then
		self.SelectedText.Text = kw .. " [" .. ChatData.EnergyTap[kw]  .. "]"
		
	end
end

function Chat:Enable()
	self.Enabled=true
	warn("creating")
	warn(tostring(self))
	local Screen = Instance.new("ScreenGui", game.Players.LocalPlayer.PlayerGui)
	local Root = Instance.new("Frame")
	Root.Parent = Screen
	Root.BackgroundColor3 = Palette:Get("Default", "Shade2")
	Root.BackgroundTransparency = 0
	Root.Size = UDim2.new(0,260,0,200)
	Root.BorderColor3 = Palette:Get("Default", "Shade4")
	Root.BorderSizePixel = 2;
	Root.Position = UDim2.new(0,20,0,20)
	--Root.ClipsDescendants = true
	Root.BackgroundTransparency = 1
	local ChatModes = {"w", "d", "y", "s", "g"}
	local ChatETap = {}
	for i,v in pairs(ChatModes) do
		local kw = ChatData.Keywords[v.."/"]
		if kw then
			ChatETap[v] = ChatData.EnergyTap[kw]
		end
	end
	self.ChatContainer = Root
	print(Root:GetFullName())
	local ChatBar = Instance.new("Frame", Screen)
	ChatBar.Position = UDim2.new(0, 20, 0, 200 + 20 + 10)	
	ChatBar.BorderSizePixel = 2
	ChatBar.BorderColor3 = Palette:Get("Default", "Shade4")
	ChatBar.BackgroundColor3 = Palette:Get("Default", "Shade2")
	
	ChatBar.Size = UDim2.new(0, 220, 0, 36)
	local CX = 0
	local selected
	for i,v in pairs(ChatModes) do
		local new = Instance.new("TextButton", ChatBar)
		new.BorderSizePixel = 1
		new.BorderColor3 = Palette:Get("Default", "Shade3")
		new.BackgroundColor3 = Palette:Get("Default", "Shade1")
		new.Text = v
		new.Size = UDim2.new(0, 15, 0, 18)
		new.Position = UDim2.new(0, 15 * (i - 1) + i * 1, 0, 0)
		new.Font = "ArialBold"
		new.TextColor3 = Palette:Get("Text", "White")
		new.TextStrokeColor3 = Palette:Get("Text")
		new.TextStrokeTransparency = 0
		new.FontSize = "Size14"
		CX = 15 * (i ) + (i-1) * 1
		if v == "d" then
			selected=new
			new.BackgroundColor3 = Palette:Get("Shade1", "Shade2")
		end
		new.MouseButton1Click:connect(function()
			self:SelectMode(v)
			selected.BackgroundColor3 = Palette:Get("Default", "Shade1")
			new.BackgroundColor3 = Palette:Get("Shade1", "Shade2")
			selected=new
		end)
	end
	
	local SelectedText = Instance.new("TextLabel", ChatBar)
	SelectedText.BorderColor3 = Palette:Get("Default", "Shade3")
	SelectedText.BackgroundColor3 = Palette:Get("Default", "Shade1")
	SelectedText.Text = ""
	SelectedText.Size = UDim2.new(0, CX, 0, 16)
	SelectedText.Position = UDim2.new(0, 1, 0, 19)
	SelectedText.Font = "ArialBold"
	SelectedText.TextColor3 = Palette:Get("Text", "White")
	SelectedText.TextStrokeColor3 = Palette:Get("Text")
	SelectedText.TextStrokeTransparency = 0
	SelectedText.FontSize = "Size14"

	
	self.SelectedText = SelectedText	
	self:SelectMode("d")	
	
	ChatBar.Size = UDim2.new(0, CX+2, 0, 36)
	
	local Form = Instance.new("TextBox", ChatBar)
	Form.BorderColor3 = Palette:Get("Default", "Shade3")
	Form.BackgroundColor3 = Palette:Get("Default", "Shade1")
	Form.Text = "Click here or press / to chat"
	Form.Size = UDim2.new(0, 260 - CX - 8 - 2, 0, 16)
	Form.Position = UDim2.new(0, CX + 8, 0, 10)
	Form.Font = "ArialBold"
	Form.TextColor3 = Palette:Get("Text", "White")
	Form.TextStrokeColor3 = Palette:Get("Text")
	Form.TextStrokeTransparency = 0
	Form.FontSize = "Size14"
	local osize =  UDim2.new(0, 260 - CX - 8 - 2, 0, 16)
	Form.Changed:connect(function(prop)
		if prop == "Text" then
			if Form.TextBounds.X + 10 > Form.Size.X.Offset then
				Form.Size = UDim2.new(0, Form.TextBounds.X + 10, 0, Form.Size.Y.Offset)
				
			end
		end
	end)
	
	Form.FocusLost:connect(function(t)
		if not t then return end
		self.IsFocussed = false
		if selected.Text == "d" then
			Instinct.Communicator:Send("Chat", Form.Text)
		else
			Instinct.Communicator:Send("Chat", selected.Text.."/ "..Form.Text)
		end
		Form.Size = osize
		Form.Text = "Click here or press / to chat"
	end)
	
	local uis = game:GetService("UserInputService")
	uis.InputBegan:connect(function(obj)
		local _,key = pcall(function() return obj.KeyCode end)
		
		if key == Enum.KeyCode.Slash then
			if self.IsFocussed then return end
			self.IsFocussed = true
			Form:CaptureFocus()
		end
	end)
	
	return Root
end

function Chat:Push(delta, ignore)
	for i,v in pairs(self.ChatContainer:GetChildren()) do
		if v ~= ignore then 
			v.Position = UDim2.new(0,0,1, v.Position.Y.Offset - delta)
		end
		if (v.Position.Y.Offset + v.Size.Y.Offset + 2) < -self.ChatContainer.Size.Y.Offset then
			v:Destroy()
		end
	end
end

function Chat:PutLocal(Message)
	self:Process(Message, "Default", "_local")
end

function Chat:Process(Message, Mode, Receipent)
	warn(tostring(self.ChatContainer))
	warn(tostring(self))
	-- I WANT A FUCKING STACK TRACE< WTF
	--error("err, mes was : " .. Message)
	if not self.ChatContainer then return end
	print("PROCESSING", Message, Mode, Receipent, self.Enabled)
	print(self.ChatContainer:GetFullName())
	if not self.Enabled then return end
	local transform = {
		Default = "said",
		Whisper = "whispered",
		Yell = "yelled",
		Shout = "shouted",
		Global = "screamed"
	}	
	
	local text = Instance.new("TextLabel", self.ChatContainer)
	local font = "ArialBold"
	local fonts = "Size18"
	
	local Receipent=Receipent
	local put = Receipent .. " " .. (transform[Mode] or "ERR_NOMODSTR") .. ": " .. Message
	if Receipent == "_host" then
		text.BackgroundColor3 = Palette:Get("Shade1", "Shade2")
		put = "Server notified: " .. Message
	elseif Receipent == "_local" then
		put = Message
		text.BackgroundColor3 = Palette:Get("Complement", "Shade1")
	else
		text.BackgroundColor3 = Palette:Get("Complement", "Shade2")
	end
	
	local x,y = DimTools.TextSize(put, font, fonts)
	text.Size = UDim2.new(0, x + 10, 0, y + 6)
	SFX.Shade(text,2)

	text.Font = font
	text.FontSize = fonts
	text.Text = put
	text.TextColor3 = Palette:Get("Text", "White")
	text.TextStrokeColor3 = Palette:Get("Text")
	text.TextStrokeTransparency = 1
	
	text.Position = UDim2.new(0, 0, 1, -(y + 6 + 2))
	
	self:Push(y + 6 + 6, text) -- 3 = whitespace qq
end


return Chat]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBXe848a36ea4be4cdca00fb520bc7c1995">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">SideBar</string>
					<ProtectedString name="Source"><![CDATA[local SideBar = {}

local ObjectService = Instinct.Include "Services/ObjectService"
local ScrollBar = Instinct.Include "Gui/ScrollBar"
local ToolService = Instinct.Include "Services/ToolService"
local Dim = Instinct.Include "Gui/DimTools"

SideBar.IsOpen = true

SideBar.ForceClosed = false

SideBar.OpenTime = 0.125
SideBar.MinimalXOpen = 75

function SideBar:Constructor()
	print("CREATED SB")
	local new = game:GetService("ReplicatedStorage").Inventory:Clone()
	new.Parent = game.Players.LocalPlayer.PlayerGui
	self.XSize = new.Sidebar.Size.X.Offset
	local ResourceCategoryContainer = new.Sidebar.RealBar.Inventory.Ore:Clone()
	self.InventoryYBase = ResourceCategoryContainer.Size.Y.Offset
	local Contents = ResourceCategoryContainer.Contents
	local Line = Contents.Cassiterite.Line:Clone()
	local Resource = Contents.Cassiterite:Clone()
	self.InventoryYDelta = Resource.Size.Y.Offset
	--Contents:ClearAllChildren()
	self.ResourceCategoryContainer = ResourceCategoryContainer
	--self.Contents = Contents
	self.Line = Line
	self.Resource = Resource
	self.Resource.Line:Destroy()
	ResourceCategoryContainer.Contents:ClearAllChildren()	
	new.Sidebar.RealBar.Inventory:ClearAllChildren()
	self.Inventory = Instinct.Create(ScrollBar)
	self.Inventory.Parent = new.Sidebar.RealBar.Inventory
	self.Inventory:Create()
	
	function self.Inventory:Add(GUI)
		return GUI -- HAX
	end
	
	self.Data = {}	
	
	self.Root = new
end

function SideBar:Destroy()
	self.Root:Destroy()
end


SideBar.DefaultCategory = "Miscallerous"
function SideBar:GetObjectCategory(Object)
	return (Object and Object.Material) or self.DefaultCategory
end

function SideBar:Work()
	local mouse = game.Players.LocalPlayer:GetMouse()
	self.Root.Sidebar.Visible=true
	delay(0, function()
		while wait() do 
			local xs = Dim.GetScreenSize().X
			local mx = mouse.X
			--print(xs, mx)
			if not self.ForceClosed then 
				if not self.IsOpen then 
					if xs - mx <= self.MinimalXOpen then
						self:Open()
					end
				elseif xs - mx >= self.MinimalXOpen + self.XSize then
					-- check if mouse is away; close
					self:Close()
				end
			end
		end
	end)
end

function SideBar:MakeVisible()
	self.Root.Sidebar.Visible = true
end

function SideBar:ForceClose()
	self.ForceClosed=true
	self:Close()
end

function SideBar:EnableOpen()
	self.ForceClosed=false
	
end

function SideBar:Open()
	self.IsOpen = true
	self.Root.Sidebar:TweenPosition(UDim2.new(1,-self.XSize,0,0), "Out", "Quad", self.OpenTime, true)
end

function SideBar:Close()
	self.IsOpen = false
	self.Root.Sidebar:TweenPosition(UDim2.new(1,0,0,0), "Out", "Quad", 0.125, true)
end



function SideBar:AddBackpackItem(resource)
	local obj = ObjectService:GetObject(resource.Name)
	local Category = self:GetObjectCategory(obj)
	if not self.Data[Category] then
		local RootGui = self.ResourceCategoryContainer:Clone()
		RootGui.Title.CategoryText.Text = Category
		self.Data[Category] = {GUI = RootGui}
		RootGui.Title.Collapse.MouseButton1Click:connect(function()
			-- TODO: change rectangle thing
			if RootGui.Contents.Visible then
				RootGui.Contents.Visible = false
				RootGui.Title.Collapse.Arrow.Rotation = 0
				self.Inventory:ChangeGUISize(RootGui, UDim2.new(1,0,0,self.InventoryYBase))
			else
				RootGui.Contents.Visible = true
				local NumItems = #(self.Data[Category])
				RootGui.Title.Collapse.Arrow.Rotation = 180
				self.Inventory:ChangeGUISize(RootGui, UDim2.new(1, 0,0, self.InventoryYBase + NumItems * self.InventoryYDelta))
			end
		end)
		if Category == self.DefaultCategory then
			self.Inventory:AddToEnd(RootGui)
		else
			self.Inventory:AddToStart(RootGui)
		end
	end
	local CatGUI = self.Data[Category].GUI
	local UseTable = self.Data[Category]
	local NumChildren = #(UseTable)
	local NewResource = self.Resource:Clone()
	NewResource.RealText.Text = resource.Name
	NewResource.Parent = CatGUI.Contents
	NewResource.Position = UDim2.new(0,0,0, NumChildren * self.InventoryYDelta)
	-- bind to events
	NewResource.MouseButton1Click:connect(function()
		self:RequestDrop(resource)
	end)
	NewResource.MouseButton2Click:connect(function()
		self:RequestCreateTool(resource)
	end)
	if NumChildren > 0 then
		local LastGui = UseTable[#UseTable]
		if LastGui then
			self.Line:Clone().Parent = LastGui
		end
	end
	-- Setup data to find it back
	table.insert(UseTable, NewResource)
	UseTable[resource] = NewResource
	-- figure out if changesize should be called to fix scrollbar st00f
	if CatGUI.Contents.Visible then
		self.Inventory:ChangeGUISize(CatGUI, UDim2.new(1, 0, 0, (NumChildren+1) * self.InventoryYDelta + self.InventoryYBase))
	end
end

function SideBar:RemoveBackpackItem(resource)
	local obj = ObjectService:GetObject(resource.Name)
	local Category = self:GetObjectCategory(obj)
	local Tab = self.Data[Category]
	local GUI = Tab[resource]
	local ID
	for i,v in ipairs(Tab) do 
		if v == GUI then
			ID = i
			break
		end
	end
	print(ID)
	-- first PUSHDOWN all remaing things
	for i = ID+1, #Tab do 
		print(i)
		Tab[i].Position = UDim2.new(0,0,0,(i-2) * self.InventoryYDelta)
	end
	if ID == #Tab then -- never remove line from first ID
		local LineGUI = Tab[ID-1]
		if LineGUI and LineGUI:FindFirstChild("Line") then
			LineGUI.Line:Destroy()
		end
	end
	Tab[resource] = nil
	table.remove(Tab, ID)
	GUI:Destroy()
	if #Tab == 0 then
		self.Inventory:Remove(Tab.GUI)
		self.Data[Category] = nil
	else
		if Tab.GUI.Contents.Visible then
			self.Inventory:ChangeGUISize(Tab.GUI, UDim2.new(1, 0, 0, (#Tab) * self.InventoryYDelta + self.InventoryYBase))
		end
	end
end

function SideBar:Show(WName)
	-- later. show craft/inventory
end

function SideBar:RequestDrop(resource)
	local comm = Instinct.Communicator
	comm:Send("Drop", resource)
end

function SideBar:RequestCreateTool(resource)
	ToolService:RequestToolCreation("DefaultTool", {name={resource}})
end



return SideBar]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX65dd1fca62df4c5bb81ad32d6077be04">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ToolGui</string>
					<ProtectedString name="Source"><![CDATA[local ToolGui = {}

ToolGui.ToolWhitespace = 15; -- whitespace between tools
ToolGui.CategoryWhitespace = 50; -- whitespace between categories, left,right, etc.
ToolGui.UnequippedY = -70;
ToolGui.EquippedY = -130;
ToolGui.ExpandedDX = 30; -- how many pixels dem tool increases

ToolGui.CanUpdate = true

function ToolGui:Constructor()
	self.Root = game:GetService("ReplicatedStorage").ToolGui:Clone()
	self.Root.Parent = game.Players.LocalPlayer.PlayerGui
	local use = self.Root.ToolCardShadowed:Clone()
	self.Template = use
	self.XUnit = use.Size.X.Offset
	
	self.Root:ClearAllChildren()
	self.Tools = {
		Left = {},
		Right = {},
		NonPhysical = {},
	}
	self.GUIs = {} -- [tool] = gui
end

function ToolGui:UpdatePositions()
	if not self.CanUpdate then return end
	local TotalGUIs = #self.Tools.Left + #self.Tools.Right + #self.Tools.NonPhysical
	-- lets use a trick to make it simpler
	-- first build everything from 0, then actually place it offsetted to the middle.
	local cpos = 0 
	-- start with nonphysicla, then left, then right
	local newpos = {}	
	local gotother = false
	for index, tool in pairs(self.Tools.NonPhysical) do
		gotother = true
		local gui = self.GUIs[tool]
		if index  > 1 then
			cpos = cpos + self.ToolWhitespace
		end
		if gui then
			local y = self.UnequippedY
			local sizex = self.XUnit
			if tool.IsEquipped then
				y = self.EquippedY
				sizex = self.XUnit + self.ExpandedDX
			end
			newpos[gui] = {cpos, y, sizex}
			cpos = cpos + self.XUnit
		end
	end

	for i, tab in pairs {self.Tools.Left, self.Tools.Right} do
		for index, tool in pairs(tab) do
			
			if index == 1 and gotother then
				cpos = cpos + self.CategoryWhitespace
			else
				cpos = cpos + self.ToolWhitespace
			end
			gotother = true
			local gui = self.GUIs[tool]
			if gui then
				 local y = self.UnequippedY
				local sizex = self.XUnit
				if tool.IsEquipped then
					y = self.EquippedY
					sizex = self.XUnit + self.ExpandedDX
				end
				newpos[gui] = {cpos, y, sizex}
				cpos = cpos + self.XUnit
		
			end
		end
	end
	local sizeof = cpos -- LOL ok.
	local xmux = -sizeof/2
	
	for gui, data in pairs(newpos) do
		local xpos = data[1]
		local ypos = data[2]
		local sizex = data[3]
		if sizex > self.XUnit then -- is expanded
			xpos = xpos - self.ExpandedDX/2
		end
		gui:TweenSizeAndPosition(UDim2.new(0, sizex, 0, gui.Size.Y.Offset), UDim2.new(0.5, xpos + xmux, 1,ypos), "Out", "Quad", 1, true)
	end
end

function ToolGui:RemoveTool(toolobj)
	local ftab
	if toolobj.Type == "Normal" then
		if toolobj.Hand == "Left" then
			-- hakes
			ftab = self.Tools.Left
		elseif toolobj.Hand == "Right" then
			ftab = self.Tools.Right
		end
	elseif toolobj.Name == "NonPhysical" then
		ftab = self.Tools.NonPhysical
	end
	local fi 
	for i,v in pairs(ftab) do
		if v == toolobj then
			fi = i
			break
		end
	end
	local ToolService = Instinct.Services.ToolService
	local function getkeystr(enum)
		return ToolService.HotkeyNames[enum]
	end

	table.remove(ftab, fi)
	table.sort(ftab, function(a,b) return getkeystr(a.Hotkey) < getkeystr(b.Hotkey) end)
	self.GUIs[toolobj]:Destroy()
	self.GUIs[toolobj] = nil
	self:UpdatePositions()
end

function ToolGui:AddTool(toolobj)
	-- Cannot direct include toolservice QQ	
	local ToolService = Instinct.Services.ToolService
	local KeyService = Instinct.Services.KeyService
	
	-- helper
	local function getkeystr(enum)
	
		return ToolService.HotkeyNames[enum]
	end
	
	local new = self.Template:Clone()
	new.Parent = self.Root
	if toolobj.Type == "NonPhysical" then
		new.ContentClipper.Drop:Destroy()
		new.ContentClipper.ChangeHand:Destroy()
		new.ContentClipper.ToolName.Text = toolobj.Name
		
	else
		new.ContentClipper.Drop.MouseButton1Click:connect(function()
			Instinct.Communicator:Send("DropTool", toolobj.ToolRoot)
		end)
		new.ContentClipper.ToolName.Text = toolobj.Tool.Name -- handle name = toolname

		new.ContentClipper.ChangeHand.MouseButton1Click:connect(function()

			if toolobj.Type == "Normal" then
				local i
				for index, tool in pairs(self.Tools[toolobj.Hand]) do
					if tool == toolobj then
						i = index
						break
					end
				end
				table.remove(self.Tools[toolobj.Hand], i)
				-- force quit update
				self.CanUpdate = false
				ToolService:ChangeHand(toolobj)
				self.CanUpdate = true
				local ftab
				if toolobj.Hand == "Left" then
					ftab = self.Tools.Left
				else
					ftab = self.Tools.Right
				end
		
				table.insert(ftab, toolobj)
				table.sort(ftab, function(a,b) return getkeystr(a.Hotkey) < getkeystr(b.Hotkey) end)
				self:UpdatePositions()
			end
		end)
	end
	
	new.ContentClipper.Hotkey.Text = getkeystr(toolobj.Hotkey)
	new.ContentClipper.ToolName.MouseButton1Click:connect(function()
		ToolService:GeneralEquip(toolobj)
	end)
	warn("CONNECT KEYSERVICE")
	--[[KeyService.KeyDown:connect(function(key)
		print(key, toolobj.Hotkey)
		if key == toolobj.Hotkey then
			ToolService:GeneralEquip(toolobj)
		end
	end)--]]
	-- register tool in data
	local ftab
	if toolobj.Type == "Normal" then
		if toolobj.Hand == "Left" then
			-- hakes
			ftab = self.Tools.Left
		elseif toolobj.Hand == "Right" then
			ftab = self.Tools.Right
		end
	elseif toolobj.Type == "NonPhysical" then
		ftab = self.Tools.NonPhysical
	end
	table.insert(ftab, toolobj)
	table.sort(ftab, function(a,b) return getkeystr(a.Hotkey) < getkeystr(b.Hotkey) end)
	self.GUIs[toolobj] = new
	
	self:UpdatePositions()
end

return ToolGui]]></ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="Script" referent="RBX930c3a8beb7745a690a06927fe9e3be8">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Menu</string>
				<ProtectedString name="Source"><![CDATA[local ButtonBar = Instinct.Include("Gui/ButtonBar")
local Palette = Instinct.Include("Utilities/Palette")
local SFX = Instinct.Include("Gui/SFX")
local WindowServer = Instinct.Include("Gui/WindowServer")
local DDMenu = Instinct.Include("Gui/DropDown")
local DimTools = Instinct.Include("Gui/DimTools")

local Player = game.Players.LocalPlayer

local Menu = {}

Menu.Offset = 4
Menu.YSize = 30
Menu.Shade = 2
Menu.BorderSize = 3
Menu.FontSize = "Size14"
Menu.LastDropDown = nil
Menu.LastDropDownButton = nil

function Menu:Init()
	local Scr = Instance.new("ScreenGui", Player.PlayerGui)
	Scr.Name = "Menu"
	self.Root = Scr
	local bar = Instance.new("Frame", Scr)
	self.Bar= bar
	bar.Size=UDim2.new(0,0,0,self.YSize)
	bar.BorderSizePixel = self.BorderSize
	bar.BorderColor3 = Palette:Get("Default", "Shade4")
	bar.BackgroundColor3 = Palette:Get("Default", "Shade2")
	self.Bar = bar
	-- create dropdown button
	bar.Position = UDim2.new(0.5, 0, 0, 0)
end

function Menu:GetButton(type, openlist)
	local DropDown = Instance.new("TextButton", self.Bar)
	local offset = self.YSize - self.Offset * 2
	DropDown.BackgroundColor3 = Palette:Get("Complement")
	DropDown.TextColor3 = Palette:Get("Text")
	DropDown.Font = "ArialBold"
	DropDown.FontSize = self.FontSize
	DropDown.Text = "V"
	DropDown.BorderSizePixel = 0
	SFX.Shade(DropDown,self.Shade)
	if type == "DropDown" and openlist then 
		DropDown.MouseButton1Click:connect(function()
		if self.LastDropDown then
			self.LastDropDown:Destroy()
		end
		if self.LastDropDownButton == DropDown then
			self.LastDropDownButton = nil
			return
		end
		self.LastDropDownButton = DropDown
		local new = Instinct.Create(Instinct.Gui.DropDown)
		self.LastDropDown = new
		new:Create(self.Root, UDim2.new(0,0,0, self.YSize + self.BorderSize), Palette:Get("Default", "Shade1"), Palette:Get("Default", "Shade4"), 
			{	which = DropDown,
				left = false,
				right = true,
				up = false,
				down = true,
				bordersize = self.BorderSize,
		})
		for i,v in pairs(openlist) do 
			local NewButton = new:AddButton(v)
			NewButton.MouseButton1Click:connect(function()
				WindowServer.RequestOpen(NewButton.Text, NewButton)
			end)
		end
		end)
	else 
		-- negotiate with winserver
		local Window
		DropDown.MouseButton1Click:connect(function() 
			local xWindow = WindowServer.RequestOpen(DropDown.Text, DropDown)
		
		end)
	end
	return DropDown
end

function Menu:AddButton(button_name, type, openlist)
	local button = self:GetButton(type or "Window", openlist)
	button.Text = button_name
	local max = 0
	for i,v in pairs(self.Root:GetChildren()) do
		if v.Position.X.Offset + v.Size.X.Offset + self.Offset + self.Shade > max then 
			max = v.Position.X.Offset + v.Size.X.Offset + self.Offset + self.Shade
		end
	end
	button.Position = UDim2.new(0,max,0,self.Offset)
	local offset = self.YSize - self.Offset * 2
	local x = DimTools.TextSize(button_name, button.Font, button.FontSize)
	button.Size = UDim2.new(0, x + 10, 0, offset)
	local nsize = max + button.Size.X.Offset + self.Offset + self.Shade
	delay(1/30, function() self.Bar.Size = UDim2.new(0, nsize, 0, self.YSize) end)
end

return Menu ]]></ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBXeb354594d42d4647bfdde7c9c4681f66">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Console</string>
				<ProtectedString name="Source"><![CDATA[local Console = {}

local Palette = Instinct.Include "Utilities/Palette"
local ScrollText = Instinct.Include "Gui/ScrollText"
local ButtonBar = Instinct.Include "Gui/ButtonBar"
local Dim = Instinct.Include "Gui/DimTools"

local Player = game.Players.LocalPlayer

Console.Seperator = " :: "
Console.Ready = false

function Console.Initialize()
	print(Console.Ready)
	if Console.Ready then
		return
	end
	local new = Instance.new("ScreenGui", Player.PlayerGui)
	new.Name = "Console"

	local fr = Instance.new("Frame", new)
	fr.BackgroundColor3 = Palette:Get("Shade1", "Shade4")
	fr.Size = UDim2.new(1,0,1,0)
	fr.Name = "Outer"
	fr.BorderSizePixel = 0
	local win = Instance.new("Frame", fr)
	win.Size = UDim2.new(1,-80,1,-80)
	win.Position = UDim2.new(0,40,0,40)
	win.BackgroundColor3 = Palette:Get("Console")
	win.Name = "Inner"
	Console.CRoot = new
	Console.TerminalWindow = win
	-- Create tab bar
	local new = Instinct.Create(Instinct.Gui.ButtonBar)
	local size_x, size_y = Dim.TextSize("test", new.Font, new.FontSize)
	new:Init(Console.CRoot, UDim2.new(0,40, 1, -38), UDim2.new(1,-80,0,size_y + new.Shade))
	Console.ButtonDock = new
	Console.Tabs = {}
	Console.Ready = true
end

function Console.Open()
	for i,v in pairs(Console.CRoot:GetChildren()) do
		v.Visible = true
	end 
end

function Console.Close()
	for i,v in pairs(Console.CRoot:GetChildren()) do
		v.Visible = false
	end 
end

function Console.Write(tab, prio, ...)
	-- figure out if prio is an option or just text
	--> assertion: if prio is a table then it is an option!
	if not Console.Tabs[tab] then
		Console.CreateTab(tab)
	end
	local args
	if type(prio) == "table" then
		args = {...}
		if prio == Instinct.Option.ConsolePriority.Extreme then 
			-- MASTER WARNING open up the console
			Console.Open()
		end
	else 
		args = {prio, ...}
	end
	local t_args = {}
	for i,v in pairs(args) do
		t_args[i] = tostring(v)
	end
	local str = table.concat(t_args, Console.Seperator)
	Console.Tabs[tab][1]:Push("[ %{light cyan bold} "..math.floor(os.time() + 0.5).." %{reset}] "..str, Palette:Get("ColorLabel", "white"))
end

function Console.OpenTab(tab)
	if Console.TabOpen then
		Console.Tabs[Console.TabOpen][1].Root.Visible = false
		Console.Tabs[Console.TabOpen][2].BackgroundColor3 = Palette:Get("Complement")
	end
	if Console.Tabs[tab] then
		Console.TabOpen = tab
		Console.Tabs[tab][1].Root.Visible = true
		Console.Tabs[tab][2].BackgroundColor3 = Palette:Get("Shade1")
	end
end

function Console.CreateTab(tab)
	if Console.Tabs[tab] then
		return
	end
	local b = Console.ButtonDock:AddButton(tab)

	Console.Tabs[tab] = {Instinct.Create(ScrollText),b}
	Console.Tabs[tab][1].FontSize = "Size18"
	Console.Tabs[tab][1].TextColor = Palette:Get("Console", "Text")
	Console.Tabs[tab][1]:Create(Console.TerminalWindow)
	Console.Tabs[tab][1]:Push(" --- "..tab.." ---", Palette:Get("ColorLabel", "white"))
	Console.Tabs[tab][1].Root.Visible = false
	
	b.MouseButton1Click:connect(function()
		if Console.TabOpen then
			Console.Tabs[Console.TabOpen][1].Root.Visible = false
			Console.Tabs[Console.TabOpen][2].BackgroundColor3 = Palette:Get("Complement")
		end
		Console.TabOpen = tab
		Console.Tabs[tab][1].Root.Visible = true
		b.BackgroundColor3 = Palette:Get("Shade1")
	end)
	
	return Console.Tabs[tab][1]
end

return Console]]></ProtectedString>
			</Properties>
		</Item>
		<Item class="Model" referent="RBX855429cd604b420bb1bdf6b495a3d251">
			<Properties>
				<CoordinateFrame name="ModelInPrimary">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<string name="Name">LocaleFiles</string>
				<Ref name="PrimaryPart">null</Ref>
			</Properties>
			<Item class="Script" referent="RBXd8def658038b4adf92c3436ac54133fb">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Francais</string>
					<ProtectedString name="Source"><![CDATA[local Locale = {

	
	
}

return Locale
]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX64748a3444df4d92870698a80469c25b">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Deutsch</string>
					<ProtectedString name="Source"><![CDATA[local Locale = {

	
	
}

return Locale
]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX6e747a14026040429fb4d84d1ebeac22">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">English</string>
					<ProtectedString name="Source"><![CDATA[local Locale = {
	MENU_BACKPACK = "Backpack",
	MENU_TRIBE = "Tribe",
	MENU_RECIPES = "Recipes",
	MENU_HELP = "Help",
	MENU_CONSOLE = "Console",
	MENU_ADMINISTRATION = "Administration",
	MENU_SERVER = "Server"
	
	
}

return Locale
]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX3df96af23b5e4d628703126f8399b484">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Espanol</string>
					<ProtectedString name="Source"><![CDATA[local Locale = {

	
	
}

return Locale
]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX261e959240f14de29633a35f486bee66">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Italiano</string>
					<ProtectedString name="Source"><![CDATA[local Locale = {

	
	
}

return Locale
]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBXf933822773884d769d73f83e19f39554">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Nederlands</string>
					<ProtectedString name="Source"><![CDATA[local Locale = {
	MENU_BACKPACK = "Rugzak",
	MENU_TRIBE = "Stam",
	MENU_RECIPES = "Recepten",
	MENU_HELP = "Hulp",
	MENU_CONSOLE = "Console",
	MENU_ADMINISTRATION = "Administratie",
	MENU_SERVER = "Server",
	
	
}

return Locale
]]></ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="Script" referent="RBX5fe65d5a34904ed4b46141554b1f384e">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Event</string>
				<ProtectedString name="Source"><![CDATA[local Event = {}

function Event:Call()
	self:fire()
end

function Event:Constructor()
	self.List = {}
end

function Event:connect(func)
	table.insert(self.List, func)
	local ret = {}
	local link = self
	function ret:disconnect()
		for i,v in pairs(link.List) do
			if v == func then
				link.List[i] = nil
				break
			end
		end
	end
	return ret
end

function Event:fire(...)
	local args = {...}
	for i,v in pairs(self.List) do 
		delay(0, function() v(unpack(args)) end)
	end
end

function Event:wait()
	-- well well well HOW IN THE WORLD ARE WE GOING TO DO THIS!?
	--> BUSY WAIT!? (no?)
	--> any kind of awesome coroutine hack?
end

return Event]]></ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX473bd85365764f799fb12b511d81fee1">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Content</string>
				<ProtectedString name="Source"><![CDATA[local Content = {}

function Content:WaitForContent()
	Instinct.Console.CreateTab "Core"
	local last = game:GetService("ContentProvider").RequestQueueSize
	while game:GetService("ContentProvider").RequestQueueSize > 0 do
		wait()
		if game:GetService("ContentProvider").RequestQueueSize ~= last then
			last = game:GetService("ContentProvider").RequestQueueSize
			Instinct.Console.Write("Core", "ContentProvider: Queue: "..game:GetService("ContentProvider").RequestQueueSize)
		end
	end
end

return Content]]></ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX00cf4ba2d3f3466dbc63eb41bcd8e54c">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">MainMenu</string>
				<ProtectedString name="Source"><![CDATA[-- MainMenu provides the main menu for the game
-- Additional modules can be launched from here
-- Insertion points are provided

local Palette = Instinct.Include "Utilities/Palette"
local Locale = Instinct.Include "Services/Locale"
local Presets = Instinct.Include "Gui/GuiPresets"
local Dim = Instinct.Include "Gui/DimTools"

local MainMenu = {}

MainMenu.TitleFont = "ArialBold"
MainMenu.FontSize = "Size36"
MainMenu.TitleShade = 3

MainMenu.BarSize = 4
MainMenu.BarOffset = 3
MainMenu.BarColor = Palette:Get() 
MainMenu.BarScale = 0.8 -- 80% of the original size

MainMenu.TextWhiteSpace = 10

MainMenu.ButtonFont = "ArialBold"
MainMenu.ButtonFontSize = "Size24"
MainMenu.VersionFontSize = "Size14"

MainMenu.WhiteSpace = 20
MainMenu.ButtonShading = 2 -- wow so much shading
MainMenu.XOffset = 50

MainMenu.Choosen = nil --


function MainMenu:Constructor()
	self.Choosen = Instinct.Create(Instinct.Event)
end

local Player = game.Players.LocalPlayer

function MainMenu:CreateFromList(title, list) -- creates the main menu from gui items
	local VERSION = Instinct.Include "Version"
	local title = title 
	local Root = Instance.new("ScreenGui", Player.PlayerGui)
	self.Root = Root
	local Backdrop = Presets.Backdrop(5)
	local MMLabel, x, y = Presets.CustomButton(
		title,		self.TitleShade, self.TitleFont, self.FontSize, 
		Palette:Get("Text"), Palette:Get("Complement"), 
		self.TextWhiteSpace) 
	local curry = self.WhiteSpace
	Backdrop.Parent = Root
	MMLabel.Parent = Backdrop
	local curry = curry + y + self.WhiteSpace
	MMLabel.Position = UDim2.new(0.5, -x/2, 0, self.WhiteSpace)
	local max_x = x
	table.insert(list, 1, "Version "..VERSION)
	for i,v in pairs(list) do
		local DeltaY = -( self.TextWhiteSpace - self.BarOffset )
		local inspos = curry + DeltaY 
		local new = Instance.new("Frame", BackDrop)
		local b,x,y
		if i ~= 1 then 
			b,x,y = Presets.CustomButton(v, self.ButtonShading, self.ButtonFont, 
			self.ButtonFontSize, Palette:Get("Text"), Palette:Get("Complement", "Shade2"), 
			self.TextWhiteSpace
			)
		else 
			b,x,y = Presets.CustomButton(v, self.ButtonShading, self.ButtonFont,
			self.VersionFontSize,  Palette:Get("Text"), Palette:Get("Complement", "Shade1"), 
			self.TextWhiteSpace
			)
		end 
		b.Parent = Backdrop
		b.Position = UDim2.new(0.5, -x/2, 0, curry)
		b.MouseButton1Click:connect(function()
			self.Choosen:fire(b.Text)
		end)
		curry = curry + y + self.WhiteSpace
		if x > max_x then
			x = max_x
		end
	end
	
	Backdrop.Size = UDim2.new(0, max_x + self.WhiteSpace, 0, curry)
	Backdrop.Position = UDim2.new(1,-(max_x + self.WhiteSpace) - self.XOffset, 0.5, -curry/2)
end

function MainMenu:Close()
	self.Root:Destroy()
end


return MainMenu]]></ProtectedString>
			</Properties>
		</Item>
		<Item class="Model" referent="RBX21203dd39dec4529972104b2bb8d9f30">
			<Properties>
				<CoordinateFrame name="ModelInPrimary">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<string name="Name">World</string>
				<Ref name="PrimaryPart">null</Ref>
			</Properties>
			<Item class="Script" referent="RBX234e183e811040ccaada2acc21a32a09">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Tree2</string>
					<ProtectedString name="Source"></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBXe8865103856b4224952771f463e173ce">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Placer</string>
					<ProtectedString name="Source"><![CDATA[-- General placer.

local Placer = {}

-- root to getchildren;
-- placecheck is called on each child -> true? check density
--> move to new position
--> call placefunc with this position + part
function Placer:DoJob(root, density_min, density_max, placecheck, placefunc)	
	local CurrentDensity, NextDensity
	function newdens()
		CurrentDensity = 0
		NextDensity= density_min + math.random() * (density_max - density_min)
	end
	newdens()
	for _, child in pairs(root:GetChildren()) do


		if child:IsA("BasePart") and placecheck(child) then 
			local z = 0
			
			for x = 1, child.Size.x do 
				CurrentDensity = CurrentDensity + child.Size.z
				if CurrentDensity > NextDensity then 
					local goback = CurrentDensity - NextDensity
					local z = child.Size.z - goback
					local start = child.CFrame * CFrame.new(-child.Size.x/2, child.Size.y/2, -child.Size.z/2)
					local pos = start * CFrame.new(x,0,z)
					placefunc(pos.p, child)
					newdens()
				end
			end
			wait()
		end

	end
end

return Placer]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBXc4a4d286e4dd495f952df856f3743c42">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">WorldTools</string>
					<ProtectedString name="Source"><![CDATA[-- World Tools provides a toolkit
-- for "world operations" such as
-- collission checking.

local WorldTools = {}

function WorldTools:IsRoom(Pos, Size) -- both vector3 please
	local BOX = Instance.new("Part", game.Workspace)
	BOX.FormFactor = "Custom"
--	BOX.Transparency = 0
	BOX.CanCollide = true
	BOX.Size = Size
	BOX.Position = Pos
--	wait(1)
	local bool = (BOX.Position - Pos).magnitude < 0.05
	--print(bool)
	BOX:Destroy()
	return bool	
end

function WorldTools:UpdateWeld(part1, part2, c1, c2)
	if part1:FindFirstChild("Weld") then
		part1.Weld:Destroy()
	end
	local Weld = Instance.new("Weld", part1)
	Weld.Name = "Weld"
	Weld.Part0 = part2
	Weld.Part1 = part1
	Weld.C0 = c2:toObjectSpace(c1)
end

return WorldTools]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX9505f78ccd0d479289cc25694b5f1622">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Fruit</string>
					<ProtectedString name="Source"><![CDATA[-- Fruit is a special resource type
-- It has a Grow function
-- Can also be used as vegetables ^_^

-- The Tree Instance will handle all positions;
-- 
local Fruit = {}

Fruit.LastTick = 0
Fruit.Base = nil

-- This fucntion should be user defined
-- It should return a base
function Fruit:GetBase()
	return Instance.new("Part") 
end

-- Fruit doesnt have regular growing patterns
-- This function should also be user provided
-- This whole class is user defined ._.

function Fruit:GrowBase(dt)
	
	
end

-- the dt argument is delta time since last
-- intern clock is provided and used when dt is nil
function Fruit:Grow(dt)
	local dt = dt or (tick() - self.LastTick)
	self:GrowBase(dt)
	self.LastTick = tick()	
end



return Fruit]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBXb2e744d06297429eb0250dedfb7239f9">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Tree</string>
					<ProtectedString name="Source"><![CDATA[local Tree = {}

-- New trees. Simple, have limitions;
-- No branch spawning! Branch finding should be done via shaking trees.
-- (this action also drops all fruit which *could* be hidden in the tree)
-- Foliage should be CanCollide once dropped
-- Trunk cannot be cut in half directly: first cut completely 
-- This also destroys the tree! 
-- Foliage has the option to regrow - for future season additions!

local WorldTools = Instinct.Include "World/WorldTools"

Tree.Trunk = Instance.new("Part")
Tree.Trunk.BrickColor = BrickColor.new "Brown"
Tree.Trunk.Material = "Wood"
Tree.Trunk.TopSurface = "Smooth"
Tree.Trunk.BottomSurface = "Smooth"
Tree.Trunk.FormFactor = "Custom"
Tree.Trunk.Name = "Wood"
--Instance.new("BlockMesh", Tree.Trunk)

Tree.TrunkFormMin = Vector3.new(0.15,1,0.15)
Tree.TrunkFormMax = Vector3.new(0.25,1,0.25)

Tree.FoliageFormMin = Vector3.new(2.5,1,2.5)
Tree.FoliageFormMax = Vector3.new(4,1,4)

Tree.SaplingHeight = 1 -- oh so cute
Tree.MinHeight = 18
Tree.MaxHeight = 32

Tree.GrowTimeMin = 300
Tree.GrowTimeMax = 600

-- TrunkForm and FoliageForm are set on init

Tree.BottomFoliagePortion = 0.5 -- Thsi is relative to the MIDDLE
Tree.MiddleFoliagePortion = 0.25  -- This is relative to the TRUNK
Tree.TopFoliagePortion = 0.5 -- This is relative to the MIDDLE

Tree.Foliage = Instance.new("Part")
Tree.Foliage.BrickColor = BrickColor.new "Bright green"

Tree.AvailableFoliageColors = {
	BrickColor.new "Bright green",
	BrickColor.new "Earth green",
	BrickColor.new "Medium green",
	BrickColor.new "Grime"
}

Tree.AvailableTrunkColors = {
	BrickColor.new "Brown",
	BrickColor.new "Reddish brown"
}

Tree.Foliage.Material = "Grass"
Tree.Foliage.TopSurface = "Smooth"
Tree.Foliage.BottomSurface = "Smooth"
Tree.Foliage.FormFactor = "Custom"
Tree.Foliage.Name = "Foliage"

Tree.Fruit = Instance.new("Part")
Tree.Fruit.BrickColor = BrickColor.Red() 
Tree.Fruit.TopSurface = "Smooth"
Tree.Fruit.BottomSurface = "Smooth"
Tree.Fruit.FormFactor = "Custom"
Tree.Fruit.Name = "Apple"
local mesh = Instance.new("SpecialMesh", Tree.Fruit)
mesh.MeshType = "Sphere"

Tree.FruitTargetSize = Vector3.new(1,1,1)
Tree.MaxFruit = 5
Tree.MinimalFoliageFruitSize = 10 -- as magnitude
-- fruit welds do not update so fruit will "dissapear" 

Tree.RoomNeeded = Vector3.new(1,1,1)

function Tree:UpdateWeld(part1, part2, c1, c2)
	if part1:FindFirstChild("Weld") then
		part1.Weld:Destroy()
	end
	local Weld = Instance.new("Weld", part1)
	Weld.Name = "Weld"
	Weld.Part0 = part2
	Weld.Part1 = part1
	Weld.C0 = c2:toObjectSpace(c1)
end

function Tree:InitializeFoliage()
	-- Find all foliages which we dont have
	if not self.MiddleFoliage or self.MiddleFoliage.Parent ~= self.TreeBase then 
		local wanted_height = self.SaplingHeight * self.MiddleFoliagePortion
		local size = self.FoliageForm * wanted_height
		local new = self.Foliage:Clone()
		new.Size = size
		new.Parent = self.TreeBase
		new.CFrame = self.TreeBase.CFrame * CFrame.new(0, self.TreeBase.Size.y/2, 0)
		self:UpdateWeld(new, self.TreeBase, new.CFrame, self.TreeBase.CFrame)
		self.MiddleFoliage = new
		self.MiddleFoliageTime = tick()
	end
	if not self.TopFoliage or self.TopFoliage.Parent ~= self.TreeBase then 
		local wanted_height =  self.SaplingHeight * self.MiddleFoliagePortion * self.TopFoliagePortion
		local size = self.FoliageForm * wanted_height
		local new = self.Foliage:Clone()
		new.Size = size
		new.Parent = self.TreeBase
		new.CFrame = self.MiddleFoliage.CFrame * CFrame.new(0, self.MiddleFoliage.Size.y/2, 0) * CFrame.new(0, new.Size.y/2, 0)
		self:UpdateWeld(new, self.TreeBase, new.CFrame, self.TreeBase.CFrame)
		self.TopFoliage = new
		self.TopFoliageTime = tick()
	end
	if not self.BottomFoliage or self.BottomFoliage.Parent ~= self.TreeBase then 
		local wanted_height =  self.SaplingHeight * self.MiddleFoliagePortion * self.BottomFoliagePortion
		local size = self.FoliageForm * wanted_height
		local new = self.Foliage:Clone()
		new.Size = size
		new.Parent = self.TreeBase
		new.CFrame = self.MiddleFoliage.CFrame * CFrame.new(0, -self.MiddleFoliage.Size.y/2, 0) * CFrame.new(0, -new.Size.y/2, 0)
		self:UpdateWeld(new, self.TreeBase, new.CFrame, self.TreeBase.CFrame)
		self.BottomFoliage = new
		self.BottomFoliageTime = tick()
	end
end

function Tree:UpdateFoliage()
	local function mvfruit(part,ds)
		for i,v in pairs(part:GetChildren()) do
			if v.Name == self.Fruit.Name then
				local g1, g2 = self.FruitTicks[v][2], self.FruitTicks[v][3]
				local newcf = self:GetFruitPositionFromOffset(part, g1, g2)
				v.CFrame = CFrame.new(newcf)
				self:UpdateWeld(v, part,v.CFrame, part.CFrame)
			end
		end
	end
	-- Middle
	local wanted_height = self.WantedHeight * self.MiddleFoliagePortion
	local new_height = self:GetNewHeight(tick() - self.MiddleFoliageTime, wanted_height)
	if new_height > self.MiddleFoliage.Size.y then 
		local size = self.FoliageForm * new_height
		local new = self.MiddleFoliage
		local ds = (size - new.Size)/2
		new.Size = size
		new.CFrame = self.TreeBase.CFrame * CFrame.new(0, self.TreeBase.Size.y/2, 0)
		self:UpdateWeld(new, self.TreeBase, new.CFrame, self.TreeBase.CFrame)
		mvfruit(new, ds)
	end
	
	-- Top
	local wh =  wanted_height * self.TopFoliagePortion
	local new_height = self:GetNewHeight(tick() - self.TopFoliageTime, wh)
	if new_height > self.TopFoliage.Size.y then 
		local size = self.FoliageForm * new_height
		local new = self.TopFoliage
		local ds = (size - new.Size)/2
		new.Size = size
		new.CFrame = self.MiddleFoliage.CFrame * CFrame.new(0, self.MiddleFoliage.Size.y/2, 0) * CFrame.new(0, new.Size.y/2, 0)
		self:UpdateWeld(new, self.TreeBase, new.CFrame, self.TreeBase.CFrame)
		mvfruit(new, ds)
	end

	-- Bottom
	local wh =  wanted_height * self.BottomFoliagePortion
	local new_height = self:GetNewHeight(tick() - self.BottomFoliageTime, wh)
	if new_height > self.BottomFoliage.Size.y then 
		local size = self.FoliageForm * new_height
		local new = self.BottomFoliage
		local ds = (size - new.Size)/2
		new.Size = size
		new.CFrame = self.MiddleFoliage.CFrame * CFrame.new(0, -self.MiddleFoliage.Size.y/2, 0) * CFrame.new(0, -new.Size.y/2, 0)
		self:UpdateWeld(new, self.TreeBase, new.CFrame, self.TreeBase.CFrame)
		mvfruit(new, ds)
	end
end

function Tree:GetRandomVector(min,max)
	-- height is 1
	local dx, dz = (max.x - min.x), (max.z - min.z)
	return Vector3.new(min.x + dx*math.random(), 1, min.z + dz * math.random())
end

-- returns a random position under the part
function Tree:GetFruitPosition(part)
	local delta = part.Size
	local function get() 
		local x = math.random() - 0.5
		if x > 0 then 
			return (x + 0.5) * 0.5
		else
			return (x - 0.5) * 0.5
		end
	end
	local get_1 = get()
	local get_2 = get()
	local x,y,z = get_1 * delta.x, -0.5 * delta.y, get_2 * delta.z
	return (part.CFrame * CFrame.new(Vector3.new(x,y,z))).p, get_1, get_2
end

function Tree:GetFruitPositionFromOffset(part, g1, g2)
	local size = part.Size
	local x,y,z = g1 * size.x, -0.5 * size.y, g2 * size.z
	return (part.CFrame * CFrame.new(Vector3.new(x,y,z))).p
end

function Tree:GetFruitCount()
	local out = 0
	for i,v in pairs(self.TreeBase:GetChildren()) do
		for ind, val in pairs(v:GetChildren()) do
			if val.Name == self.Fruit.Name then
				out = out + 1
			end
		end
	end
	return out
end

function Tree:InitializeFruit()
	local make = self.WantedFruit - self:GetFruitCount()
	if make > 0 then 
		for i,v in pairs(self.FruitTicks) do
			if not i:IsDescendantOf(self.TreeBase) then 
				self.FruitTicks[i] = nil
			end
		end
	
		for i = 1, make do 
			local parts = {self.TopFoliage, self.MiddleFoliage, self.BottomFoliage}
			local rem = {}
			for i,v in pairs(parts) do
				if v.Size.magnitude <  self.MinimalFoliageFruitSize then 
					parts[i] = nil
				end
			end
			local temp = {}
			for i,v in pairs(parts) do
				table.insert(temp,v)
			end
			parts=temp
			if #parts > 0 then 

				local new = self.Fruit:Clone()
				new.Size = Vector3.new(0.2,0.2,0.2)
				local part = parts[math.random(1,#parts)]
				local offset, g1,g2 = self:GetFruitPosition(part)
				self.FruitTicks[new] = {tick(), g1,g2}
				new.Parent = part
				new.CFrame = CFrame.new(offset)
			
				self:UpdateWeld(new,part,new.CFrame,part.CFrame)
			end
		end

	
	end
end

function Tree:UpdateFruit()
	for fruit,lasttick in pairs(self.FruitTicks) do
		local newh = self:GetNewHeight(tick() - lasttick[1], self.FruitTargetSize.y)
		if newh > fruit.Size.y then
			local oldcf = fruit.CFrame
			fruit.Size = newh * self.FruitTargetSize
			fruit.CFrame =oldcf
			self:UpdateWeld(fruit, fruit.Parent, oldcf, fruit.Parent.CFrame)
		end
	end
end

function Tree:Initialize(Position, Ground)
	local IsRoom = WorldTools:IsRoom(Position + Vector3.new(0,self.RoomNeeded.y/2,0), self.RoomNeeded)
	if IsRoom then 
		self.LastTick = tick()
		self.Ground = Ground		
		self.GroundPos = Position
		
		-- Colors;
		local ft, tt = self.AvailableFoliageColors, self.AvailableTrunkColors
		local fc, tc = ft[math.random(1, #ft)], tt[math.random(1,#tt)]
		
		self.Foliage.BrickColor = fc 
		self.Trunk.BrickColor = tc
		
		-- Generate the look of the tree!
		self.FoliageForm = self:GetRandomVector(self.FoliageFormMin, self.FoliageFormMax)
		self.FoliageForm = Vector3.new(self.FoliageForm.x, self.FoliageForm.y, self.FoliageForm.x)
		self.TrunkForm = self:GetRandomVector(self.TrunkFormMin, self.TrunkFormMax)
		self.WantedHeight = self.MinHeight + math.random() * (self.MaxHeight - self.MinHeight)
		
		self.WantedFruit = math.random(1, self.MaxFruit)		
		
		self.FruitTicks = {}
		
		self.GrowTime = self.GrowTimeMin + math.random() * (self.GrowTimeMax - self.GrowTimeMin)		
		-- Let's incoroporate some animal crossing elements: shake trees!		
		
		-- Create the base size!
				
		local NewTrunk = self.Trunk:Clone()
		self.TreeBase = NewTrunk
		self.StartTime = tick()
		NewTrunk.Parent = game.Workspace.Life
		NewTrunk.Size = self.SaplingHeight * self.TrunkForm
		self.TrunkRotation = math.random(1,360)
		NewTrunk.CFrame = CFrame.new(Position) * CFrame.new(0,NewTrunk.Size.y/2,0) * CFrame.Angles(0, math.rad(self.TrunkRotation), 0) -- oh so hipster
		self:UpdateWeld(NewTrunk, Ground, NewTrunk.CFrame, Ground.CFrame)
		self:InitializeFoliage()
		self:InitializeFruit()
	end
	return IsRoom
end

function Tree:GetNewHeight(dt,max)
	-- returns the new height
	local portion = dt/self.GrowTime
	if portion >= 1 then return max end
	-- now ease...
	local ease = (-1 * ((portion-1)^2)) + 1
	return ease * max
end



-- Grows a tick.
function Tree:Grow() 
	-- Update the branch!
	if not self.TreeBase or self.TreeBase.Parent ~= game.Workspace.Life or self.Disabled then 
		return false -- If false is returned DESTROY
	end
	local NewHeight = self:GetNewHeight(tick() - self.StartTime, self.WantedHeight)
	if NewHeight > self.TreeBase.Size.y then 
		local dy = NewHeight - self.TreeBase.Size.y 
		self.TreeBase.Size = NewHeight * self.TrunkForm
		self.TreeBase.CFrame = CFrame.new(self.GroundPos) * CFrame.new(0,  self.TreeBase.Size.y/2, 0)  * CFrame.Angles(0, math.rad(self.TrunkRotation), 0)
		self:UpdateWeld(self.TreeBase, self.Ground, self.TreeBase.CFrame, self.Ground.CFrame)
	end
	self:InitializeFoliage()
	self:UpdateFoliage()
	self:InitializeFruit()
	self:UpdateFruit()
	self.LastTick = tick()
	return true
end

function Tree:Generate()

	self.StartTime = 0
	self.MiddleFoliageTime = 0
	self.TopFoliageTime = 0
	self.BottomFoliageTime = 0

	self:Grow()
	for i,v in pairs(self.FruitTicks) do
		v[1] = 0
	end
	self:UpdateFruit()
end


return Tree]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBXb4998bf9f43a4cdb984b3bba4c459577">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Mine</string>
					<ProtectedString name="Source"><![CDATA[local Mine = {}

Instinct.Include "Utilities/Random"

Mine.OtherStoneSpawningChance = 1/100
Mine.OtherOreSpawnChance = 1/100
Mine.OreChance = 1/40
Mine.GroundOreChance = 1/5
Mine.OreBoostMultiplier = 6

function Mine:GetStone(height, stonetype)
	local selected = stonetype or Instinct.Option.StoneType.General
	if height then 
		local height = height - (height % 8) - 24
		local my = -math.huge
		local standard = Instinct.Option.StoneType.General
		for i,v in pairs(self.Heights) do 
			if height < v[2] then 
				standard = v[1]
			end
		end
	end

	local Stones = _G.StoneData.StonesInStoneType[selected]
	local NonNativeStones = {}
	for i,v in pairs(_G.StoneData.StonesInStoneType) do 
		if i ~= selected then
			for _, stone in pairs(v) do 
				table.insert(NonNativeStones, stone)
			end
		end
	end
	local randomroulette = {}
	local function scan(t, multiplier)
		for i,v in pairs(t) do
		
			randomroulette[v.Name] = v.Rarity * multiplier
		end
	end
	scan(Stones, 1)
	scan(NonNativeStones, self.OtherStoneSpawningChance)

	local stone = Instinct.Utilities.Random:FromWeightsTable(randomroulette)
	local t =  game.ServerStorage.Mining[stone]:Clone()
	t.Anchored = true
	return t
end

function Mine:GetOre(voxel)
-- Create a RandomRoulette table
	local Ores = _G.OreData
	local Stone = _G.StoneData[voxel.Name]

	--warn(Stone)
	if Stone then 
		local OreBooster = Stone.OreBoost
		local StoneType = Stone.StoneType
		local native_ores = {}
		local non_native_ores = {}
		local t = {}
		for i,v in pairs(Ores) do
			if i ~= "OresInStoneType" then
				table.insert(t,v)
			end
		end
		--OLDPRINT("ORELEN", #t)
		for i,v in pairs(t) do
		--	OLDPRINT(v.Name, v.StoneType == StoneType, "hi") 
			if v.StoneType == StoneType or v.StoneType == Instinct.Option.StoneType.All then 
				table.insert(native_ores, v)
			else
				table.insert(non_native_ores, v)
			end
		end
		local randtable = {}
		function scan(tab, mul)
			for i,v in pairs(tab) do 
				
				if v.Name == OreBooster then 
					randtable[v.Name] = v.Rarity * self.OreBoostMultiplier * mul
				else
					randtable[v.Name] = v.Rarity * mul
				end
				
			end
		end
		scan(native_ores, 1)
		scan(non_native_ores, self.OtherOreSpawnChance)
	--	OLDPRINT("WEIGHT DUMP")
	--	OLDPRINT("VOXEL NAME: " .. voxel.Name)
		local x = {}
		for i,v in pairs(randtable) do 
			table.insert(x, {i,v})
		end
		table.sort(x, function(a,b) return a[2] > b[2] end)
		for i,v in pairs(x) do 
			--OLDPRINT(v[1], v[2])
		end
		local rr = Instinct.Utilities.Random:FromWeightsTable(randtable)
		--OLDPRINT("OREG",rr)
		local clone = game.ServerStorage.Ores:FindFirstChild(rr)
		--warn(rr)
		if clone then
			local new = clone:Clone()
			local ret
			local function mux()
				if ret then return ret end
				ret = (math.sqrt(0.5) + math.random() * (1-math.sqrt(0.5)))^2 -- guarantees square ores
				return ret
			end
			new.FormFactor = "Custom"
			new.Size = Vector3.new(mux(),mux(),mux())
			return new
		end
	end
end

return Mine]]></ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="Model" referent="RBXc016de10d14647ca8c10ff9e7ad8cb4d">
			<Properties>
				<CoordinateFrame name="ModelInPrimary">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<string name="Name">Action</string>
				<Ref name="PrimaryPart">null</Ref>
			</Properties>
			<Item class="Script" referent="RBX81c0b17770444eb299fae5df61d23b7d">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ObjectService</string>
					<ProtectedString name="Source"><![CDATA[lolwat
print 'Hello world!'
]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX6aaf161a7f1247aea8897fcd88e13f35">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">CreationService</string>
					<ProtectedString name="Source"><![CDATA[local CreationService = {}

local Object = Instinct.Include "Action/Object"
local ObjectService = Instinct.Include "Services/ObjectService"

function CreationService:Create(UsageList, Recipe)

end 

CreationService.CodeMap = {
	[1] = "The recipe can only be created in one way: no leftovers",
	[2] = "The recipe has more ways to be created (more ingredient names)",
	[3] = "The recipe has only one way to be created in terms of the name of the ingredients, however, there are leftovers. This should be harmless in most cases, except if some items are better than one another.",
}

function CreationService:GetStatusInfo(code)
	return self.CodeMap[code] or "no info found on this status code"
end 

function CreationService:DeleteFromUsageListIfExist(NOKLIST, used, IfExist)
	if NOKLIST[IfExist] then 
		for UseName, Data in pairs(used) do 
			print("usename", UseName)
			for RealName, List in pairs(Data) do 
				print("rn", Realname)
				if type(List) == "table" then 
					for i, ActualItem in ipairs(List) do 
						print("World has to delete " .. RealName .. " from the world as there is not Metal Container available!!")
					end
				end
			end 
		end 
	end
end 


-- figures out if there is only one way to create the item, (1)
-- or more ways (2)
-- or, more ways, but no other objnames found (3) (in most cases this results in a good output, so this could lead to same behaviour as with (1) )
-- returns a list for every IngredientName which could be created

-- listobjects = {o = sizeused}

-- name = {listobjects, OnlyOneName = false/true, LeftOvers = 0}
-- name = {objname1 = {listobjects}, objname2 = {listobjects}}

-- in the last case the "same" rule is applied
-- for instance, use the same types of wood
-- then let user chose which wood;
-- for 

function CreationService:CanCreateImmediate(UsageList, Recipe)
	local out = {} 
	local HasMoreNames = false 
	local HasLeftoverResources = false 

	print("Checking for CCI ")

	local skip = {
		AmountNeeded = true, 
	}

	for IngredientName, IData in pairs(UsageList) do 
		--hastobesame
		local HTBS = Recipe.Ingredients[IngredientName].Same
		local VCheck = Recipe.Ingredients[IngredientName].AmountType == "Volume"
		local need = IData.AmountNeeded
		local current = 0 
		local leftovers = 0 -- amount leftover
		local use = {}
		local puse = use 
		local got = false 
		local ing = 0 
		print("chk", IngredientName)
		out[IngredientName] = use
		for IName, IOtherData in pairs(IData) do 
			print("check variation", IName, IngredientName)
			if not skip[IName] then 
				print(IName)
				ing = ing + 1
				if HTBS then 
					current = 0 
					use[IName] = {}
					puse = use[IName]
					got = false 
					leftovers = 0
				end  
				puse.LeftoverAmount = 0
				for i, RBXInstance in pairs(IOtherData) do 
					print(i)
					if type(i) == "number" then 
						local cvol = 1 
						if VCheck then 
							cvol = ObjectService:GetVolume(RBXInstance)
							current = current + cvol 
						else 
							current = current + 1
						end 			

						if current >= need then 	

							if not got then 
								leftovers = leftovers + current - need 
								got = true 
							else 
								print(need, current, "HL")
								leftovers = leftovers + cvol 
								HasLeftoverResources = true 
								puse.LeftoverAmount = puse.LeftoverAmount + 1 
							end 
						end 
					end 
					table.insert(puse, {RBXInstance, cvol})
				end 

				puse.LeftOvers = leftovers
				use.MoreTypes = ing > 1 
				HasMoreNames = HasMoreNames or ing > 1
			end
		end 
		use.Needed = need 
	end 
	-- well lets return a status then
	local status = 1 
	if HasMoreNames then 
		status = 2 
	elseif HasLeftoverResources then 
		status = 3 
	end 
	return use, status 
end


return CreationService ]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX8b64a070e0a946f5b4af171d96ea1db6">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">FireService</string>
					<ProtectedString name="Source"><![CDATA[-- FireService

local ObjectService = require "Services/ObjectService"
local Object = require "Action/Object"

local FireService = {}

local function tick()
	if game then 
	else 
		tick=os.clock()
	end 
end 

function FireService:GetEnvironmentTemperature(root)
	return 20 
end 

function FireService:Light(inst, plust, spark)
	local o = ObjectService:GetObject(inst.Name)
	if o then 
		if o:HasConstant("Lighteable", true) then 
			local bt = o:GetConstant("BurnTemperature")
			if not bt then 
				print("no burn temp found")
				return 
			end 
			if spark and o:HasConstant("Sparkable", true) then 
				o:SetContext("Temperature", bt)
				o:SetContext("Lit", tick() )
			elseif plust then 
				local lt = o:GetConstant("LightTemperature")
				if lt then 
					local nt = o:GetContext(inst, "Temperature") or 20
					if nt then 
						
						if nt + plust > lt then 
							o:SetContext(inst, "Temperature", bt)
							o:SetContext(inst, "Lit", tick())
						else 
							o:SetContext(inst, "Temperature", nt  + plust)
						end 
					end 
				end 
			end 
		end 
	end 
end 

-- returns fuel with the highest temperature
function FireService:GetFuel(root)
	local max = 0
	local found 
	local fuels = {}
	for i,v in pairs(root:GetChildren()) do 
		if ObjectService:IsResource(v) then 
			local o = ObjectService:GetObject(v.Name)
			if o:GetConstant("IsFuel") and o:GetProperty(v, "Lit") then 
				local t = o:GetProperty(v, "Temperature")
				if t > max then 
					max=t 
					found = v 
				end 
			elseif o:GetConstant("IsFuel") then 
				table.insert(fuels,v)
			end 
		end 
	end 
	if found then 
		for i,v in pairs(fuels) do 
			if Object:SetProperty(v, )
		return vfound,max 
	end 
end 

-- root is a root entity, this contains the ingredients
-- this doesnt have to be a building
-- note: only suitable for buildings with range == 0 for ings.
function FireService:HandleRoot(root)
	local tmul = 1
	local dt = tick() - (Object:GetContext(root, "LastCheck") or (tick() - 1))
	local remt = dt 
	Object:SetContext(root, "LastCheck", tick())
	local bb = Object:GetContext(root, "BurnBoost")
	if bb then 
		remt = dt * bb
		if tmul < bb then 
			tmul = bb 
		end 
		local be = Object:GetContext(root, "BurnBoostTime")
		if be then 
			Object:SetContext(root, "BurnBoostTime", be-dt)
			if be-dt <= 0 then
				Object:RemoveContext(root, "BurnBoost")
				Object:RemoveContext(root, "BurnBoostTime")
			end 
		end 
	end 
	local envt = self:GetEnvironmentTemperature(root)
	local fuel 
	-- first get fuel

	local fuel, ft  = self:GetFuel(root)

	for i,v in pairs(root:GetChildren()) do 
		if ObjectService:IsResource(v) then 
			local t = Object:GetContext(v, "Temperature") or envt 

			if fuel then 
				-- very sipmle 
				if t < ft and not v == fuel then 
					t = t + 1 * dt 
				end 
			elseif t < envt then 
				t = t - 1 * dt 
			end 
		end 
	end 


end 

return FireService]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBXf5f6dd2a562e40668b26492793c94b02">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Object</string>
					<ProtectedString name="Source"><![CDATA[-- An object is a very abstract class
-- It holds info on game objects
-- Game objects are anything;
--> Tools
--> Resources
--> Buildings

--> WARNING
--> DO NOT CREATE NEW OBJECTS FOR EVERY ROBLOX INSTANCE
--> THE OBJECT INSTINCT INSTANCE SHOULD BE USED
--> TO LOOK UP INFO ON THE OBJECT CONTEXT

-- context and properties are basically the same
-- easire to branch between 

-- NOTE
-- For some objects we want a general "object"
-- such as a Crucible
-- but multiple "tiers" of it
-- ex: Bronze Crucible
-- In order to manage to do this use the following:
--> The in game identifier should be Crucible
--> A context variable should be set: the tier
--> This is of course derived from the bronze "object"
--> Which is a helper object to figure out the properties for
-- bronze
--> The in game name should be stored in a variable to 
-- make sure it shows correctly on GUIs

print('require')

local printm=print
local throwt =print
local throw=print

local Object = {}

local ObjectService = Instinct.Include( "Services/ObjectService" )

Object.ContextName = "contextinfo"
Object.InfoClassName = "Configuration"

-- ExtendedBy: 
--> string (extend one object)
--> table (extend more objects)

Object.ExtendedBy = nil 

function Object:CreateExtension(name)
	if self.Name ~= "Object" then 
		local new = Instinct.Create(self)
		new.ExtendedBy = self.Name 
		new.Name = name or "Object"
		return new 
	else 
		throw "rename object first"
	end
end 

local IsServer = _G.__InstinctPresets.LoadType == "Server"
local IsTerm = _G.__InstinctPresets.LoadType == "term"

-- We will first define some helper functions
-- These make an easy Instinct <-> Roblox transition

function Object:SetPropertyCat(Inst, PropertyName, Value, Cat)
	if Inst:FindFirstChild(Cat) == nil then 
		if IsServer then 
			-- Okay to create
			local new = Instance.new(self.InfoClassName, Inst)
			new.Name = Cat
		elseif IsTerm then 
			local new = Instinct.Local.rbxinstance:new(self.InfoClassName)
			new.Name = Cat
			new:SetParent(Instance)
		else 
			throw("No server contact rule defined yet - no action taken")
			return 1
		end
	end	

	local typeof = type(Value)
	local make
	if typeof == "number" then 
		make = "NumberValue"
	elseif typeof == "string" then 
		make = "StringValue"
	elseif typeof == "boolean" then 
		make = "BoolValue"
	end 

	if IsServer and make then 
		local my = Inst[Cat]:FindFirstChild(PropertyName)
		if not my then
			my = Instance.new(make, Inst[Cat])
		end
		my.Value = Value 
		my.Name = PropertyName		
	elseif IsTerm and make then 
		local my = Instinct.Local.rbxinstance:new(make)
		my.Name = PropertyName
		my.Value = Value 
		my:SetParent(Instance:FindFirstChild(Cat))
	end
end 

function Object:SetContext(Instance, ContextName, Value)
	self:SetPropertyCat(Instance, ContextName, Value, self.ContextName)
end 

function Object:RemoveContext(Instance,ContextName)
	if Instance:FindFirstChild(self.ContextName) then 
		if Instance:FindFirstChild(self.ContextName):FindFirstChild(ContextName) then 
			Instance[self.ContextName][ContextName]:Destroy()
		end 
	end 
end 

function Object:GetContext(Instance, PropertyName)
	if Instance:FindFirstChild(self.ContextName) then 
		local this = Instance:FindFirstChild(self.ContextName):FindFirstChild(PropertyName)
		if this then 
			return this.Value
		end 
	end
end 

-- lolwat!?
function Object:IsA(what)
	local list = self:GetConstant("Name")
	for i,v in pairs(list) do
		if v == what then
			return true
		end
	end
	return false
end

-- contact objservice to figure out all possible constants
-- returns a table with these constants
-- we must recurse (dammit)
function Object:GetConstant(const)
	ObjectService.ObjectConstants[const] = true
	if not ObjectService.ObjectConstantsDescriptions[const] then
		ObjectService.ObjectConstantsDescriptions[const] = true -- reg for no warn
		warn("No description for: "..const)
	end
	local out = {}
	if self[const] then 
		table.insert(out, self[const])
	end 
	if self.ExtendedBy then 
		if type(self.ExtendedBy) == "string" then 
			local other = ObjectService:GetObject(self.ExtendedBy)
			if not other then 
				throw(self.ExtendedBy .. " is not a valid object")
				return 
			end 
			local data = other:GetConstant(const)
			for _,c in pairs(data) do 
				table.insert(out, c)
			end 
		elseif type(self.ExtendedBy) == "table" then 
			for _, obj in pairs(self.ExtendedBy) do 
				local other = ObjectService:GetObject(obj)
				local data = other:GetData(const) 
				for _,c in pairs(data) do 
					table.insert(out, c)
				end 
			end 
		end 
	end 
	return out 
end 

-- figures out if the object has a ceratin constant 
function Object:HasConstant(const, val)
	-- figuring out if value is ok
--	printm("Object", "info", "checking for constant " .. const )
	local values = self:GetConstant(const)
	for _, value in pairs(values) do 
		if value == val then 
			return true 
		end 
	end 
	return false 
end 

-- returns list table which recsued

function Object:GetRecursedList(name)
	local c = self
	local rules = {}
	function chk(obj)
		if obj[name] then
			for _, rulename in pairs(obj[name]) do
				rules[rulename]=true
			end
		end
		if obj.ExtendedBy then
			if type(obj.ExtendedBy) == "string" and ObjectService:GetObject(obj.ExtendedBy) then
				chk(ObjectService:GetObject(obj.ExtendedBy))
			elseif type(obj.ExtendedBy) == "table" then
				for _, oname in pairs(self.ExtendedBy) do
					if ObjectService:GetObject(oname) then
						chk(ObjectService:GetObject(oname))
					end
				end
			end
		end		
		
	end	
	chk(self)
	local out = {}
	for i in pairs(rules) do
		table.insert(out,i)
	end
	return out
end

-- returns a list of all items which have to be saved
-- traverses complete extend road
function Object:GetSaveDataList()
	return self:GetRecursedList("SaveDataList")
end

function Object:GetMoveDataList()
	return self:GetRecursedList("MoveRuleList")
end

return Object]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBXdd77c227f6c04686b075da9545cd6f98">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Property</string>
					<ProtectedString name="Source"><![CDATA[-- Property provides a small context helper class
-- It can be used to serialize properties!

local Property = {}

Property.Type = "string" 
Property.Supported = {
	string=true,
	Vector3=false
}

Property.Mode = {
	Constant = true, -- No copy! 
	ShowInfo = false, -- show on tooltips?
}

local meta = {__index=Property.Mode, __newindex = function(tab,ind,val) 		
	
	if Property.Mode[ind] == nil then -- EXPLICIT for nil! otherwise false will troll 	
		warn(ind.. " is not a valid value")
		return
	end 
	rawset(tab,ind,val)
end}

function Property:Constructor()
	self.Mode = setmetatable({}, meta)
end

function Property:Serialize(value)
	if not self.Supported[self.Type] then 
		throw("Serializing of " .. self.Type .. " is not suppored")
	end 
	if self.Type == "string" then
		return value 
	end 
end 

return Property]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBXc6e32b0b84014e4f9bf45841c3966d98">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Recipe</string>
					<ProtectedString name="Source"><![CDATA[local Recipe = {} 

local RecipeService = Instinct.Include "Services/RecipeService"

Recipe.Category = "Creation"
Recipe.Context = {}
Recipe.Ingredients = {}

function Recipe:SetCategory(cat) 
	if RecipeService.Categories[cat] then 
		self.Category = cat 
	else 
		throw(cat .. " is not a valid category, register this first on RecipeService")
	end 
end 

function Recipe:CheckRecipe(Context, List)
	if Context and List then 
		return RecipeService:CheckRecipe(self, Context, List), 0
	else 
		if not Context then 
			throw("no context provided")
			return false, 1 
		end 
		if not List then 
			throw("no recipe list provided")
			return false, 2 
		end 
	end
end

return Recipe ]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX896badc46d9946c4a6635ca414ffea85">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Context</string>
					<ProtectedString name="Source"><![CDATA[-- A helper class to setup a valid context

local ObjectService = Instinct.Include "Services/ObjectService"

local Context = {}

function Context:SetLocation(rbxinstance)
	local o = ObjectService:GetObject(rbxinstance.Name)
	if o then 
		self.Location = o 
		self.RBXLocation = rbxinstance
	else 
		
		throw(rbxinstance.Name .. " obj not available")
	end 
end

return Context




]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBXd9790fdb74dd4f59a1d9b1d4e627b73e">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Tool</string>
					<ProtectedString name="Source"><![CDATA[local Tool = {}

-- ! adding useful properties? add them to cpy list too. (in delegate function)

Tool.Grip = nil -- cf

Tool.IsEquipped = false
Tool.Hand = "Left"
Tool.Hotkey = 1
Tool.Type = "Normal"

function Tool:Constructor()
	self.Equipped = Instinct.Create(Instinct.Event)
	self.Unequipped = Instinct.Create(Instinct.Event)
	self.HotkeyChanged = Instinct.Create(Instinct.Event)
	self.IsEquipped = false
--	self:CreateWelds()
end

function Tool:UpdateWeld(part1, part2, c1, c2)
	if part1:FindFirstChild("Weld") then
		part1.Weld:Destroy()
	end
	local Weld = Instance.new("Weld", part1)
	Weld.Name = "Weld"
	Weld.Part0 = part2
	Weld.Part1 = part1
	Weld.C0 = c2:toObjectSpace(c1)
end

function Tool:Transform(part)
	print('transform', part.Name)
	part.CanCollide = false
	part.Anchored = false
end

function Tool:CreateWelds(root, weld_to, grip, dontweldtoroot)
	local hand = hand
	local handle = root
--	handle.Parent = game.Workspace
	if not root then return end
	local mainpart = root


	for i,v in pairs(mainpart:GetChildren()) do
		if v:IsA("BasePart") and v ~= mainpart then
			self:UpdateWeld(v, mainpart, v.CFrame, mainpart.CFrame)
			if not dontweldtoroot then
				self:Transform(v)
			end
		end
	end
	if not dontweldtoroot and mainpart:IsA("BasePart") then
		self:Transform(mainpart)
	end
	local Weld
	if not dontweldtoroot then
		Weld = Instance.new("Weld", weld_to)
		Weld.Name = "Weld"
		Weld.Part1 = weld_to
		Weld.Part0 = mainpart
		Weld.C1 = grip or CFrame.new()
		Weld.C0 = CFrame.new()
	end
	return 
end

function Tool:GetGrip()
	return self.Grip
end

function Tool:Equip()
	if Instinct.Communicator then
		
		Instinct.Communicator:Send("EquipTool", self.Tool, self.Hand, self:GetGrip())
	end
	if self.OnEquip then
		self:OnEquip()
	end
	--self.Equipped:fire()
end

function Tool:Unequip()
	if Instinct.Communicator then
		Instinct.Communicator:Send("UnequipTool", self.Tool)
	end
	if self.OnUnequip then
		self:OnUnequip()
	end
end

function Tool:CacheAction()
	-- figure out if we can do action, should return a string indication what it is
end

function Tool:GetDelegate()
	return setmetatable({}, {__index=self})
end

return Tool]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX25cdc02c4a6847a4893e55b191191adc">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ToolService</string>
					<ProtectedString name="Source"><![CDATA[local ToolService = {}

function ToolService:Constructor()
	self.ToolEquipped = Instinct.Create(Instinct.Event)
end

function ToolService:EquipTool(tool)
	if tool.Hand == "Left" then
		tool.OtherEquipped = self.Right
	elseif tool.Hand == "Right" then
		tool.OtherEquipped = self.Left
	else
		warn("no hand set")
		return
	end 
	tool:Equip()
	self.ToolEquipped:fire(tool)
end


return ToolService]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX1cc22284fbc44301a89bebdfe95a2820">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Knapping</string>
					<ProtectedString name="Source"><![CDATA[-- Knapping function



local Knapping = {}

Knapping.Patterns = {
	Knife = {
		{false, false, false, false, false	},
		{false, false, false, false, false},
		{true, true, true, true, true},
		{true, true, true, true, false},
		{false, false, false, false, false}
	},
	Pickaxe = {
		{false, false, false, false, false},
		{false, true, true, true, false},
		{true, false, false, false, true},
		{false, false, false, false, false},
		{false, false, false, false, false},
		
	},
	Axe = {
		{false, false, false, false, true},
		{true, true, true, true, true},
		{true, true, true, true, true},
		{true, true, true, true, true},
		{false, false, false, false, true},
	}
}

function Knapping:Knap(What)
	if self.Knapping then
		self:StopKnap()
	end
	-- block tools
	Instinct.Services.KeyService.State = "Knapping" 
	Instinct.Gui.Chat:PutLocal("Click on the rock to remove a piece. Press z to return. If nothing could be created the stone is lost.")
	self.KeyConnection = Instinct.Services.KeyService.KeyDown:connect(function(key, state)
	--	OLDPRINT("KNAP KEYDOWN", key)
		print(key)
		if key == "m1" or key == "m2" then
			--OLDPRINT(Mouse.Target and Mouse.Target.Parent.Name)
			local Mouse = game.Players.LocalPlayer:GetMouse()
			local Camera = game.Workspace.CurrentCamera
			if Mouse.Target and  Mouse.Target.Parent == Camera:FindFirstChild("Knap") then
				Mouse.Target:Destroy()
			end 
		elseif key == Enum.KeyCode.Z then
			self:StopKnap()
		end
	end)
	local Camera = game.Workspace.CurrentCamera
	self.Knapping = What
	self.KnappingParent = What.Parent
	game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = 0
	self.LastCF = Camera.CoordinateFrame
	self:ConvertToKnapObject(What)
	Camera.CameraType = "Scriptable"
	Camera.CoordinateFrame = CFrame.new(What.Position + Vector3.new(0,5,0), What.Position)
	
end

function Knapping:StopKnap()
	if self.KeyConnection then
		self.KeyConnection:disconnect()
		self.KeyConnection = nil
	end
	local this = game.Workspace.CurrentCamera:FindFirstChild("Knap")
	local didhit = false
	local wrong
	local created
	-- chkcreate
	for createdname, data in pairs(self.Patterns) do
		wrong = false
		created = createdname
		for y, d in pairs(data) do
			for x, val in pairs(d) do
				print(val, this:FindFirstChild(y.."x"..x) ~= nil, x,y)
				if (this:FindFirstChild(y.."x"..x) ~= nil) == val then
					
				else
					if #(this:GetChildren()) ~= 25 then
						didhit = true
					end
					wrong = true
					created=nil
					break
				end 
			end
			if wrong then
				created=nil
				break
			end
			if created then
				--break
			end
		end
		if created then break end
	end

	
	if created then
		Instinct.Communicator:Send("CreateKnap", self.Knapping, created)
	end
	
	if didhit then
		Instinct.Communicator:Send("DestroyResource", self.Knapping, "KnappingError")
	end	
	
	game.Players.LocalPlayer.Character.Humanoid.WalkSpeed=16
	Instinct.Services.KeyService.State = "Default"
	local Camera = game.Workspace.CurrentCamera
	Camera.CoordinateFrame = self.LastCF
	Camera.CameraType = "Custom"
	if self.Knapping then 
		self.Knapping.Parent = self.KnappingParent
	end
	if Camera:FindFirstChild("Knap") then
		for i,v in pairs(Camera:GetChildren()) do 
			if v.Name == "Knap" then 
				v:Destroy()
			end
		end
	end
	self.Knapping = nil
	self.KnappingParent = nil
end



function Knapping:ConvertToKnapObject(root)
	root.Parent = nil
	local center = root.CFrame
	local y = root.Position.y
	local Camera = game.Workspace.CurrentCamera
	local temp = Instance.new("Model", Camera)
	temp.Name = "Knap"
	for x = -0.4, 0.4, 0.2 do 
		for z = -0.4, 0.4, 0.2 do
			local new = root:Clone()
			new.FormFactor = "Custom"
			new.Size = Vector3.new(0.2,1,0.2)
			new.Anchored = true
			new.CFrame = CFrame.new(center.x + x, y, center.z + z)
			new.Name = math.abs(((x + 0.6) * 5) - 6) .. "x" .. ((z + 0.6) * 5)
			new.Parent = temp
		end
	end	
end

return Knapping]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX0de6c6224e984d68bb70f58a688dc034">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Mover</string>
					<ProtectedString name="Source"><![CDATA[local Mover = {}

local KeyService = Instinct.Include "Services/KeyService"

local Mouse = game.Players.LocalPlayer:GetMouse()

Mover.MoveRoot = nil


Mover.Mode = "Nothing" 

Mover.CurrentAngles = {
	0,0,0
} -- Angles in RAD

Mover.AngleIncrement = math.pi/4 -- 45 degrees ^_^
Mover.StudIncrement = 1 -- snapper

function Mover:CreateBuilder()
	self.RemConn = {}
	local Gui = game:GetService("ReplicatedStorage").BuildGui:Clone()
	Gui.Parent = game.Players.LocalPlayer.PlayerGui
	local r = Gui.BuildGui.ContentClipper
	self.Gui = Gui
	self.ContentRoot = r	
	-- Connect all events to be very interactive ^_^
	local mv = r.Mode.Contents

	local arrow = mv.Arrow
	self.Arrow = arrow
	
	mv.Handle.MouseButton1Click:connect(function()
		if not self.MoveRoot then return end
		self:ToHandleMode()
		arrow:TweenPosition(UDim2.new(0.05, 0, 0, 35))
	end)
	mv.Resize.MouseButton1Click:connect(function()
		if not self.MoveRoot then return end
		local ok, err = self:CanResize() 
		if ok then 
			self:ToResizeMode()
			arrow:TweenPosition(UDim2.new(0.05, 0, 0, 60))
		else 
			self:SetStatus(err)
		end
	end)	
	mv.Rotate.MouseButton1Click:connect(function()
		if not self.MoveRoot then return end
		self:ToRotateMode()
		arrow:TweenPosition(UDim2.new(0.05, 0, 0,85))
	end)
	mv.Target.MouseButton1Click:connect(function()
		if not self.MoveRoot then return end
		arrow:TweenPosition(UDim2.new(0.05, 0, 0,10))
		self:ToMoveMode()
		
	end)
	-- Snap connections to change GripSnap size
	local sr = r.Snap.Contents.Target
	for i,v in pairs(sr:GetChildren()) do
		if v.Name ~= "Selection" then
			v.MouseButton1Click:connect(function()
				sr.Selection.Text = v.Text
				self.StudIncrement = tonumber(v.Text)
			end)
		end
	end
	-- Rotatoes
	local rr = r.Rotate.Contents.Target
	for i,v in pairs(rr:GetChildren()) do
		if v.Name ~= "Selection" then
			v.MouseButton1Click:connect(function()
				rr.Selection.Text = v.Text
				local num = tonumber(v.Text)
				local part = num/90
				self.AngleIncrement = part * math.pi/2
			end)
		end
	end
	r.Confirm.Contents.Target.MouseButton1Click:connect(function()
		print("CLICKED CONFIRM")
		if self.MoveRoot then
			self:Confirm()
		end
	end)
end

function Mover:CreateMover()
	self.RemConn = {}
end

function Mover:Confirm()
	-- notify server of size,cf
	self:SetStatus("Confirming...")
	local size = self.MoveRoot.Size
	if self.UseSize == size then
		size=nil
	end
	if self.MoverType == "Build" then
		Instinct.Communicator:Ask("Build", self.MoveRoot, self.MoveRoot.CFrame, size)
	elseif self.MoverType == "Move" then
		Instinct.Communicator:Ask("RequestMove", self.MoveRoot, self.MoveRoot.CFrame)
	end
	self:SetStatus("Click a resource to start")
	self.MoveRoot = nil
	self:InitializeActionChange()
end

function Mover:Clicked(m)
	print(m, self.Mode)
	if self.MoveRoot and self.MoverType == "Move" then
		self:Confirm()
		return
	elseif self.MoverType == "Move" then
		return
	end
	if m == "m1" and self.Mode == "Target" then
		self:CancelMovements()
	elseif self.MoveRoot and self.Mode == "Nothing" then
		if self.Arrow then
			self.Arrow:TweenPosition(UDim2.new(0.05, 0, 0, 10))
		end
		self:ToMoveMode()
	end
end

function Mover:DoubleClicked(m)
	-- confirm!
	print("DOUBLE LCIKC", m)
end

function Mover:CancelMovements()
	self.Mode = "Nothing"
	self:InitializeActionChange()
end

-- disown; return;
function Mover:Abort()
	self:CancelMovements()
	self:SetStatus("Cancelling...")
	Instinct.Communicator:Ask("CancelResourceLock", self.MoveRoot)
	self:SetStatus("Click a resource to start")
	self.MoveRoot = nil
end

function Mover:SetStatus(Text)
	if not self.Gui then return end
	self.ContentRoot.Status.Contents.Target.Text=Text
end

function Mover:GetRootCFrame()
	if self.MoveRoot:IsA("Model") then
		-- FAK!
		return self.MoveRoot:GetModelCFrame()
	else
		return self.MoveRoot.CFrame
	end
end

function Mover:GetRootSize()
	if self.MoveRoot:IsA("Model") then
		return self.MoveRoot:GetModelSize()
	else
		return self.MoveRoot.Size
	end
end

function Mover:SetRootCFrame(CF)
	local Player = game.Players.LocalPlayer
	local Char = Player.Character
	if Char then
		if Char:FindFirstChild("Torso") then
			if (Char.Torso.Position - CF.p).magnitude > 20 then
				return
			end
		end
	end	
	
	
	if self.MoveRoot:IsA("Model") then
		local function moveModel(model,targetCFrame)
			for i,v in pairs(model:GetChildren()) do
				if v:IsA("BasePart") then
					v.CFrame=targetCFrame:toWorldSpace(model:GetModelCFrame():toObjectSpace(v.CFrame))
				end
				moveModel(v, targetCFrame)
			end
		end

		moveModel(self.MoveRoot, CF)
	else
		if self.MoveRoot:FindFirstChild("chParent") then
			for i,v in pairs(self.MoveRoot:GetChildren()) do
				if v:IsA("BasePart") and v.Name == "chParent" then
					local weld = v:FindFirstChild("Weld")
					if weld then
						local c0 = weld.C0
						v.CFrame = CF * c0
					end
				end
			end
			self.MoveRoot.CFrame = CF
		else
			self.MoveRoot.CFrame = CF
		end
	end
end

function Mover:SetRootSize(Size)
	local v = Size.x * Size.y * Size.z 
	local mv = self.UseSize.x * self.UseSize.y * self.UseSize.z 
	if v > mv then
		self:SetStatus("The volume of the resize is bigger than the original")
		return false
	end
	if self.MoveRoot:IsA("Model") then
		-- ... wat ... 
		warn("cannot resize models")
		return false
	end
	self.MoveRoot.Size=Size
	return true
end

function Mover:SelectTarget(Root)
	-- First check if we can get..
	warn("HERE")
	print(self.MoverType,  self.MoverType == "Build")
	if self.MoverType == "Build" then
	
		local o = Instinct.Services.ObjectService:GetObject(Root.Name)
		local c = o:GetConstant("BuildingMaterial")
		print(#c)
		if #c==0 then
			self:SetStatus("This is not a building material!")
			return
		end
		for i,v in pairs(c) do
			if not v then
				self:SetStatus("This is not a building material!")
				return
			end
		end
		local size = Instinct.Services.ObjectService:GetSize(Root)
		if size.x < 1 or size.y  < 1 or size.z < 1 then
			self:SetStatus("This resource is too small.")
			return
		end

	end	
	
	
	self.GettingMoveRoot = true
	-- call server to lock resource for self.
	self:SetStatus("Trying to lock resource...")
	local CanGet, msg = Instinct.Communicator:Ask("RequestResourceLock", Root)
	
	if CanGet then
		self.MoveRoot = Root
		self.MoveRoot.Parent = game.Workspace 
	
		if Root:IsA("Model") then
			self.UseSize = Root:GetModelSize()
			function scan(f) 
				for i,v in pairs(f:GetChildren()) do
					if v:IsA("BasePart") then
						v.Anchored=true
						v.CanCollide=false
						v.Locked=true -- .. k
					end
					scan(v)
				end
			end
		
		else
			Root.Anchored=true
			Root.Locked=true
			Root.CanCollide=false
			self.UseSize = Root.Size
		end
		
		if self.MoverType == "Build" then
			local size = Instinct.Services.ObjectService:GetSize(Root)
			local rs = {x=size.x, y=size.y, z=size.z}
			for i,v in pairs(rs) do
				rs[i] = math.floor(v) -- round down to lowest.
			end
			self:SetRootSize(Vector3.new(rs.x,rs.y,rs.z))
		end
	else
		self:SetStatus(msg or "")
	end
	self.GettingMoveRoot = false

end

-- Move to close grid number
local function close(num, tonext)
	local upv = (num + (tonext - (num % tonext)))
	if upv - num > tonext * 0.5 then
		return (num - (num % tonext))
	end
	return upv
end



function Mover:ResetAngles()
	self.CurrentAngles = {0,0,0}
end

-- Function to clean up OldActions
function Mover:InitializeActionChange()
	if self.CurrentHandles then
		self.CurrentHandles:Destroy()
	end
	for i,v in pairs(self.RemConn) do
		v:disconnect()
	end
	self.RemConn = {}
end

function Mover:CanResize() -- should return false + err
	if self.MoveRoot:IsA("BasePart") then
		if self.MoveRoot:FindFirstChild("chParent") == nil then
			local o = Instinct.Services.ObjectService:GetObject(self.MoveRoot.Name)
			if o:GetConstant("ResizeTool") then
				local tr = o:GetConstant("ResizeTool")
				local tools = Instinct.Services.ToolService
				if tools.EquippedRight and tools.EquippedRight.Tool.Name == tr[1] then
					return true
				elseif tools.EquippedLeft and tools.EquippedLeft.Tool.Name == tr[1] then
					return true
				else
					return false, "You need a " .. tr[1] .. " equipped to resize this!"
				end
			end			
			
			return true
		else
			return false, "You cannot resize this resource!"
		end
	else
		return false, "You cannot resize this resource!"	
	end

end

function Mover:ToResizeMode()
	if self:CanResize() then
		
		self:InitializeActionChange()
		self.Mode = "Resize"
		self:SetStatus("Drag the handles to resize the resource.")
		local handles = Instance.new("Handles", game.Players.LocalPlayer.PlayerGui)
		handles.Adornee = self.MoveRoot
		handles.Style = "Resize"
		self.CurrentHandles = handles
		self.LockedCF = self:GetRootCFrame() -- origin cframe, can be used for resets
		self.OrigSize = self:GetRootSize()
		local last = {}
		setmetatable(last, {__index=function() return 0 end})
	
		local low = 0.2 
		handles.MouseDrag:connect(function(face, delta)
			if math.abs(last[face] - delta) >= self.StudIncrement then 
				local nDist = last[face] - delta
				local size_now = self:GetRootSize()
				local r = Enum.NormalId 

				local x,y,z = size_now.x, size_now.y, size_now.z 
				local dx, dy, dz = 0,0,0
				local fx,fy,fz = x,y,z
				local mod = 1
				local snap = close(nDist, self.StudIncrement)
				if face == r.Back then --
					z = -snap + z 
				elseif face == r.Right then 
					x = -snap + x 
				elseif face == r.Left then 
					mod = -1 -- ?
					x = -snap + x
				elseif face == r.Front then  --
					z = -snap + z
					mod = -1
				elseif face == r.Top then 
					y = -snap + y
					
				elseif face == r.Bottom then 
					y = -snap + y 
					mod = -1
				end
				print(face)
				last[face] = last[face] - nDist

				if x < low or y < low or z < low then 
					return 
				end
				local rcf = self:GetRootCFrame()
				local ok = self:SetRootSize(Vector3.new(x,y,z))
				local vec = Vector3.new(x,y,z) - Vector3.new(fx,fy,fz)
				if not ok then
					vec = Vector3.new(0,0,0)
				end
				local mod = (vec) * 0.5 * mod 
				--print(Vector3.new(offset.x, offset.y, offset.z))
				self.LockedCF = rcf * CFrame.new(mod)
				self:SetRootCFrame(self.LockedCF)-- * CFrame.new(Vector3.new(-use.x/2, -use.y/2, -use.z/2)))
			end
		end)
		--print("connectiong")
		-- ONLY GETS FIRED WHEN UP @ HANDLE, CONNECT TO UINPUT
		table.insert(self.RemConn, KeyService.KeyUp:connect(function(mouse, state)
			if mouse ~= "m1" then return end
		--	print("UP")
			for i,v in pairs(last) do
				last[i] = 0
			
			end

		end))
	end
end

function Mover:ToHandleMode()
	self:InitializeActionChange()
	self.Mode = "Move"
	self:SetStatus("Drag the handles to move the resource.")
	local handles = Instance.new("Handles", game.Players.LocalPlayer.PlayerGui)
	handles.Adornee = self.MoveRoot
	handles.Style = "Movement"
	self.CurrentHandles = handles
	self.LockedCF = self:GetRootCFrame() -- origin cframe, can be used for resets
	local offset = {x=0,y=0,z=0}
	local root = {x=0,y=0,z=0}
	handles.MouseDrag:connect(function(face, delta)
		--print(face)
		local cfd = { -- unit delta vectors.
			[Enum.NormalId.Top] = Vector3.new(0,1,0); --
			[Enum.NormalId.Back] = Vector3.new(0,0,1);  --
			[Enum.NormalId.Left] = Vector3.new(-1,0,0); --
			[Enum.NormalId.Right] =Vector3.new(1,0,0);
			[Enum.NormalId.Front] = Vector3.new(0,0,-1); --
			[Enum.NormalId.Bottom] = Vector3.new(0,-1,0); --
		}
		local mvpos = cfd[face] * delta
		--local rpos = Vector3.new(close(mvpos.x, self.StudIncrement), close(mvpos.y, self.StudIncrement), close(mvpos.z, self.StudIncrement))
		for _,i in pairs({"x", "y", "z"}) do
			if mvpos[i] ~= 0 then
				offset[i] = close(cfd[face][i] * delta, self.StudIncrement) + root[i]
			end
		end
		local vec = offset 
		self:SetRootCFrame(self.LockedCF * CFrame.new(Vector3.new(offset.x, offset.y, offset.z)))
	end)
	table.insert(self.RemConn, KeyService.KeyUp:connect(function(mouse, state)
		if mouse ~= "m1" then return end
		for i,v in pairs(offset) do
			root[i] = root[i] + v
		end
	end)
	)
	
end



function Mover:ToRotateMode()
	self:InitializeActionChange()
	self.Mode = "Rotate"
	local handles = Instance.new("ArcHandles", game.Players.LocalPlayer.PlayerGui)
	handles.Adornee = self.MoveRoot
	self:SetStatus("Drag the handles to rotate the resource.")
	self.CurrentHandles = handles
	self.LockedCF = self:GetRootCFrame() -- origin cframe, can be used for resets
	local offset = {X=0,Y=0,Z=0}
	local root = {X=0,Y=0,Z=0}
	handles.MouseDrag:connect(function(face, delta)
		--print(face)
		local mvpos = delta
		--local rpos = Vector3.new(close(mvpos.x, self.StudIncrement), close(mvpos.y, self.StudIncrement), close(mvpos.z, self.StudIncrement))
		for _,i in pairs({"X", "Y", "Z"}) do
			if face == Enum.Axis[i] then
				offset[i] = (close(delta, self.AngleIncrement) + root[i]) % (math.pi * 2)
			end
		end
		local vec = offset 
		--print(offset.X/(math.pi/2), offset.Y/(math.pi/2), offset.Z/(math.pi/2))
		self:SetRootCFrame( self.LockedCF * CFrame.Angles(offset.X, offset.Y, offset.Z))
	end)
	table.insert(self.RemConn, KeyService.KeyUp:connect(function(mouse, state)
		if mouse ~= "m1" then return end
		for i,v in pairs(offset) do
			root[i] = (root[i] + v) % (math.pi * 2)
		end
	end))
end

-- Where should targ move? (For Target mode)
function Mover:GetTransformedCFrame()
	-- Move MoveRoot away so we can get the current target and hit..
	self.MoveRoot.Parent = nil
	local Target = Mouse.Target
	local Hit = Mouse.Hit
	if not Target then return end
	
		-- Rotate
	local Rotates = {
		[Enum.NormalId.Top] = CFrame.Angles(0,0,0); --
		[Enum.NormalId.Back] = CFrame.Angles(math.pi/2,0,0);  --
		[Enum.NormalId.Left] = CFrame.Angles(0,0, math.pi/2); --
		[Enum.NormalId.Right] = CFrame.Angles(0, 0,-math.pi/2);
		[Enum.NormalId.Front] = CFrame.Angles(-math.pi/2, 0, 0); --
		[Enum.NormalId.Bottom] = CFrame.Angles(math.pi, 0, 0); --
	}	
	
	
	local Surface = (Mouse.TargetSurface)
	--print(Surface)
	
	-- Get a rotated cframe so we can get a "local axis" offset.
	local RotatedCFrame = (Target.CFrame * Rotates[Surface])


	self.MoveRoot.Parent = game.Workspace
	-- Strip rotation matrix..
	local TargetRot = RotatedCFrame:toObjectSpace(CFrame.new(Target.Position))
	
	local Hit = CFrame.new(Hit.p) * TargetRot -- rotate the cframe. (Just copy target cframe)
	-- Retrieve offset.
	local offset = RotatedCFrame:toObjectSpace(Hit).p;
	-- Tansform target (this strips the rotation of the hit cframe and aligns it)
	--print(offset)
	-- y is always UP; noffset the rest.
	local noffset = Vector3.new(close(offset.x, self.StudIncrement), offset.y, close(offset.z, self.StudIncrement))	
	--print(noffset)
	--local vcf = Target.CFrame * CFrame.new(noffset)
	
	
	--[[local CenterCF = Target.CFrame * Rotates[Surface] -- rotated;
	local CenterSize = Target.Size
	local CenterCF = CenterCF * CFrame.new(0, CenterSize/2, 0)
	local Offset = Hit:toObjectSpace(CenterCF)
	print(Offset.p)--]]
	local newcf = RotatedCFrame * CFrame.new(noffset)
	
	-- Specific wedgepart top surface chk
	if Target:IsA("WedgePart") then 
		if Surface == Enum.NormalId.Top then 
			local real_ang = math.atan2(Target.Size.x, Target.Size.z)
	--		print(real_ang)
			newcf = newcf * CFrame.Angles(-real_ang, 0, 0)
		end
	end
	

	
	local Transform = CFrame.Angles(unpack(self.CurrentAngles))
	-- Here are hooks for possible r/t keys to rotate!
	local ax, ay, az = self.CurrentAngles[1], self.CurrentAngles[2], self.CurrentAngles[3]
	
	local Size =  self:GetRootSize()/2
	local newSize = Vector3.new(Size.x * math.sin(ax), Size.y * math.cos(ay), Size.z * math.sin(az))
	
	--print(newSize)	

	return newcf * CFrame.new(newSize) * Transform
end

function Mover:ToMoveMode()
	if not self.MoveRoot then return end
	self:InitializeActionChange()
	self.Mode = "Target"
	self:SetStatus("The resource moves to the mouse cursor. Click to lock position.")
	local id = (self.ModeID or 0) + 1
	self.ModeID = id
	print("moving..")
	while self.MoveRoot and self.Mode == "Target" and self.ModeID == id do -- breaks other threads.
		
		local newCF = self:GetTransformedCFrame()
	--	print(newCF)
		if newCF then
			self:SetRootCFrame(newCF)
		end
		wait()
	end
end


if false then
delay(1, function()
	Mover:ToHandleMode()
	wait(1)
	Mover:ToRotateMode()
	wait(1)
	Mover:ToResizeMode()
end)
Mover:ToMoveMode()
end

return Mover]]></ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="Script" referent="RBXde3f23fe0f024f089fdcabbe6485c6cf">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Communicator</string>
				<ProtectedString name="Source"><![CDATA[local Communicator = {}

local IsLocal = (game.Players.LocalPlayer~=nil)

function Communicator:Constructor()
	if IsLocal then
		-- war has begun god dammit
		_G.Counter = (_G.Counter or 0) + 1
		local DEBOUNCER = _G.Counter or 0
		
		self.Commands = Instinct.Include("CommandsLocal")
		self.SendData = game:GetService("ReplicatedStorage").ServerSocket
		self.AskData = game:GetService("ReplicatedStorage").ServerAsk
		
		-- small env hack
		local ev = {}
		local function DISCONNECT()
			ev[1]:disconnect()
			ev[2]:disconnect()
			error("@------ DISCONNECTED FROM PREVIOUS EVENTS , ROBLOX GC FAILED? -----@")
		end
		
		ev[1] = self.SendData.OnClientEvent:connect(function(CommandName, ...)
			warn(_G.Counter, DEBOUNCER)
			if DEBOUNCER ~= _G.Counter then
				DISCONNECT()
			end
			print("<- " .. CommandName)
			if self.Commands[CommandName] then
				self.Commands[CommandName]({Type = "Event"}, ...)
			else

				warn(tostring(CommandName) .. " doesnt exist")
			end
		end)
		self.AskData.OnClientInvoke = function(CommandName, ...)
			print("<- " .. CommandName)
			--if DEBOUNCER ~= _G.Counter then
			--	DISCONNECT()
			--end
			if self.Commands[CommandName] then
				return self.Commands[CommandName]({Type="Function"}, ...)
			else
	
				warn(tostring(CommandName) .. " doesnt exist")
			end
		end
	else
		self.Commands = Instinct.Include("CommandsServer", "Server")
		self.SendData = game:GetService("ReplicatedStorage").ServerSocket
		self.AskData = game:GetService("ReplicatedStorage").ServerAsk
		self.AskData:Destroy() self.SendData:Destroy()
		local new = Instance.new("RemoteEvent", game:GetService("ReplicatedStorage"))
		new.Name = "ServerSocket"
		self.SendData = new
		local new = Instance.new("RemoteFunction", game:GetService("ReplicatedStorage"))
		new.Name = "ServerAsk"
		self.AskData = new
		
		self.SendData.OnServerEvent:connect(function(Player, CommandName, ...)
		print("<- " .. CommandName)
			if self.Commands[CommandName] then
				self.Commands[CommandName]({Type = "Event", Player=Player}, ...)
			else
		
				warn(tostring(CommandName) .. " doesnt exist")
			end
		end)
		self.AskData.OnServerInvoke = function(Player, CommandName, ...)
			print("<- " .. CommandName)
			if self.Commands[CommandName] then
				return self.Commands[CommandName]({Type="Function", Player=Player}, ...)
			else
				
				warn(tostring(CommandName) .. " doesnt exist")
			end
		end
	end
end

if IsLocal then 
	function Communicator:Send(Command, ...)
		print("-> " .. Command)
		self.SendData:FireServer(Command, ...)
	end
	function Communicator:Ask(Command, ...)
		print("-> " .. Command)
		return self.AskData:InvokeServer(Command, ...)
	end
else
	function Communicator:Send(Player, Command, ...)
		print("-> " .. Command)
		self.SendData:FireClient(Player, Command, ...)
	end
	function Communicator:Ask(Player, Command, ...)
		print("-> " .. Command)
		return self.AskData:InvokeClient(Player, Command, ...)
	end
	function Communicator:SendAll(Command, ...)
		print("-> " .. Command)
		self.SendData:FireAllClients(Command, ...)
	end
end

return Communicator]]></ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX8d20bff03a3e450891eb201d8dfcdb51">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">CommandsLocal</string>
				<ProtectedString name="Source"><![CDATA[-- Command gets called with info packet and data
local Commands = {}

local Chat = Instinct.Include "Chat"


function Commands.Test(Data, arg1)
	warn(arg1, "cmds work")
end

function Commands.Chat(Data, Message, Mode, Sender)
	warn("->>> CHAT")
	if Instinct.Gui and Instinct.Gui.Chat then 
		Instinct.Gui.Chat:Process(Message, Mode, Sender)
	end
end

function Commands.SetSkinColor(Data, Color)
	local ch = game.Players.LocalPlayer.Character
	for i,v in pairs(ch:GetChildren()) do
		if v:IsA("BasePart") then
			v.BrickColor = BrickColor.new(Color)
		end
	end
end

return Commands]]></ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBXa3b3d1423fb74967ba7a13b3c15bf3fc">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">CommandsServer</string>
				<ProtectedString name="Source"><![CDATA[local Commands = {}

local ObjectService = Instinct.Include "Services/ObjectService"
local Chat = Instinct.Include "Chat"
local DiscoveryService = Instinct.Include "Services/DiscoveryService"
local Tool = Instinct.Include "Action/Tool"
local ToolService = Instinct.Include "Services/ToolService"
local Object = Instinct.Include "Action/Object"

function Commands.DoPlayerDamage(Data, Target, Damage, Critical)
	if Target then
		local p = game.Players:GetPlayerFromCharacter(Target)
		if p then
			local hval = game:GetService("ReplicatedStorage"):WaitForChild("LocalPlayerData"):WaitForChild(tostring(p.userId)):WaitForChild("Stats"):WaitForChild("Health")
			hval.Value = hval.Value - Damage
		end
	end
end

function Commands.Chat(Data, Message)
	if Message == "" or Message:match("%S") == nil then
		return -- wat dafaq
	end
	print("HELLO")
	local Communicator = Instinct.Communicator
	local Player = Data.Player
	local Torso = Player.Character and Player.Character:FindFirstChild("Torso")
	if not Torso then return end
	local EnergyTap, Range, Mode, Message = Chat:GetAttributes(Message)	
	local get = game:GetService("ReplicatedStorage")
	local loc = (get:FindFirstChild("LocalPlayerData") and get.LocalPlayerData:FindFirstChild(tostring(Player.userId)) and get.LocalPlayerData[tostring(Player.userId)]:FindFirstChild("Stats") and get.LocalPlayerData[tostring(Player.userId)]:FindFirstChild("Stats"):FindFirstChild("Energy"))
	if not loc then return end
	if loc.Value - EnergyTap < 0 then
		Chat:Send("You don't have enough energy to do that!", Player)
		return
	end
	loc.Value = loc.Value - EnergyTap
	for i,v in pairs(game.Players:GetPlayers()) do
		if v.Character and v.Character:FindFirstChild("Torso") then
			if (v.Character.Torso.Position - Torso.Position).magnitude <= Range then
				Communicator:Send(v, "Chat", Message, Mode, Player.Name)
			end
		end
	end
	
end

function Commands.AddToBackpack(Data, item)
	if not item:IsDescendantOf(game.Workspace) then
		return -- what in the world!?
	end
	print("INTOADD", item:GetFullName())
	local p = Data.Player
	local bp = game:GetService("ReplicatedStorage"):WaitForChild("LocalPlayerData"):WaitForChild(tostring(p.userId)):WaitForChild("Backpack")
	
	-- ERMAGEWD	

	ObjectService:ToBackpack(item, bp)
	DiscoveryService:SetDiscovery("Resource", Data.Player, item.Name)

end

function Commands.Drop(Data, item)
	local p = Data.Player
	local char = p.Character
	if item.Parent:IsDescendantOf(game:GetService("ReplicatedStorage").LocalPlayerData) then 
		if char then
			if char:FindFirstChild("Torso") then
				local cf = char.Torso.CFrame
				local move = cf * CFrame.new(0,4,0)
				ObjectService:DropItem(item, move.p)
			end
		end
	end
	
end

local ToolEquipData = {} 
local ToolDropContainer = {}

function Commands.EquipTool(Data, Root, Hand, Grip)
	if not Root or not Hand then return end
	print(Grip)
	local Grip  = Grip
	if not Grip then Grip = CFrame.new() end
	local c = Root:Clone()
	if not game.Workspace:FindFirstChild("Garbage") then 
		Instance.new("Model", game.Workspace).Name = "Garbage"
	end 
	if not game.Workspace.Garbage:FindFirstChild("Tools") then
		Instance.new("Model", game.Workspace.Garbage).Name = "Tools"
	end
	if not game.Workspace.Garbage.Tools:FindFirstChild(Data.Player.Name) then
		Instance.new("Model", game.Workspace.Garbage.Tools).Name = Data.Player.Name
	end
	local weldto
	if Data.Player.Character then
		if Hand == "Left" then
			weldto = Data.Player.Character:FindFirstChild("Left Arm")
		elseif Hand == "Right" then
			weldto = Data.Player.Character:FindFirstChild("Right Arm")
		end
		Tool:CreateWelds(c, weldto, Grip, false)
		c.Parent =  game.Workspace.Garbage.Tools[Data.Player.Name]
		ToolEquipData[Root] = c
	end
	
end

function Commands.UnequipTool(Data, Root)
	if ToolEquipData[Root] then
		ToolEquipData[Root]:Destroy()
	end
end

-- root is the toolroot
function Commands.DropTool(Data, Root, DestrRes)
	local itemroot = Root.Tool:GetChildren()[1]
	if ToolEquipData[itemroot] then
		ToolEquipData[itemroot]:Destroy()
	end
	if Root.Name == "DefaultTool" then -- drop inside resources
		local res = Root.Items:GetChildren()[1]:GetChildren()[1]
		Tool:CreateWelds(res, nil, nil, true)
		local head = Data.Player.Character:FindFirstChild("Head")
		if head and res then
			res.CFrame = head.CFrame * CFrame.new(0,2,0)
		
			res.Parent = game.Workspace.Resources
		end
		Root:Destroy()
		if DestrRes then res:Destroy() end
	else
		local clone = itemroot
		Tool:CreateWelds(clone, nil, nil, true)
		local head = Data.Player.Character:FindFirstChild("Head")
		if head then
			clone.CFrame = head.CFrame * CFrame.new(0,2,0)
		end
		clone.Parent = game.Workspace.Tools 
		ToolDropContainer[clone] = Root
		Root.Parent = game:GetService("ServerStorage")
		if DestrRes then Root:Destroy() end
	end
end
-- if a tool is dropped in workspace tools then readd it to player here
-- toolroot is physical root item
function Commands.ReaddTool(Data, ToolRoot)
	if not ( ToolRoot:IsDescendantOf(game.Workspace.Tools)) then
		return
	end
	local Player = Data.Player
	if ToolDropContainer[ToolRoot] then
		local troot = Instinct.DataManager:GetContainer(Player, "Tools")
		if #(troot:GetChildren()) >= ToolService.MaxTools then 
			local Container = ToolDropContainer[ToolRoot]
			ToolRoot.Parent = Container.Tool
			Container.Parent = troot
		else
			Instinct.Chat:Send("You cannot equip the tool: " .. ToolRoot.Name .. " because you already have " .. ToolService.MaxTools .. " tools!", Player)
		end
	end
end

function Commands.RequestToolCreation(Data, Name, ObjectList, IsDefault)
	print(IsDefault)
	if IsDefault then 
		local scan = nil
		for i,v in pairs(ObjectList) do
			for ind, val in pairs(v) do
				scan = v
				break
			end
			if scan then break end
		end
		print(scan[1])
		ObjectService:ToBackpack(scan[1])
	end

	ToolService:CreateNormalTool(Data.Player, Name, ObjectList)
end


function Commands.DestroyResource(Data, What, Reason)
	if not What then return end
	if Reason == "KnappingError" then
		What:Destroy()
	end
end

-- tries to lock a resource.

ResourceLocks = {}

local function unlockres(p,anchor,collide)
	local data = ResourceLocks[p] 
	if data then 
		local origp = data.Parent
		local origr = data.Resource
		origr.Parent = origp
	
		for i,v in pairs(data) do
			print(i)
			if type(i) == "userdata" then
				i.CanCollide = collide or v.CanCollide
				i.Anchored = anchor or v.Anchored
			end
		end
		ResourceLocks[p] = nil
	end
end

function Commands.CancelResourceLock(Data, Resource)
	local Player = Data.Player
	if ResourceLocks[Player] and ResourceLocks[Player].Resource == Resource then
		unlockres(Player)
	end
	return true
end

function Commands.RequestResourceLock(Data, Resource)
	local Player = Data.Player
	if not Resource or Resource.Parent == nil then return end
	if ResourceLocks[Player] then -- WAT
		unlockres(Player)
	end
	for i,v in pairs(ResourceLocks) do
		if i.Parent then -- player exists;
			if v == Resource then
				return false, i.Name .. " is using this resource."
			end
		else
			unlockres(i)
		end
	end
	local op = Resource.Parent
	ResourceLocks[Player] = {Parent = op, Resource = Resource, CF = Resource.CFrame}
	Instinct.Services.ObjectService:ToBackpack(Resource) -- HAX [tonil]

	function fd(p)
		if p:IsA("BasePart") then
			ResourceLocks[Player][p] = {CanCollide = p.CanCollide, Anchored = p.Anchored}
			p.CanCollide = false
			p.Anchored=true
		end
		for i,v in pairs(p:GetChildren()) do
			fd(v)
		end
	end
	fd(Resource)
	Resource.Parent=nil
	return true
end

function Commands.RequestMove(Data, Resource, CFrame)
	local Player = Data.Player

	if ResourceLocks[Player] and ResourceLocks[Player].Resource == Resource then
		Instinct.Services.ObjectService:SetResourceCFrame(Resource, CFrame)
	--	ResourceLocks[Player].Parent = game.Workspace.Buildings


		print(Resource:GetFullName())
	--	Resource.Parent = game.Workspace.Buildings
		unlockres(Player, false, true)
		return true
	else
		 return  true
	end
end

---- TODO -----
-- ROTATED REOSURCES DO NOT WELD TO WORLD!
-- to fix: raycast and weld @ ground
-- players will have to offset their buildings tho, but.. well, kinda kewl still :)

function Commands.Build(Data, Resource, CFrame, Size)
	-- first move;
	local Player = Data.Player
	print("eval", ResourceLocks[Player] and ResourceLocks[Player].Resource == Resource )
	if ResourceLocks[Player] and ResourceLocks[Player].Resource == Resource then
		if Size then
			Instinct.Services.ObjectService:ResizeResource(Resource, Size, ResourceLocks[Player].Parent)
		end
		Instinct.Services.ObjectService:SetResourceCFrame(Resource, CFrame)
		ResourceLocks[Player].Parent = game.Workspace.Buildings
		function fd(p,func)
			if p:IsA("BasePart") then
				func(p)
			end
			for i,v in pairs(p:GetChildren()) do
				fd(v,func)
			end
		end
		fd(Resource, function(p)
					p.FrontSurface = "Universal"
					p.BackSurface = "Universal"
					p.BottomSurface = "Universal"
					p.LeftSurface = "Universal"
					p.TopSurface = "Universal"
					p.RightSurface = "Universal"
					p.Velocity = Vector3.new()
					p.AngularVelocity = Vector3.new()
		end)	
		Resource.Parent = game.Workspace.Buildings	
		fd(Resource, function(p)
			p:MakeJoints() -- yeah.
		end)
		print(Resource:GetFullName())
	--	Resource.Parent = game.Workspace.Buildings
		unlockres(Player, false, true)
		return true
	else
		return true
	end
	
end

function Commands.CreateKnap(Data, Original, CreatedName)
	print("OMG REATED", Original, CreatedName)
	if not Original or not CreatedName then return end
	local mkName = Original.Name
	local stCopy = game:GetService("ServerStorage").Mining:FindFirstChild(mkName)
	print(mkName)
	if mkName then
		local created = game:GetService("ReplicatedStorage").NewTools:FindFirstChild(CreatedName)
		print(created)
		if created then
			local root = created:Clone()
			local propcpy = {"Material", "BrickColor", "Reflectance", "Transparency"}
			ObjectService:CopyStyle(stCopy, root, propcpy)
			ObjectService:WeldObject(root)			
			
			
			root.Parent = game.Workspace
			root.CFrame = Original.CFrame
			print(root.CFrame)
			--delay(0, function() while wait() do print(root.CFrame) end end)
			Object:SetContext(root, "Material", mkName)
			print("done")
			root.CFrame = Original.CFrame
			Original:Destroy()

			
		end
	end
end

-- really ugly code here Q

local growt = {}

delay(0, function()
while wait(1) do
	for i,v in pairs(growt) do
		v:Grow()
		wait(0.2)
	end
end
end)

function Commands.Plant(Data, Handle, ToolRoot, Hit, Part)
	if Handle and Handle.Name == "Apple" and ToolRoot and Hit and Part then
			print(Hit, Part)
			local new = Instinct.Create(Instinct.World.Tree)
			local ok = new:Initialize(Hit.p, Part)
			if ok then 
				table.insert(growt,new)
				Commands.DropTool(Data, ToolRoot, true)
			else 
				Instinct.Chat:Send("There is no room to place that!", Data.Player)
			end
			
	end
end

function Commands.ChopTree(Data, Tree)
	if Tree and Tree.Name == "Wood" and Tree:IsDescendantOf(game.Workspace.Life) then
		print(Instinct.Services.ObjectService)
		local o = Instinct.Services.ObjectService:GetObject("Wood")
		local val = o:GetContext(Tree, "ChoppedDown")
		print(val)
		if val then
			if val == 1 then
				o:SetContext(Tree, "ChoppedDown", 2)
				Tree.Parent = game.Workspace.Resources 
				for i,v in pairs(Tree:GetChildren()) do 
					if v:IsA("BasePart") then 
						for ind, val in pairs(v:GetChildren()) do 
							if val:IsA("BasePart") then 
								val.Parent = game.Workspace.Resources 
								val:BreakJoints()
							end 
						end 
						v.Parent = game.Workspace.Resources 
						v:BreakJoints()
					end 
				end
			end
		else 
			o:SetContext(Tree, "ChoppedDown", 1)
			local w = Tree:FindFirstChild("Weld")
			w:Destroy()
			Tree.RotVelocity = Vector3.new(4,0,0)

		end
		for i, tree in pairs(growt) do
			if tree.TreeBase == Tree then
				tree.Disabled = true -- disable grows.
				table.remove(growt, i)
			end
		end
	end
end

function Commands.SwapBackpack(Data, Res)
	local p = Data.Player
	local bp = game:GetService("ReplicatedStorage"):WaitForChild("LocalPlayerData"):WaitForChild(tostring(p.userId)):WaitForChild("Backpack")
	if Res:IsDescendantOf( game:GetService("ReplicatedStorage").DroppedBackpacks) then
		Res.Parent = bp
	end
end

function Commands.DoDamage(Data, Enemy, Damage)
	
end

return Commands]]></ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBXcb8c01ec4a0448b89e9b2c110e35c219">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Resources</string>
				<ProtectedString name="Source"><![CDATA[return function()
print("loadfunc")
repeat wait() until _G.Instinct
local Instinct = _G.Instinct
local Object = Instinct.Include "Action/Object"
print("loaded object")
local ObjectService = Instinct.Include "Services/ObjectService"
local Property = Instinct.Include "Action/Property"
print('hi')
local new = Instinct.Create(Property)
new.Mode.ShowInfo = true
new.Name = "Material"
ObjectService:AddProperty(new)
print("add")

local FL = Instinct.Create(Object)
FL.Name = "Flower"
FL.SaveDataList = {"Size", "Color"}
FL.MoveRuleList = {"UnanchorAll", "UnweldAll", "Ungroup"}
FL.CheckGather = true -- no special function needed.
FL.Density = 0.01
FL.DamageType = "Crush"
FL.BaseDamage = 0.01
FL.Hardness = 0.01

local FLS = Instinct.Create(Object)
FLS.Name = "Flower Stalk"
FLS.SaveDataList = {"Size", "Color"}
FLS.MoveRuleList = {"UnanchorAll", "UnweldAll", "Ungroup"}
FLS.CheckGather = true
FLS.Density = 0.05
FLS.BaseDamage = 0.1
FLS.Hardness = 0.01
FLS.DamageType = "Cut"

ObjectService:AddObject(FL)
ObjectService:AddObject(FLS)

local Stone = Instinct.Create (Object)

Stone.Name = "Stone"
Stone.Material = "Stone"
Stone.ToolToGatherWhenAnchored = "Pickaxe"
Stone.SaveDataList = {"Size"}
Stone.MoveRuleList = {"UnanchorAll", "UnweldAll", "Ungroup"}
Stone.BuildingMaterial = true
Stone.Hidden = true -- hide stone from resources
Stone.BaseDamage = 3
Stone.DamageType = "Crush"

function Stone:CheckGather(Inst)
	if (Inst:IsA("BasePart") and Inst.Anchored) or Inst:FindFirstChild("Weld") then 
		return false, {"Use a pickaxe to gather this resource"}, "Mine"
	end
	return true
end

ObjectService:AddObject(Stone)


local ToolHead = Instinct.Create(Object)
ToolHead.SaveDataList = {}

ToolHead.CheckGather = true

function ToolHead:GetBaseDamage(Tool)
	local n = Tool.Tool.Name
	local obj = ObjectService:GetObject(n)
	local mat = obj:GetContext(Tool.Tool, "Material")[1]
	print(mat)
	if mat then
		local obj = self:GetObject(mat)
		if obj then
			return {Hardness = obj.Hardness, Density = obj.Density}
		end
	end
end

local Axe = ToolHead:CreateExtension("Axe")
Axe.DamageType = "Cut"
Axe.BaseDamage = 10
ObjectService:AddObject(Axe)
 
local Knife = ToolHead:CreateExtension("Knife")
Knife.DamageType = "Cut"
Knife.BaseDamage = 20
ObjectService:AddObject(Knife)

local Pickaxe = ToolHead:CreateExtension("Pickaxe")
Pickaxe.DamageType = "Hack"
Pickaxe.BaseDamage = 15
ObjectService:AddObject(Pickaxe)


local StoneTypes = {
	"General",
	"River",
	"Pressured",
	"Volcanic",
	"All"
}

local Instinct = _G.Instinct
print(Instinct.Option)
Instinct.Options = Instinct.Option
Instinct.Options.New("StoneType", StoneTypes)

local stonedata = {}

_G.StoneData = stonedata
stonedata.StonesInStoneType = {}

local data = {
	[Instinct.Options.StoneType.General] = {
			Flint = {
				Rarity = 0.75,
				OreBoost = "Chalcopyrite",
				Hardness = 4,
				Density = 2.6
			},
			Chert = {
				Rarity = 4,
				OreBoost = "Franklinite",
				Hardness = 2,	
				Density = 2.65			
				
			},
			Chalk = {
				Rarity = 6,
				OreBoost = "Malachite",
				Hardness = 1,	
				Density = 2.4			
			},
			Coal = {
				Rarity = 2.5,
				OreBoost = "Cuprite",
				Hardness = 3,
				Density = 1.4
			},
			Shale = {
				Rarity = 11,
				OreBoost = "Cassiterite",
				Hardness = 2,
				Density = 2.6
			},
		},
	[Instinct.Options.StoneType.River] = {
		Sandstone = {
			Rarity = 10,
			OreBoost = "Pyrite",
			Hardness = 5,
			Density = 2.6
		},
		Mudstone = {
			Rarity = 3,
			OreBoost = "Cuprite",
			Hardness = 1,
			Density = 2.7
		},
		Breccia = {
			Rarity = 1,
			OreBoost = "Bismite",
			Hardness = 4,
			Density = 2.5
		},
		Dolomite = {
			Rarity = 5,
			OreBoost = "Nordenskioldine",
			Hardness = 5,
			Density = 2.9
			
		},
		Limestone = {
			Rarity = 8,
			OreBoost = "Malachite",
			Hardness = 3,	
			Density = 2.5		
		}
	},
	[Instinct.Options.StoneType.Pressured] = {
		Blueschist = {
			Rarity = 1,
			OreBoost = "Pyrolusite",
			Hardness = 7,
			Density = 1.8
		},
		Gneiss = {
			Rarity = 8,
			OreBoost = "Malachite",
			Hardness = 6,
			Density = 2.9
		},
		Quartzite = {
			Rarity = 0.5,
			OreBoost = "Pentlandite",
			Hardness = 8,
			Density = 2.8
		},
		Marble = {
			Rarity = 3,
			OreBoost = "Cassiterite",
			Hardness = 7,
			Density = 2.5
		},
		Slate = {
			Rarity = 10,
			OreBoost = "Stannite",
			Hardness = 9,
			Density = 2.8
		}
	},
	[Instinct.Options.StoneType.Volcanic] = {
		Obsidian = {
			Rarity = 0.3,
			OreBoost = "Chromium",
			Hardness = 11,
			Density = 2.4
		},
		Andesite = {
			Rarity = 5,
			OreBoost = "Chalcopyrite",
			Hardness = 11,
			Density = 2.5
		},
		Latite = {
			Rarity = 8,
			OreBoost = "Hematite",
			Hardness = 10,
			Density = 2.2
		},
		Rhyolite = {
			Rarity = 4,
			OreBoost = "Cassiterite",
			Hardness = 14,			
			Density = 2.6
		},
		Feldspar = {
			Rarity = 12,
			OreBoost = "Malachite",
			Hardness = 18,
			Density = 2.6
			
		}
		
	}
	
}

for StoneType, StoneData in pairs(data) do 
	for name, data in pairs(StoneData) do 
		local obj = Stone:CreateExtension(name)

		local new = Stone:CreateExtension(name)
		new.StoneType = StoneType


		for setting, settingdata in pairs(data) do 
			new[setting] = settingdata
			obj[setting] = settingdata
		end
		_G.StoneData[name] = new
		new.Material = "Stone"
		ObjectService:AddObject(new)

		if _G.StoneData.StonesInStoneType[StoneType] then
			table.insert(_G.StoneData.StonesInStoneType[StoneType], new)
		else
			_G.StoneData.StonesInStoneType[StoneType] = {new}
		end
	end	

end

local holder = {}

local Ore = Instinct.Create(Object)

Ore.Name = "Ore"
Ore.CheckGather=true
Ore.SaveDataList = {"Size"}
Ore.DamageType = "Crush"
Ore.BaseDamage = 1

ObjectService:AddObject(Ore)


_G.OreData = holder
_G.OreData.OresInStoneType = {}


local data = {
	Chalcopyrite = {
		Contents = {Cu = 34.6, Fe = 30.4},
		Rarity = 8,
		StoneType = Instinct.Option.StoneType.General,
		Density = 4.1
	},
	Cuprite = {
		Contents = {Cu = 88.8},
		Rarity = 1,
		StoneType = Instinct.Option.StoneType.General,
		Density = 6.14
	},
	Malachite = {
		Contents = {Cu = 57.3},
		Rarity = 10,
		StoneType = Instinct.Option.StoneType.All,
		Density = 3.7,
	},
	Cassiterite = {
		Contents = {Sn = 78.8},
		Rarity = 1,
		StoneType = Instinct.Option.StoneType.All,
		Density = 7,
	},
	Stannite = {
		Contents = {Cu = 29.6, Sn = 27.6, Fe = 13.0},
		Rarity = 3,
		StoneType = Instinct.Option.StoneType.General,
		Density = 4.3
	},
	Nordenskioldine = {
		Contents = {Sn = 43.0},
		Rarity = 7,
		StoneType = Instinct.Option.StoneType.General,
		Density = 4.1
		
	},
	Sphalerite = {
		Contents = {Zn = 67.1},
		Rarity = 0.25,
		StoneType = Instinct.Option.StoneType.General,
		Density = 3.9
	},
	Franklinite = {
		Contents = {Zn = 27.1, Fe = 46.3},
		Rarity = 0.75,
		StoneType = Instinct.Option.StoneType.General,
		Density = 5.1
	},
	Pyrite = {
		Contents = {Fe = 46.5},
		Rarity = 10,
		StoneType = Instinct.Option.StoneType.Pressured,
		Density = 4.8
	},
	Bismuthinite = {
		Contents = {Bi = 81.3},
		Rarity = 0.6,
		StoneType = Instinct.Option.StoneType.River,
		Density = 6.8
	},
	Bismite = {
		Contents = {Bi = 89.7},
		Rarity = 0.3,
		StoneType = Instinct.Option.StoneType.River,
		Density = 8.7
	},
	Stibnite = {
		Contents = {Sb = 71.7},
		Rarity = 0.25,
		StoneType = Instinct.Option.StoneType.River,
		Density = 4.63
	},
	Cobaltite = {
		Contents = {As = 45.2},
		Rarity = 1,
		StoneType = Instinct.Option.StoneType.River,
		Density = 6.3
	},
	Hematite = {
		Contents = {Fe = 69.9},
		Rarity = 6,
		StoneType = Instinct.Option.StoneType.Volcanic,
		Density = 5.3
	},
	Pyrolusite = {
		Contents = {Mn = 63.2},
		Rarity = 0.8,
		StoneType = Instinct.Option.StoneType.Pressured,
		Density = 5.1
	},
	["Native Silver"] = {
		Contents = {Ag = 80.5},
		Rarity = 0.08,
		StoneType = Instinct.Option.StoneType.Pressured,
		Density = 10.1
	},
	["Native Gold"] = {
		Contents = {An = 75.3},
		Rarity = 0.01,
		StoneType = Instinct.Option.StoneType.River,
		Density = 17;
	},
	Pentlandite = {
		Contents = {Ni = 41.0},
		Rarity = 10	,
		StoneType  = Instinct.Option.StoneType.Pressured,
		Density = 4.6
	},
	Chromite = {
		Contents = {Cr = 41.9},
		Rarity = 0.2,
		StoneType = Instinct.Option.StoneType.Volcanic ,
		Density = 4.6
		
	},
	Galena = {
		Contents = {Pb = 86.6},
		Rarity = 4,
		StoneType = Instinct.Option.StoneType.Volcanic,
		Density = 7.6
	},
	Beryl = {
		Contents = {Si = 31.0},
		Rarity = 1,
		StoneType = Instinct.Option.StoneType.Volcanic,
		Density = 2.7
	}

}

_G.OreData.OresInStoneType = {}

for OreName, OreData in pairs(data) do
	local new = {}
	new.Name = OreName

	local obj = Ore:CreateExtension(OreName)


	for setting, value in pairs(OreData) do
		new[setting] = value
		obj[setting] = value 
	end
	obj.Material = "Ore"
	ObjectService:AddObject(obj)
	_G.OreData[OreName] = new
	if _G.OreData.OresInStoneType[OreData.StoneType] and OreData.StoneType ~= Instinct.Option.StoneType.All then 
		table.insert(_G.OreData.OresInStoneType[OreData.StoneType], new)
	elseif  OreData.StoneType ~= Instinct.Option.StoneType.All then
		_G.OreData.OresInStoneType[OreData.StoneType] = {new}
	end
	
end

local new = Instinct.Create(Object)
new.Name = "Wood"
new.BuildingMaterial = true
new.Material = "Wood"
new.ToolToGatherWhenAnchored = "Axe"
new.ToolToGatherWhenWelded = "Axe"
new.ResizeTool = "Axe"
new.GatherVolumeMaximum = 2^3
new.SaveDataList = {"Size", "Color"}
new.MoveRuleList = {"UnanchorAll", "UnweldAll", "Ungroup"}
new.DamageType = "Crush"
new.BaseDamage = 4-- stick epic damage
new.Density = 0.7-- depends on wood, add later.
new.Hardness = 3

function new:CheckGather(Inst)
	local val = self:GetContext(Inst, "ChoppedDown")
	if val == 1 then
		return false, {"Use an axe to remove the leaves"}, "Chop"
	elseif val == 2 then
		return true
	else 
		return false, {"Use an axe to chop the tree down"}, "Chop", {Left="Shake tree"}
	end
end

ObjectService:AddObject(new)


-- le foliage

local Foliage = Instinct.Create(Object)
Foliage.Name = "Foliage"
Foliage.BuildingMaterial =true
Foliage.GatherVolumeMaximum = 2^3
Foliage.Material = "Leaves"
Foliage.ResizeTool = "Knife"
Foliage.SaveDataList = {"Size", "Color"}
Foliage.MoveRuleList = {"UnanchorAll", "UnweldAll", "Ungroup"}
Foliage.DamageType = "Cut"
Foliage.Hardness = 0.05
Foliage.Density = 0.4

function Foliage:CheckGather(Inst)
	if Inst.Parent.Name == "Wood" then
		return false, {"Chop the tree down with an axe"}, nil
	else
		return true
	end
end
ObjectService:AddObject(Foliage)
-- NEED KNIVE WHEN ANCHORED ?

local Apple = Instinct.Create(Object)
Apple.Name = "Apple"
Apple.SaveDataList = {"Size", "Color"} -- realy
Apple.MoveRuleList = {"Unweld", "Unanchor"}
Apple.CheckGather = true
Apple.Edible = {Hunger = 10, Thirst = 3}; -- edible value per studs^3
Apple.Hardness = 0.05
Apple.Density = 0.8
Apple.DamageType = "Crush"
function Apple:CustomVolume(inst) -- custom volume function; 
	if inst:IsA("BasePart") then
		local r = inst.Size.x/2
		return math.pi * 4/3 * r^3
	end
end
ObjectService:AddObject(Apple)


------------------------------------
------------------------------------
------------------------------------
--									--
--			SAVING RULES 			--
------------------------------------

local function addr(r,name)
	r.Name=r.Name or name
	ObjectService:AddRule(r)
end

-- SIZE RULE --
local Size = {}
Size.To = function(inst)
	local size = inst.Size
	local out = {x=size.X, y = size.Y, z=size.Z}
	return out
end

Size.From = function(data, instance)
	instance.Size = Vector3.new(data.x, data.y, data.z)
end
addr(Size,"Size")

local Colour = {}
Colour.To = function(inst)
	return inst.BrickColor.Number
end
Colour.From = function(data, inst)
	inst.BrickColor = BrickColor.new(data)
end
addr(Colour, "Color") -- QQ

local MaterialContext = {}

function MaterialContext.From(data, inst)
	local propcpy = {"Material", "BrickColor", "Reflectance", "Transparency"}
	-- only checks for stones
	print("called", inst.Name)
	warn("CALLED!!")
	-- please make a "STYLE" rule
	ObjectService:CopyStyle(game:GetService("ServerStorage").Mining:FindFirstChild(data), inst, propcpy)
	-- please move this somewhere else.. --	
	ObjectService:WeldObject(inst)		
end

MaterialContext.To = function() end

addr(MaterialContext, "ContextMaterial") -- qq

---- MOVERULES
-----
------
------
-------
function addmvr(rule, name)
	ObjectService:AddMoveRule(rule,name)
end

local unanchor = function(r)
	if r:IsA("BasePart") then
		r.Anchored=false
	else
		warn("no unanchor for models")
	end
end
addmvr(unanchor, "Unanchor")


local unweld = function(r)
	r:BreakJoints() -- works for mods/parts
end
addmvr(unweld, "Unweld")

function generic_inmod(where, func)
	local x = where
	while x.Parent and not x.Parent:IsA("Model") do
		x = x.Parent
	end
	local mod
	if x.Parent.Parent == game.Workspace then 
		mod = x
	elseif x.Parent.Parent == game.Workspace.Mine then 
		mod =x
	else
		mod = x.Parent
	end
	print("inmod " .. where:GetFullName(), mod:GetFullName())
	local function re(where)
		for i,v in pairs(where:GetChildren()) do
			if v:IsA("BasePart") then
				func(v, mod)
			end
			re(v)
		end
	end
	re(mod)
	func(mod, mod)
end

local unweld_all = function(r)
	generic_inmod(r, function(c) c:BreakJoints() end)
end

local unanchor_all = function(r)
	generic_inmod(r, function(c) if c:IsA("BasePart") then c.Anchored=false end end)
end
addmvr(unweld_all, "UnweldAll")
addmvr(unanchor_all, "UnanchorAll")

local ungroup = function(r)
	local c = r
	while c.Parent and not c.Parent:IsA("Model") do
		c = c.Parent
	end
	local root
	if c.Parent.Parent == game.Workspace then 
		root = c
	elseif c.Parent.Parent == game.Workspace.Mine then 
		root =c 
	else
		root = c.Parent
	end
print("inmod " .. r:GetFullName(), root:GetFullName())
	local function re(where)
		for i,v in pairs(where:GetChildren()) do
			if v:IsA("BasePart") and v ~= r then
				if root == r then 
					v.Parent=root.Parent				
				else 
					v.Parent = root
				end
			end
			re(v, root)
		end
	end
	re(root, root)
end

addmvr(ungroup, "Ungroup")

end]]></ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBXf511e744a4ad40fb9cb6b72dad183da6">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Recipes</string>
				<ProtectedString name="Source"><![CDATA[return function()
	-- setup rules
local Instinct = _G.Instinct
local printm=function() end
local throw = function() end

local RecipeService = Instinct.Include "Services/RecipeService"
local ObjectService = Instinct.Include "Services/ObjectService"
local Recipe = Instinct.Include "Action/Recipe"

RecipeService:AddCategory("Furnace")


local functemplate = function (RuleData, RuleSet, RuleType, 
	Context, List, Recipe) end 


-- amount only function to receive the whole list
-- hard list of possible ingredients
-- returns a list of useable ingredients!
local function checkamount(arg)
	local ingwant = arg.RuleType[2]
	local have = 0
	local ok = false 
	local skipd = {"Explicit", "AmountType", "Same"}
	print(ingwant)
	if arg.List[ingwant] then 

			ok = true 
			for i = 1, #(arg.List[ingwant]) do 
				arg.List.Used:Add(ingwant, arg.List[ingwant][i])
			end 	
		 
	elseif not arg.RuleSet.Explicit then 
		for _,idata in ipairs(arg.List) do 
			local obj = idata[2]
			if obj:HasConstant("Name", ingwant) then 
				
				arg.List.Used:Add(ingwant, idata[1])

			--[[	if have >= RuleData then 
					ok = true 
					break 
				end--]]
			end 
		end
	end 
	return ok, skipd
end

local function checktemp(arg) 
	local mode = arg.RuleData[1]
	local eq = arg.RuleData[2] 
	if mode == "L" then 
		for i,v in ipairs(arg.List) do

			if arg.Mode == 2 then 
				printm("RuleCheck", "info", "check " .. arg.RuleType[2])
			end 
			local temp =  arg.List.Object:GetContext(v, "Temperature")
			if not temp then 
				throw("no temp var  found ")
				return false 
			end 
			if arg.Mode == 2 then 
				printm("RuleCheck", "info", "t value found, is " .. temp)
			end 
			if temp  > arg.RuleData[2] then 

			else 
				arg.WholeList.Used:Delete(RuleType[2], v)
				printm("RuleCheck", "info", "Removed " .. arg.RuleType[2] )
			end 
		end 
		return true 
	end 
end 

local function chkloc(loc, what )
	return loc:HasConstant( what,true )
end 

local function checkfurnace(arg)
	if arg.Context.Location then 
		return chkloc(arg.Context.Location, "IsFurnace")
	end 
end 

function checkmix(arg)
	if arg.Context.Location then 
		return chkloc(arg.Context.Location, "IsMetalMixingDevice")
	end 
end 

RecipeService:AddRule("Amount", checkamount)
RecipeService:AddRule("Temperature", checktemp)
RecipeService:AddRule("Furnace", checkfurnace)
RecipeService:AddRule("MetalMixingDevice", checkmix)

function debug(...)
	--print(...)
end

-- OK gather rule

function checkg(arg)
	local Context = arg.Context
	local exc = {(game.Workspace:FindFirstChild("Garbage") and game.Workspace.Garbage:FindFirstChild("Tools")), game.Workspace.Buildings}
	if Context and Context.Target then	
		local ok = Context.Target
		--print(ok:GetFullName())
		if false and ok:IsDescendantOf(game.Workspace.Resources) then 
			return true 
		elseif ObjectService:GetObject(ok.Name) then 
			for i,v in pairs(exc) do
			--	print("CHECK DESCENDANT", v, ok:GetFullName())
				if ok:IsDescendantOf(v) then
					table.insert(arg.WholeList.Used.WarningMessages, "CANNOTGATHER")
					return false
				end
			end
			if ok:IsDescendantOf(game.Workspace.Tools) then
				table.insert(arg.WholeList.Used.WarningMessages, "ISTOOL")
				return false
			end
			local o = ObjectService:GetObject(ok.Name)
			if not o then
				-- yeah get out 
				debug("no object")
				return false
			end
			--print(o)
			--[[if not o.IsAClass then
				debug("not a class")
				return false
			end--]]
			--print(o.IsAClass)
			--print(ok.Anchored)
			if false then -- not ok.Anchored and not ok:FindFirstChild("Weld") then
				debug("no anc, no weld, ok")
				return true
			else 
				local Volume = ObjectService:GetVolume(ok)
				local av = o:GetConstant("ToolAnchorVolumeMinimum")[1]
				local wv = o:GetConstant("ToolWeldVolumeMinimum")[1]
				local gv = o:GetConstant("GatherVolumeMaximum")[1]
				print(gv)
			
				-- Really ugly solution here..
				if ok.Name == "Foliage" and ok.Parent.Name == "Wood" then
					table.insert(arg.WholeList.Used.WarningMessages,"Chop tree down first with axe")
				end	
				if ok.Name == "Wood"  then
					local val = o:GetContext(ok, "ChoppedDown")
					print(val)
					if val == 1 then
						table.insert(arg.WholeList.Used.WarningMessages,"Remove leaves first with axe")
						return false
					elseif val == 2 then
						return true
					else
						table.insert(arg.WholeList.Used.WarningMessages,"Chop tree down first with axe")
						return false
					end
				end			
			
				
				
				if ok.Anchored then
					if av and Volume <= av then 
						debug("volume smaller than minimum, okay")
						return true
					end
					local tool = o:GetConstant("ToolToGatherWhenAnchored")
					if tool and #tool > 0 then 
						debug("can gather with tool")
						table.insert(arg.WholeList.Used.WarningMessages, tool[1] .. " to gather")
					else 
						debug("no tool provided")
						return false
					end
				elseif ok:FindFirstChild("Weld") and #(o:GetConstant("ToolToGatherWhenWelded")) > 0 then
					if av and Volume <= av then 
						debug("volume smaller than minimum, okay")
						return true
					end
					local tool = o:GetConstant("ToolToGatherWhenAnchored")
					if tool and #tool > 0 then 
						debug("can gather with tool")
						table.insert(arg.WholeList.Used.WarningMessages, tool[1] .. " to gather")
					else 
						debug("no tool provided")
						return false
					end
					
				elseif gv then
					if gv and Volume <= gv then
						debug("volume smaller ok")
						return true
					end
					local tool = o:GetConstant("ToolToShrink")
					if tool and #tool > 0 then
						debug("tool provided")
						table.insert(arg.WholeList.Used.WarningMessages, tool[1] .. " to gather")
					else 
						table.insert(arg.WholeList.Used.WarningMessages, "Too large to gather")
						return false
					end	
				end 
			end
		end 
	end
end	

RecipeService:AddRule("Gather", checkg)	
	
local gather = Instinct.Create(Recipe)
gather.Context = {Gather=true}	
	
RecipeService:AddRecipe(gather, "Gather")	
	
end]]></ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX892ac3cf0e5549b38fca289055499807">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Chat</string>
				<ProtectedString name="Source"><![CDATA[local Chat = {}

-- Chat provides everything necessary for backend chat. GUI should be loaded from anything else.

local IsLocal = (game.Players.LocalPlayer ~= nil)



Chat.EnergyTap = {
	Global = 50;
	Shout = 25;
	Yell = 10;
	Default = 0;
	Whisper = 0;
}

Chat.Range = {
	Global = math.huge;
	Shout = 300;
	Yell = 200;
	Default = 100;
	Whisper = 20;
}

Chat.Keywords = {
	["g/"] = "Global";
	["s/"] = "Shout",
	["y/"] = "Yell",
	["w/"] = "Whisper",
	["d/"] = "Default",
}

function Chat:Send(Message, Player)
	local Communicator = Instinct.Communicator
	if IsLocal then

		Communicator:Send("Chat", Message, Player.Name)
	else
		Communicator:Send(Player, "Chat", Message, "Default", "_host")
	end
end

function Chat:SendGlobal(Message)
	local Communicator = Instinct.Communicator
	Communicator:SendAll("Chat", Message, "Default", "_host")
end

-- returns energytap, range and "real message"
function Chat:GetAttributes(message)
	local mode = message:sub(1,2)
	local cmode = self.Keywords[mode] or "Default"
	local cmsg = message
	if self.Keywords[mode] then
		cmsg = message:match(mode.."%s*(.+)")
	end
	cmsg = self:FixMessage(cmsg)
	return self.EnergyTap[cmode], self.Range[cmode], (self.Keywords[mode] or "Default"), cmsg
end

-- makes msg nice.
function Chat:FixMessage(msg)
	if not msg then return "" end
	-- fix first
	local msg = msg:gsub("^%W*%w", function(what)  return string.upper(what) end)
	--local msg = msg:gsub("%.%W%w", function(what) print(2, what) return string.upper(what) end)
	local msg = msg:gsub("%.%s*%l", function(qq) return string.upper(qq) end)
	local msg = msg:gsub("\n", function(qq) return "" end)
	if msg:len() > 150 then
		msg = msg:sub(1,150)
	end
	return msg
end

return Chat]]></ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBXe76744ef8cc443e38759b55e8b5561f3">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">DataManager</string>
				<ProtectedString name="Source"><![CDATA[local DataManager = {}

function DataManager:GetRoot(player)
	if game:GetService("ReplicatedStorage"):FindFirstChild("LocalPlayerData") then
		return game:GetService("ReplicatedStorage"):FindFirstChild("LocalPlayerData"):FindFirstChild(tostring(player.userId))
	end
end

function DataManager:GetContainer(player, name)
	local root =self:GetRoot(player)
	if root then
		return root:FindFirstChild(name)
	end
	
end



return DataManager]]></ProtectedString>
			</Properties>
		</Item>
		<Item class="Model" referent="RBXa5f08982ffb9493c9887f2298281b1a3">
			<Properties>
				<CoordinateFrame name="ModelInPrimary">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<string name="Name">Windows</string>
				<Ref name="PrimaryPart">null</Ref>
			</Properties>
			<Item class="Script" referent="RBX743bc86a90e641f4be956d661e12e0bb">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Discoveries</string>
					<ProtectedString name="Source"><![CDATA[local Discovery = {}

local ScrollBar = Instinct.Include "Gui/ScrollBar"
local Palette = Instinct.Include "Utilities/Palette"
local SFX = Instinct.Include "Gui/SFX"

local ObjectService = Instinct.Include "Services/ObjectService"

function Discovery:Constructor()
	self.Tabs = {}
	self.Data = {}
end

function Discovery:ShowTab(Which)
	local wind = self
	if not self.Tabs[Which] then 
		self.Data[Which] = {}
		local new = Instinct.Create(ScrollBar)
		new.Parent = self.Window.Canvas
		new:Create(UDim2.new(0.8, 0, 0.8, 0))
		new.Root.Position = UDim2.new(0.1, 0, 0.1, 0)
		function new:Add(name, discoverer, tabletitle)
			local Container = Instance.new("Frame")
			Container.Size = UDim2.new(1,0,0, 22)
			Container.BackgroundTransparency=1
			
			local text = Instance.new("TextLabel", Container)
			text.BackgroundColor3 = Palette:Get("Shade1", "Shade2")
			if tabletitle then
				text.BackgroundColor3 = Palette:Get("Shade1", "Shade3")
			end
			text.TextColor3 = Palette:Get("Text", "White")
			text.TextStrokeTransparency = 0
			text.TextStrokeColor3 = Palette:Get("Text")
			text.Font = "ArialBold"
			text.FontSize = "Size18"
			text.Text = name
			text.BorderSizePixel=0
			text.Size = UDim2.new(0.4,0,  0, 20)
			local main=text
			local text = Instance.new("TextLabel", Container)
			text.BackgroundColor3 = Palette:Get("Shade1", "Shade2")
			if tabletitle then
				text.BackgroundColor3 = Palette:Get("Shade1", "Shade3")
			end
			text.BorderSizePixel=0
			text.TextColor3 = Palette:Get("Text", "White")
			text.TextStrokeTransparency = 0
			text.TextStrokeColor3 = Palette:Get("Text")
			text.Font = "ArialBold"
			text.FontSize = "Size18"
			text.Text = discoverer or "No one yet."
			if not discoverer then
				text.BackgroundColor3 = Palette:Get("Shade1", "Shade1")
			elseif discoverer == game.Players.LocalPlayer.Name then
				text.BackgroundColor3 = Palette:Get("Complement", "Shade1")
			end
			text.Size = UDim2.new(0.4, 0, 0, 20)
			text.Position = UDim2.new(0.5,0,0,0)
			SFX.Shade(text, 2)
			SFX.Shade(main, 2)
			if not tabletitle then
		
				wind.Data[Which][name] = {Name = main, Discoverer = text}
			end
			return Container
		end
		self.Tabs[Which] = new
		new:AddToStart("Resource name", "Discoverer", true)
		
				
		
		
		if Which == "Resource" then 

			
			local  mknames = {}
			for ObjName in pairs(ObjectService.ObjectData) do
				if not self.Tabs[Which][ObjName] then
					table.insert(mknames, ObjName)
				end
			end
			table.sort(mknames)		
			local check = game:GetService("ReplicatedStorage"):FindFirstChild("Discoveries")	
			for i,name in pairs(mknames) do
				local disc = check:FindFirstChild("Resource")
				local discoverer

				if disc then
					if disc:FindFirstChild(name) then
						discoverer = disc[name].Value
					end
				end
				new:AddToEnd(name,discoverer)
			end
						
			
			if check then
				if check:FindFirstChild("Resource") then
					check.Resource.ChildAdded:connect(function(what)
						local objname = what.Name
						local discoverer = what.Value
						local data = self.Data[Which][objname]
						if data then
							local gui = data.Discoverer
							gui.Text = discoverer
							if discoverer == game.Players.LocalPlayer.Name then
								gui.BackgroundColor3 = Palette:Get("Complement", "Shade1")
							end
						end
					end)
				end
			end
		end
	end
end


function Discovery:Open(Window)
	print(Window.Canvas:GetFullName())
	self.Window = Window
	self:ShowTab("Resource")
end

function Discovery:Close(Window)
	print('final')
end

return Discovery]]></ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="Script" referent="RBX1665c2c58634499a88523adbda31dbe6">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Tools</string>
				<ProtectedString name="Source"><![CDATA[return function()

local Tool = Instinct.Include "Action/Tool"
local ToolService = Instinct.Include "Services/ToolService"
local ObjectService = Instinct.Include "Services/ObjectService"
local Knapping = Instinct.Include "Action/Knapping"
 
local Mover
local NormalMover
if game.Players.LocalPlayer then
	local CMover = Instinct.Include "Action/Mover"
	Mover = Instinct.Create(CMover)
	Mover.MoverType = "Build"
	Mover:CreateBuilder()
	CMover.Builder = Mover
	NormalMover = Instinct.Create(CMover)
	NormalMover.MoverType = "Move"
	CMover.Mover = NormalMover
	NormalMover:CreateMover()
	ToolTip = Instinct.Include "Gui/ToolTip"
	NutritionService = Instinct.Include "Services/NutritionService"
end

local Eat = Instinct.Create(Tool)
Eat.Type = "NonPhysical"
Eat.Name = "Eat"

function Eat:Create() end

function Eat:OnEquip()
	Instinct.Services.KeyService.State = "Eating"
	self.Gui = Instinct.Create(ToolTip)
	self.Cache = {}
	--self.Gui:Hide()
	delay(0, function()
		local Mouse = game.Players.LocalPlayer:GetMouse()
		while Instinct.Services.KeyService.State == "Eating" do
			
			
			local targ = Mouse.Target
			if targ and NutritionService:IsEdible(targ) then
				local data = NutritionService:GetNutritionInfo(targ)
				local use = {}
				for i,v in pairs(data) do
					local val = ((math.floor(v*100 + 0.5)-0.5)/ 100) 
					table.insert(use, {"info", i..": "..val})
				end
				table.insert(use,{"info", "Left click to eat!"})
				self.Gui:Show(targ, {}, use)
			--	warn('show')
				self.Cache[targ] = data
			else 
				self.Gui:Hide()
			--	warn('hide')
			end
			wait()		
			if targ then
				self.Cache[targ] = nil -- GC last targ [ifexist]
			end
		end
	end)
end

function Eat:OnUnequip()
	Instinct.Services.KeyService.State = "Default"
	self.Cache = {}
	self.Gui:Destroy()
end

function Eat:DoAction(mbutton)
	if mbutton == "m1" then
		local Mouse = game.Players.LocalPlayer:GetMouse()
		local targ = Mouse.Target
		if self.Cache[targ or ""] then
			NutritionService:Eat(targ, self.Cache[targ])
		end
	end
end

ToolService:RegisterTool("Eat", Eat)


local Move = Instinct.Create(Tool)
Move.Type = "NonPhysical"
Move.Name = "Move"

function Move:Create() end

function Move:OnEquip()
	Instinct.Services.KeyService.State = "Moving"
end

function Move:OnUnequip()
	Instinct.Services.KeyService.State = "Default"
	if NormalMover.MoveRoot then
		-- should not abort but just move.
		NormalMover:Confirm()
	end

end

function Move:DoDBCAction(key)
	 NormalMover:DoubleClicked(key)
end

function Move:DoAction(mbutton)
	print(mbutton, mbutton == "m1")
	if mbutton == "m1" then
		print(NormalMover.MoveRoot)
		if NormalMover.MoveRoot == nil then
			local Mouse = game.Players.LocalPlayer:GetMouse()
			local targ = Mouse.Target
			local usetarg = Instinct.Services.ObjectService:GetMainPart(targ)
			local o = Instinct.Services.ObjectService:GetObject((usetarg and usetarg.Name) or "")
			print(usetarg)
			local Char = game.Players.LocalPlayer.Character
			if Char then 
				if Char:FindFirstChild("Torso") then
					if (Char.Torso.Position - Mouse.Hit.p).magnitude > 20 then
						return
					end
				end
			end
			if usetarg and o then 
				local rec = Instinct.Services.RecipeService.Categories.Gather[1]
				local warns = Instinct.Services.RecipeService:CheckRecipe(rec, {Target=usetarg}, {})
				local ok = true 
				for i,v in pairs(warns) do
					if v[1] == "CANNOTGATHER" or v[1] == "ISTOOL" then
						print(v[1], "cannot move because")
						ok=false
						break
					end
				end
				if ok then				
					local usewarn = warns.WarningMessages
					if #usewarn == 0 then
						
					else
						print("not 0")
						for i,v in pairs(usewarn) do
							print(v)
							if v == "Too large to gather" then
								-- no prob
								
							else 
								ok = false
								break
							end
						end
					end
					print("ok?" , ok)
					if ok then
						local omg = Instinct.Services.ObjectService:GetMainPartRoot(targ)
						if omg then
							if not NormalMover.GettingMoveRoot then
								print(omg:GetFullName())
								NormalMover:SelectTarget(omg)
								NormalMover:ToMoveMode()
							end
						end
					end
				else 
					-- not ok to build with this resource!
				end
			end
		else
			print("->clicked")
			NormalMover:Clicked(mbutton)
		end
	end
end
ToolService:RegisterTool("Move", Move)


local Build = Instinct.Create(Tool)
Build.Type = "NonPhysical"
Build.Name = "Build"

function Build:Create()
	
end

function Build:OnEquip()
	if Instinct.Gui and Instinct.Gui.SideBar then 
		Instinct.Gui.SideBar:ForceClose()
	end
	Instinct.Services.KeyService.State = "Building"
	Mover.Gui.BuildGui.Visible = true
end

function Build:OnUnequip()
	if Instinct.Gui and Instinct.Gui.SideBar then 
		Instinct.Gui.SideBar:EnableOpen()
	end
	Instinct.Services.KeyService.State = "Default"
	if Mover.MoveRoot then
		Mover:Abort()
	end
	Mover.Gui.BuildGui.Visible=false
end

function Build:DoDBCAction(key)
	Mover:DoubleClicked(key)
end

function Build:DoAction(mbutton)
	print(mbutton, mbutton == "m1")
	if mbutton == "m1" then
		print(Mover.MoveRoot)
		if Mover.MoveRoot == nil then
			local Mouse = game.Players.LocalPlayer:GetMouse()
			local targ = Mouse.Target
			local usetarg = Instinct.Services.ObjectService:GetMainPart(targ)
			local o = Instinct.Services.ObjectService:GetObject((usetarg and usetarg.Name) or "")
			print(usetarg)
			local Char = game.Players.LocalPlayer.Character
			if Char then 
				if Char:FindFirstChild("Torso") then
					if (Char.Torso.Position - Mouse.Hit.p).magnitude > 20 then
						return
					end
				end
			end
			if usetarg and o then 
				local rec = Instinct.Services.RecipeService.Categories.Gather[1]
				local warns = Instinct.Services.RecipeService:CheckRecipe(rec, {Target=usetarg}, {})
				local ok = true 
				for i,v in pairs(warns) do
					if v[1] == "CANNOTGATHER" or v[1] == "ISTOOL" then
						ok=false
						break
					end
				end
				if ok then				
					local usewarn = warns.WarningMessages
					if #usewarn == 0 then
						
					else
						for i,v in pairs(usewarn) do
							if v == "Too large to gather" then
								-- no prob
								
							else 
								ok = false
								break
							end
						end
					end
					print("ok?" , ok)
					if ok then
						local omg = Instinct.Services.ObjectService:GetMainPartRoot(targ)
						if omg then
							if not Mover.GettingMoveRoot then
								print(omg:GetFullName())
								print("SELECTING TARGET")
								Mover:SelectTarget(omg)
								Mover:ToMoveMode()
							end
						end
					end
				else 
					-- not ok to build with this resource!
				end
			end
		else
			print("->clicked")
			Mover:Clicked(mbutton)
		end
	end
end
ToolService:RegisterTool("Build", Build)

local DefaultTool = Instinct.Create(Tool)

local function inrange()	
	local center = game.Players.LocalPlayer.Character:FindFirstChild("Torso")
	return (center.Position - game.Players.LocalPlayer:GetMouse().Hit.p).magnitude < 10
end
function DefaultTool:Create(TRoot, ObjData)
	local find
	print('scan')
	for objname, objdata in pairs(ObjData) do
		print(objname, objdata)
		for i, item in pairs(objdata) do
			print(i,item)
			find = item
			break
		end
		if find then
			break
		end
	end
	if find then
		local this = find:Clone()
		this.Parent = TRoot
	end
	
	return self -- always
end


function DefaultTool:DoAction(button)
	print(self.Tool.Name)
	local o = ObjectService:GetObject(self.Tool.Name)
	print(o)
	if o and inrange() then
		local mat = o:GetConstant("Material")
		print(mat)
		if mat[1] == "Stone" then
			-- is a hammerstone. 
			print("IS HAMMERSOTNE")
			local Mouse = game.Players.LocalPlayer:GetMouse()
			if Mouse.Target and Mouse.Target:IsDescendantOf(game.Workspace.Resources) then 
				local target = ObjectService:GetObject(Mouse.Target.Name)
				if target then 
					local mat = target:GetConstant("Material")
					if mat[1] == "Stone" then
						-- omg
						Knapping:Knap(Mouse.Target)
					end
				end
			end
		elseif self.Tool.Name == "Apple" then
			local Mouse = game.Players.LocalPlayer:GetMouse()
			if Mouse.Target and Mouse.Target.Name == "FertileGround" then 
					Instinct.Communicator:Send("Plant", self.Tool, self.ToolRoot, Mouse.Hit, Mouse.Target)
			end
				
		elseif self.Tool.Name == "Axe" then
			local Mouse = game.Players.LocalPlayer:GetMouse()
			if Mouse.Target then 
				local target = ObjectService:GetObject(Mouse.Target.Name)
				if target then 
					local c = target:GetContext(Mouse.Target, "ChoppedDown")
					if c == nil or c == 1 then 
						Instinct.Communicator:Send("ChopTree", Mouse.Target)
					end
				end
			end
		end 
	end
end

function DefaultTool:CacheAction()
	--	print(self.Tool.Name)
	local o = ObjectService:GetObject(self.Tool.Name)
--	print(o)
	if o then
		local mat = o:GetConstant("Material")
		--print(mat)
		if mat[1] == "Stone" then
			-- is a hammerstone. 
			print("IS HAMMERSOTNE")
			local Mouse = game.Players.LocalPlayer:GetMouse()
			if Mouse.Target then 
				local target = ObjectService:GetObject(Mouse.Target.Name)
				if target then 
					local mat = target:GetConstant("Material")
					if mat[1] == "Stone" then
						-- omg
						return "Knap"
					end
				end
			end
		elseif self.Tool.Name == "Apple" then
			local Mouse = game.Players.LocalPlayer:GetMouse()
			if Mouse.Target and Mouse.Target.Name == "FertileGround" then 
					return "Plant"
			end
				
		elseif self.Tool.Name == "Axe" then
			local Mouse = game.Players.LocalPlayer:GetMouse()
			if Mouse.Target then 
				local target = ObjectService:GetObject(Mouse.Target.Name)
				if target and target.Name == "Wood" then 
					local c = target:GetContext(Mouse.Target, "ChoppedDown")
					if c == nil or c == 1 then 
						return "Chop"
					end
				end
			end
		end
	end
end

function DefaultTool:GetGrip()
	print('get grip')
	local norm = self.Tool
	local other = CFrame.new()
	if norm then
		other = CFrame.new(0, -0.5, 0)
	end
	return CFrame.new(0, -1, 0) * CFrame.Angles(math.pi/2,0,0) * other
end

ToolService:RegisterTool("DefaultTool", DefaultTool)

end]]></ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX0214098412044d06a71f737d498ac687">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Clothing</string>
				<ProtectedString name="Source"><![CDATA[return (function() local toadd = {}
local function mk(n)
	local o = {Name=n}
	table.insert(toadd,o)
	return o
end

local ClothingService = Instinct.Include "Services/ClothingService"

local dr = game:GetService "ServerStorage"
local r = dr.Clothing

Backpack = mk "Backpack"
Backpack.Grip = CFrame.new(0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1) * CFrame.Angles(0,math.pi,0)
Backpack.Root = r.Backpack
Backpack.BodyPart = "Torso"

Shirt = mk "Shirt"
Shirt.Grip = CFrame.new(0,-0.2, 0.04, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Shirt.Root = r.Shirt
Shirt.BodyPart = "Torso"

LeftPants = mk "LeftPants"
LeftPants.Grip = CFrame.new(0, 0.42, 0.01, 1, 0, 0, 0, 1, 0, 0, 0, 1)
LeftPants.Root = r.LeftPants
LeftPants.BodyPart = "Left Leg"

RightPants = mk "RightPants"
RightPants.Grip =  CFrame.new(0, 0.42, 0.01, 1, 0, 0, 0, 1, 0, 0, 0, 1)
RightPants.Root = r.RightPants
RightPants.BodyPart = "Right Leg"

for i,v in pairs(toadd) do
	ClothingService:AddCloth(v)
end
end)]]></ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX6eafde98e0ac4193817ad0644cd2f1c6">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Actions</string>
				<ProtectedString name="Source"><![CDATA[return (function()
local IntentionService = Instinct.Include "Services/IntentionService"
local ToolService = Instinct.Include "Services/ToolService"
local DamageService = Instinct.Include "Services/DamageService"
local toadd ={}
local function mk(name)
	local o = {Name=name}
	table.insert(toadd, o)
	return o
end

local InspectBackpack = mk "Inspect Backpack"

local IBS_Open = nil; -- inspect backpack open debouncher.

function InspectBackpack:Run(targ)
	if IBS_Open then
		return --no.
	end
	local r = targ
	if targ.Name ~= "Backpack" then
		if targ.Name == "chParent" then 
			r = targ.Parent
		end
	end
	if r and r:FindFirstChild("BPRootLocation") then
		if r.BPRootLocation.Value then
			-- good. let's get sidebar.
			local newsidebar = Instinct.Create(Instinct.Gui.SideBar)
			IBS_Open = newsidebar
			local root = r.BPRootLocation.Value
			Instinct.Gui.SideBar:ForceClose() --> close own inventory.
			
			newsidebar.Root.Sidebar.RealBar.Tabs:ClearAllChildren()
			local close_button_loc = newsidebar.Root.Sidebar.RealBar.Tabs
			local new = Instance.new("TextButton", close_button_loc)
			new.Size = UDim2.new(0.9, 0, 0.9, 0)
			new.Position = UDim2.new(0.05, 0, 0.05,0)
			new.BackgroundTransparency = 0.8
			new.Text = "Close"
			new.FontSize = Enum.FontSize.Size24
			new.Font = Enum.Font.SourceSans
			new.BorderSizePixel=0
			new.ZIndex=3
			
			new.MouseButton1Click:connect(function()
				newsidebar:Destroy() -- removes gui.
				IBS_Open = nil
				Instinct.Gui.SideBar:EnableOpen()
			end)
			
			for i,v in pairs(root:GetChildren()) do
				newsidebar:AddBackpackItem(v)
			end
			root.ChildRemoved:connect(function(v)
				newsidebar:RemoveBackpackItem(v)
			end)
			
			function newsidebar:RequestDrop(v)
				local comm = Instinct.Communicator
				comm:Send("SwapBackpack", v)
			end
			
			-- we are done; open
			newsidebar:MakeVisible() -- done drawing
			newsidebar:Open()
		end
	end
end
	
	
local ShakeTree = mk "Shake tree"

function ShakeTree:Run(targ)
	print("oh very shake tree")
end

local Attack = mk "Attack"

function Attack:Run(Targ, Hand)
	print("WAT attack?")
	local Tool = ToolService["Equipped"..Hand]
	print(Tool, Hand)
	if Tool then
		print("EXISITS")
		DamageService:Attack(Tool, Targ)
	end
end

for _,action in pairs(toadd) do
	IntentionService:AddAction(action)
end
	
end)]]></ProtectedString>
			</Properties>
		</Item>
	</Item>
</roblox>